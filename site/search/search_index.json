{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MagnetoPy","text":""},{"location":"#installation","title":"Installation","text":"<p>While MagnetoPy is still in development, install directly from the GitHub repository:</p> <pre><code>pip install git+https://github.com/RinehartGroup/MagnetoPy.git\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation is available at https://rinehartgroup.github.io/MagnetoPy/.</p>"},{"location":"#what-is-magnetopy-and-why-is-it-useful","title":"What is MagnetoPy and why is it useful?","text":"<p>MagnetoPy is a Python package containing tools to aid researchers in the analysis of magnetic data, with a particular emphasis on aiding researchers in developing and publishing new analyses. It contains robust and flexible methods for parsing and processing data files and transforming the data into standard interfaces from which researchers can perform their research. It also contains some record keeping capabilities such that any processing steps performed on the data can be recorded and reproduced at a later date.</p> <p>MagnetoPy is built with a primary focus on in-depth analysis of magnetic data and development of new analyses. For this reason we mostly envision users of MagnetoPy using it in a notebook environment (e.g., Jupyter notebooks). Once an analysis becomes routine, however, using MagnetoPy as a library in a script is also possible, and will make script/app development easier.</p>"},{"location":"#experiment-and-data-file-interfaces","title":"Experiment and Data File Interfaces","text":"<p>Scientific data analysis typically follows a similar pattern: data is collected, parsed, processed, analyzed, and reported. Each step has some code associated with it. Without some forethought and planning with regard to the architecture, however, the code for each step can become tightly coupled to the code for the other steps. This can make it difficult to reuse code for a particular step in a different context. For example, a researcher trying to use someone else's code may have to rewrite the code relating to the latter steps in that process if their workflow slightly deviates from that of the original researcher. They may even have to rewrite the entire workflow!</p> <p> </p> <p>Alternatively, by making well-defined interfaces for each step of the process, the code for each step can be decoupled from the code for the other steps. There may be different implementations of each step -- for example, one researcher's processing step may include a background subtraction, while another researcher's processing step may not -- the code representing the analyis workflow should allow for and record these differences, but subsquent steps in the workflow should not need to know about them.</p> <p>This decoupled approach means that if the existing code does not already work for a particular researcher's workflow, they can simply write their own implementation of the step that does not work for them, and then use the existing code for the other steps. This is the approach taken by MagnetoPy.</p> <p> </p> <p>Consider a project where a group of researchers propose a new model for fitting variable field magnetization (i.e., hysteresis) data. The model ultimately only needs access to field and magnetization data to then return the values of the fit parameters.</p> <p>Suppose another research group wants to try the analysis on their own data. Assuming the original research group published their code for the analysis, what would the second research group need to do to apply the new model to their data?</p> <p>Typically, the code used to perform the analysis contains a lot of hard-coded information that is specific to the researchers' data. For example, their code may only work on the format of their particular data files, the particular method of measurement (i.e., DC or VSM measurements), their particular sequence of magnetic fields (e.g. with hard-coded values for the indices of the forward and reverse scans), whether or not they performed any processing of the data (e.g., mass/molar scaling, diamagnetic corrections, background subtraction, normalization, etc.). Thus, there is often an extremely large activation barrier for other researchers to apply the model to their own data, even though the model ultimately only cares about field and magnetization values!</p> <p>MagnetoPy provides interfaces for experiments that abstract away the details of the data files and measurement methods, allowing researchers to focus on the analysis. In the current example, the researchers would be interested in the <code>MvsH</code> class, which provides a standard interface for accessing variable field magnetization data.</p> <p>After using analyses within MagnetoPy, the serialized form of the magnetometry dataset contains all of the information that future researchers would need to reproduce the analysis, as shown in this example. This includes the raw data, the processing steps, and the analysis itself. Thus, the activation barrier for other researchers to apply the analysis to their own data is greatly reduced.</p>"},{"location":"#currently-supported-interfaces","title":"Currently Supported Interfaces","text":""},{"location":"#experiments","title":"Experiments","text":"<ul> <li><code>MvsH</code>: Variable field magnetization experiments</li> <li><code>ZFC</code>/<code>FC</code>: Zero-field-cooled/field-cooled magnetization experiments</li> </ul>"},{"location":"#data-files","title":"Data Files","text":"<ul> <li>Quantum Design MPMS3 .dat files</li> <li>Quantum Design MPMS3 .rw.dat files - note that while the <code>DcMeasurement</code> class is available to represent an individual DC measurement (i.e., the voltage data underlying a sinlge magnetic moment data point), the raw voltage data is more likely to accessed via the <code>DatFile.data</code> attribute, where the <code>\"raw_scan\"</code> column of the <code>DataFrame</code> contains the raw voltage data in the form of <code>DcMeasurement</code> objects.</li> </ul>"},{"location":"file_formatting/","title":"Parsing Conventions and Capabilities","text":"<p>MagnetoPy can read in a variety of raw magnetic data and convert it to useful Python objects. The following sections describe what sort of file conventions are compatible with MagnetoPy and how the automatic parsing works.</p>"},{"location":"file_formatting/#sample-info-and-moment-scaling","title":"Sample Info and Moment Scaling","text":"<p>When creating a <code>Magnetometry</code> object, MagnetoPy will assume that all files within the given folder are from the same sample. Thus, the <code>Magnetometry.sample_info</code> attribute will be created by looking at the sample information in the header of the first file that it finds.</p> <p>The sample information is also used to automatically scale the magnetic moment data in all dc measurements (i.e., all <code>MvsH</code>, <code>ZFC</code>, and <code>FC</code> objects within the dataset).</p>"},{"location":"file_formatting/#dat-file-conventions","title":".dat File Conventions","text":"<p>MagnetoPy determines what experiment(s) is/are contained in a given file by checking the following items in this order:</p> <ul> <li>comments embedded in the data section of the file (e.g., the section of the file after the row containing \"[DATA]\" in a Quantum Design MPMP3 .dat file)</li> <li>the file name</li> <li>the actual data</li> </ul> Note: It is strongly recommended to use the comment method to specify the experiment type, as this removes any ambiguity, and adding support for new experiment types will be easiest with commented files."},{"location":"file_formatting/#commented-files","title":"Commented Files","text":"<p>In Quantum Design's MPMS3 MultiVu software, comments are added using the \"Datafile Comment\" section of the Sequence Command panel.</p> <p>The comment should be placed immediately after setting the file location, as shown in the following example of a sequence containing ZFC and FC experiments.</p> <p>Comments should be comma separated and can be in any order. The following experiments should be commented as follows:</p>"},{"location":"file_formatting/#mvsh","title":"MvsH","text":"<p>Comments must include:</p> <ul> <li>\"MvsH\" (case insensitive)</li> <li>the nominal temperature written as \"XX\", \"XX K\", or \"XX C\" (values without a unit are assumed to be K)</li> </ul>"},{"location":"file_formatting/#zfcfc-zfc-fc","title":"ZFCFC, ZFC, FC","text":"<p>Comments must include:</p> <ul> <li>\"ZFC\" or \"FC\" (case insensitive)</li> <li>the nominal magnetic field strength written as \"XX\", \"XX Oe\", or \"XX T\" (values without a unit are assumed to be Oe)</li> </ul>"},{"location":"file_formatting/#file-names","title":"File Names","text":"<p>Recognized file names are (case insensitive):</p> <ul> <li>\"zfcfc\"</li> <li>further parsing will assume the file contain a single ZFC/FC experiment</li> <li>further parsing will assume the experiments are in the order ZFC then FC</li> <li>\"zfc\"</li> <li>further parsing will assume the file contain a single ZFC experiment</li> <li>\"fc\"</li> <li>further parsing will assume the file contain a single FC experiment</li> <li>\"mvsh\"</li> <li>further parsing can handle one or multiple MvsH experiments within the same file</li> </ul>"},{"location":"file_formatting/#uncommented-files","title":"Uncommented Files","text":"<p>Differentiating between files containing ZFCFC and MvsH experiments is done by checking the number of unique field values in the data, since it is assumed that ZFCFC files will only have a single field value.</p>"},{"location":"file_formatting/#zfcfc-zfc-fc_1","title":"ZFCFC, ZFC, FC","text":"<p>The automatic parsing of uncommented files containing ZFC/FC experiments currently only supports files with a single ZFC/FC pair. The data must be in the order ZFC then FC. The FC experiment can be collected with increasing or decreasing temperature.</p>"},{"location":"file_formatting/#mvsh_1","title":"MvsH","text":"<p>Files containing M vs. H data can contain one or multiple experiments at different nominal temperatures. Due to the temperature fluctuations, experiments are grouped by nominal temperatures using scikit-learn's DBSCAN clustering algorithm. Default values for the <code>eps</code> and <code>min_samples</code> parameters are provided and can be overwritten during <code>MvsH</code> object creation or <code>Magnetometry.extract_mvsh()</code></p>"},{"location":"standard_calibration_library/","title":"Standard Calibration Repository","text":"<p>MagnetoPy can be used to perform field corrections on M vs. H experiments and, in the future, may also implement manual background subtraction methods for dc measurements. Each magnetometer will have its own calibration files. Research groups may choose to maintain a repository of these files to serve as a single source of truth for their instrument and so that outside groups and reviewers have the necessary access to reproduce the results.</p>"},{"location":"standard_calibration_library/#contents","title":"Contents","text":"<p>The Rinehart group's repository is located in MagnetoPyCalibration.</p> <p>In general, a calibration library must include a the files containing calibraiton data and a json file describing the files.</p> <p>\"calibration.json\" has the following structure:</p> <pre><code>{\n  \"moment\": \"moment.dat\",\n  \"mvsh\": {\n    \"sequence_1\": \"mvsh_seq1.dat\",\n    \"sequence_2\": \"mvsh_seq2.dat\"\n  }\n}\n</code></pre> <p>The actual files are stored in the directory \"calibration_files\". It's assumed that, when needed, a .rw.dat file containing the unprocessed data is also stored in this folder (with the default convention of having the same name as the .dat file, but with the .rw.dat extension).</p> <p>Only two categories of calibration files are currently supported.</p> <ol> <li> <p>\"moment\"</p> <p>Used for the determination of the system-specific calibration factor. There should only ever need to be one of these files.</p> </li> <li> <p>\"mvsh\"</p> <p>Used for determining the \"true field\" during an M vs H sequence. Per the application note, all measurements should be collected at 298 K. The temperature of the calibration data does not need to match the temperature of the target data, but the sequence of fields should be the exact same.</p> <p>The \"mvsh\" keys are the names of the sequences. These names are referred to by <code>magnetopy</code> for easy access to the correct calibration data. See the field correction example for more details.</p> </li> </ol>"},{"location":"api/analysis/","title":"Analysis (Protocol)","text":""},{"location":"api/analysis/#magnetopy.magnetometry.Analysis","title":"<code>magnetopy.magnetometry.Analysis</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol class representing an analysis of one or more magnetometry experiments.</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>Any</code> <p>The results of the analysis. For results more complicated than a simple value, it is recommended that a <code>dataclass</code> be used, and that the <code>dataclass</code> have an <code>as_dict</code> method.</p>"},{"location":"api/analysis/#magnetopy.magnetometry.Analysis--notes","title":"Notes","text":"<p>While not yet enforced, it is strongly recommended that any class that implements this protocol have an <code>__init__</code> method which takes the following arguments:</p> <ul> <li><code>dataset</code>: a <code>Magnetometry</code> object</li> <li><code>parsing_args</code>: an object with attributes that specify how to parse the data; these arguments may be used as arguments to be passed to various <code>Magnetometry</code> methods. It is recommended that this object be a dataclass with an <code>as_dict</code> method.</li> <li><code>fitting_args</code>: an object with attributes that specify how to fit the data; these arguments may include, e.g., starting values, bounds, constraints, etc. It is recommended that this object be a dataclass with an <code>as_dict</code> method.</li> </ul> <p>The <code>__init__</code> method should perform the analysis and store the results in the <code>results</code> attribute.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>class Analysis(Protocol):\n\"\"\"A protocol class representing an analysis of one or more magnetometry\n    experiments.\n    Attributes\n    ----------\n    results : Any\n        The results of the analysis. For results more complicated than a simple value,\n        it is recommended that a `dataclass` be used, and that the `dataclass` have an\n        `as_dict` method.\n    Notes\n    -----\n    While not yet enforced, it is strongly recommended that any class that implements\n    this protocol have an `__init__` method which takes the following arguments:\n    - `dataset`: a `Magnetometry` object\n    - `parsing_args`: an object with attributes that specify how to parse the data;\n    these arguments may be used as arguments to be passed to various `Magnetometry`\n    methods. It is recommended that this object be a dataclass with an `as_dict`\n    method.\n    - `fitting_args`: an object with attributes that specify how to fit the data;\n    these arguments may include, e.g., starting values, bounds, constraints, etc.\n    It is recommended that this object be a dataclass with an `as_dict` method.\n    The `__init__` method should perform the analysis and store the results in the\n    `results` attribute.\n    \"\"\"\ndef as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Return a dictionary representation of the analysis. Should include the\n        results of the analysis along with any parsing and fitting arguments used.\n        The dictionary must include a field \"_class_\" with the name of the class of\n        the analysis object (e.g. \"MvsHAnalysis\", \"ZFCAnalysis\", etc.).\n        Returns\n        -------\n        dict[str, Any]\n        \"\"\"\n...\n</code></pre>"},{"location":"api/analysis/#magnetopy.magnetometry.Analysis.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dictionary representation of the analysis. Should include the results of the analysis along with any parsing and fitting arguments used.</p> <p>The dictionary must include a field \"class\" with the name of the class of the analysis object (e.g. \"MvsHAnalysis\", \"ZFCAnalysis\", etc.).</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Return a dictionary representation of the analysis. Should include the\n    results of the analysis along with any parsing and fitting arguments used.\n    The dictionary must include a field \"_class_\" with the name of the class of\n    the analysis object (e.g. \"MvsHAnalysis\", \"ZFCAnalysis\", etc.).\n    Returns\n    -------\n    dict[str, Any]\n    \"\"\"\n...\n</code></pre>"},{"location":"api/dat_file/","title":"DatFile","text":""},{"location":"api/dat_file/#magnetopy.data_files.DatFile","title":"<code>magnetopy.data_files.DatFile</code>","text":"<p>             Bases: <code>GenericFile</code></p> <p>A class for reading and storing data from a Quantum Design .dat file from a MPMS3 magnetometer.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>The path to the .dat file.</p> required <code>parse_raw</code> <code>bool</code> <p>By default <code>False</code>. If <code>True</code> and there is a corresponding .rw.dat file, the raw data will be parsed and stored in the <code>raw_scan</code> column of the <code>data</code> attribute.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>local_path</code> <code>Path</code> <p>The path to the .dat file.</p> <code>header</code> <code>list[list[str]]</code> <p>The header of the .dat file.</p> <code>data</code> <code>pd.DataFrame</code> <p>The data from the .dat file.</p> <code>comments</code> <code>OrderedDict[str, list[str]]</code> <p>Any comments found in the \"Comment\" column within the \"[Data]\" section of the .dat file.</p> <code>length</code> <code>int</code> <p>The length of the .dat file in bytes.</p> <code>sha512</code> <code>str</code> <p>The SHA512 hash of the .dat file.</p> <code>date_created</code> <code>datetime</code> <p>The date and time the .dat file was created.</p> <code>experiments_in_file</code> <code>list[str]</code> <p>The experiments contained in the .dat file. Can include \"mvsh\", \"zfc\", \"fc\", and/or \"zfcfc\".</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>class DatFile(GenericFile):\n\"\"\"A class for reading and storing data from a Quantum Design .dat file from a\n    MPMS3 magnetometer.\n    Parameters\n    ----------\n    file_path : str | Path\n        The path to the .dat file.\n    parse_raw : bool, optional\n        By default `False`. If `True` and there is a corresponding .rw.dat file, the\n        raw data will be parsed and stored in the `raw_scan` column of the `data`\n        attribute.\n    Attributes\n    ----------\n    local_path : Path\n        The path to the .dat file.\n    header : list[list[str]]\n        The header of the .dat file.\n    data : pd.DataFrame\n        The data from the .dat file.\n    comments : OrderedDict[str, list[str]]\n        Any comments found in the \"Comment\" column within the \"[Data]\" section of the\n        .dat file.\n    length : int\n        The length of the .dat file in bytes.\n    sha512 : str\n        The SHA512 hash of the .dat file.\n    date_created : datetime\n        The date and time the .dat file was created.\n    experiments_in_file : list[str]\n        The experiments contained in the .dat file. Can include \"mvsh\", \"zfc\", \"fc\",\n        and/or \"zfcfc\".\n    \"\"\"\ndef __init__(self, file_path: str | Path, parse_raw: bool = False) -&gt; None:\nsuper().__init__(file_path, \"magnetometry\")\nself.header = self._read_header()\nself.data = self._read_data()\nself.comments = self._get_comments()\nself.date_created = self._get_date_created()\nself.experiments_in_file = self._get_experiments_in_file()\nif parse_raw:\nrw_dat_file = self.local_path.parent / (self.local_path.stem + \".rw.dat\")\nif rw_dat_file.exists():\nself.append_raw_data(rw_dat_file)\ndef __str__(self) -&gt; str:\nreturn f\"DatFile({self.local_path.name})\"\ndef __repr__(self) -&gt; str:\nreturn f\"DatFile({self.local_path.name})\"\ndef _read_header(self, delimiter: str = \"\\t\") -&gt; list[list[str]]:\nheader: list[list[str]] = []\nwith self.local_path.open(encoding=\"utf-8\") as f:\nreader = csv.reader(f, delimiter=delimiter)\nfor row in reader:\nheader.append(row)\nif row[0] == \"[Data]\":\nbreak\nif len(header[2]) == 1:\n# some .dat files have a header that is delimited by commas\nheader = self._read_header(delimiter=\",\")\nreturn header\ndef _read_data(\nself,\nsep: str = \"\\t\",\n) -&gt; pd.DataFrame:\nskip_rows = len(self.header)\ndf = pd.read_csv(self.local_path, sep=sep, skiprows=skip_rows)\nif df.shape[1] == 1:\n# some .dat files have a header that is delimited by commas\ndf = self._read_data(sep=\",\")\nreturn df\ndef _get_comments(self) -&gt; OrderedDict[str, list[str]]:\ncomments = self.data[\"Comment\"].dropna()\ncomments = OrderedDict(comments)\nfor key, value in comments.items():\ncomments[key] = [comment.strip() for comment in value.split(\",\")]\nreturn comments\ndef _get_date_created(self) -&gt; datetime:\nfor line in self.header:\nif line[0] == \"FILEOPENTIME\":\nday = line[2]\nhour = line[3]\nbreak\nhour24 = datetime.strptime(hour, \"%I:%M %p\")\nday = [int(x) for x in day.split(\"/\")]\nreturn datetime(day[2], day[0], day[1], hour24.hour, hour24.minute)\ndef _get_experiments_in_file(self) -&gt; list[str]:\nexperiments = []\nif self.comments:\nfor comments in self.comments.values():\nfor comment in comments:\nif comment.lower() in [\"mvsh\", \"zfc\", \"fc\", \"zfcfc\"]:\nexperiments.append(comment.lower())\nelif (filename := filename_label(self.local_path.name, \"\", True)) != \"unknown\":\nexperiments.append(filename)\nelse:\nif len(self.data[\"Magnetic Field (Oe)\"].unique()) == 1:\nexperiments.append(\"zfcfc\")\nelse:\nexperiments.append(\"mvsh\")\nreturn experiments\ndef append_raw_data(self, rw_dat_file: str | Path) -&gt; None:\n\"\"\"Adds a column \"raw_scan\" to the `data` attribute containing the raw data\n        from the .rw.dat file.\n        Parameters\n        ----------\n        rw_dat_file : str | Path\n            The path to the .rw.dat file.\n        \"\"\"\nraw_scans = create_raw_scans(rw_dat_file)\nself.combine_dat_and_raw_dfs(raw_scans)\ndef combine_dat_and_raw_dfs(self, raw: list[DcMeasurement]) -&gt; None:\n\"\"\"Data from the .rw.dat file is converted to a list of DcMeasurement objects\n        which must be integrated with the `DataFrame` stored in the `data` attribute.\n        This is not completely straightforward in cases where there are comments in\n        the .dat file. This method takes the list of DcMeasurement objects and\n        integrates them with the `DataFrame` stored in the `data` attribute.\n        Parameters\n        ----------\n        raw : list[DcMeasurement]\n            A list of DcMeasurement objects created from the .rw.dat file.\n        \"\"\"\nif len(self.data) == len(raw):\n# there are no comments in the .dat file\nself.data[\"raw_scan\"] = raw\nelse:\n# we need to skip rows that have comments\nhas_comment = self.data[\"Comment\"].notna()\nnew_raw = []\nj = 0\nfor i in range(len(self.data)):\nif has_comment[i]:\nnew_raw.append(np.nan)\nelse:\nnew_raw.append(raw[j])\nj += 1\nself.data[\"raw_scan\"] = new_raw\ndef plot_raw(\nself,\ndata_slice: tuple[int, int] | None = None,\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"fit\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"purple\", \"orange\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"If the `data` attribute contains raw data, this method will plot it.\n        Parameters\n        ----------\n        data_slice : tuple[int, int] | None, optional\n            The slice of data to plot (start, stop). `None` by default. If `None`, all\n            data will be plotted.\n        scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"fit\"], optional\n            Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n            scans (which have been adjusted for drift and shifted to center the waveform\n            around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the raw\n            voltages as the come straight off the SQUID, and `\"fit\"` will plot the\n            fit data (which is the result of fitting the up and down scans). `\"up\"` by\n            default.\n        center : Literal[\"free\", \"fixed\"], optional\n            Only used if `scan` is `\"fit\"`; determines whether to plot the \"Free C\n            Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n        colors : tuple[str, str], optional\n            The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n            default.\n        label : bool, optional\n            Default `True`. Whether to put labels on the plot for the initial and final\n            scans.\n        title : str, optional\n            The title of the plot. `\"\"` by default.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n            The figure and axes objects created by `plot_raw`.\n        Raises\n        ------\n        NoRawDataError\n        \"\"\"\nreturn plot_raw(self.data, data_slice, scan, center, colors, label, title)\ndef plot_raw_residual(\nself,\ndata_slice: tuple[int, int] | None = None,\nscan: Literal[\"up\", \"down\"] = \"up\",\ncenter: Literal[\"free\", \"fixed\"] = \"free\",\ncolors: tuple[str, str] | None = None,\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"If the `data` attribute contains raw data, this method will plot the\n        residual between the raw data and the fit data.\n        Parameters\n        ----------\n        data_slice : tuple[int, int] | None, optional\n            The slice of data to plot (start, stop). `None` by default. If `None`, all\n            data will be plotted.\n        scan : Literal[\"up\", \"down\"], optional\n            Which data to use in the residual calculation. `\"up\"` and `\"down\"` will use the\n            processed directional scans (which have been adjusted for drift and shifted to\n            center the waveform around 0, but have not been fit). `\"up\"` by default.\n        center : Literal[\"free\", \"fixed\"], optional\n            Only used if `scan` is `\"fit\"`; determines whether to plot the \"Free C\n            Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n        colors : tuple[str, str], optional\n            The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n            default.\n        label : bool, optional\n            Default `True`. Whether to put labels on the plot for the initial and final\n            scans.\n        title : str, optional\n            The title of the plot. `\"\"` by default.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n            The figure and axes objects created by `plot_raw_residual`.\n        Raises\n        ------\n        NoRawDataError\n        \"\"\"\nreturn plot_raw_residual(\nself.data, data_slice, scan, center, colors, label, title\n)\ndef as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Serializes the DatFile object to a dictionary.\n        Returns\n        -------\n        dict[str, Any]\n            Contains the following keys: local_path, length, date_created, sha512,\n            experiments_in_file.\n        \"\"\"\noutput = super().as_dict()\noutput[\"_class_\"] = self.__class__.__name__\noutput[\"experiments_in_file\"] = self.experiments_in_file\nreturn output\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.DatFile.append_raw_data","title":"<code>append_raw_data(rw_dat_file)</code>","text":"<p>Adds a column \"raw_scan\" to the <code>data</code> attribute containing the raw data from the .rw.dat file.</p> <p>Parameters:</p> Name Type Description Default <code>rw_dat_file</code> <code>str | Path</code> <p>The path to the .rw.dat file.</p> required Source code in <code>magnetopy\\data_files.py</code> <pre><code>def append_raw_data(self, rw_dat_file: str | Path) -&gt; None:\n\"\"\"Adds a column \"raw_scan\" to the `data` attribute containing the raw data\n    from the .rw.dat file.\n    Parameters\n    ----------\n    rw_dat_file : str | Path\n        The path to the .rw.dat file.\n    \"\"\"\nraw_scans = create_raw_scans(rw_dat_file)\nself.combine_dat_and_raw_dfs(raw_scans)\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.DatFile.combine_dat_and_raw_dfs","title":"<code>combine_dat_and_raw_dfs(raw)</code>","text":"<p>Data from the .rw.dat file is converted to a list of DcMeasurement objects which must be integrated with the <code>DataFrame</code> stored in the <code>data</code> attribute. This is not completely straightforward in cases where there are comments in the .dat file. This method takes the list of DcMeasurement objects and integrates them with the <code>DataFrame</code> stored in the <code>data</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>list[DcMeasurement]</code> <p>A list of DcMeasurement objects created from the .rw.dat file.</p> required Source code in <code>magnetopy\\data_files.py</code> <pre><code>def combine_dat_and_raw_dfs(self, raw: list[DcMeasurement]) -&gt; None:\n\"\"\"Data from the .rw.dat file is converted to a list of DcMeasurement objects\n    which must be integrated with the `DataFrame` stored in the `data` attribute.\n    This is not completely straightforward in cases where there are comments in\n    the .dat file. This method takes the list of DcMeasurement objects and\n    integrates them with the `DataFrame` stored in the `data` attribute.\n    Parameters\n    ----------\n    raw : list[DcMeasurement]\n        A list of DcMeasurement objects created from the .rw.dat file.\n    \"\"\"\nif len(self.data) == len(raw):\n# there are no comments in the .dat file\nself.data[\"raw_scan\"] = raw\nelse:\n# we need to skip rows that have comments\nhas_comment = self.data[\"Comment\"].notna()\nnew_raw = []\nj = 0\nfor i in range(len(self.data)):\nif has_comment[i]:\nnew_raw.append(np.nan)\nelse:\nnew_raw.append(raw[j])\nj += 1\nself.data[\"raw_scan\"] = new_raw\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.DatFile.plot_raw","title":"<code>plot_raw(data_slice=None, scan='up', center='free', colors=('purple', 'orange'), label=True, title='')</code>","text":"<p>If the <code>data</code> attribute contains raw data, this method will plot it.</p> <p>Parameters:</p> Name Type Description Default <code>data_slice</code> <code>tuple[int, int] | None</code> <p>The slice of data to plot (start, stop). <code>None</code> by default. If <code>None</code>, all data will be plotted.</p> <code>None</code> <code>scan</code> <code>Literal['up', 'up_raw', 'down', 'down_raw', 'fit']</code> <p>Which data to plot. <code>\"up\"</code> and <code>\"down\"</code> will plot the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit), <code>\"up_raw\"</code> and <code>\"down_raw\"</code> will plot the raw voltages as the come straight off the SQUID, and <code>\"fit\"</code> will plot the fit data (which is the result of fitting the up and down scans). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Only used if <code>scan</code> is <code>\"fit\"</code>; determines whether to plot the \"Free C Fitted\" or \"Fixed C Fitted\" data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"purple\"</code> and <code>\"orange\"</code> by default.</p> <code>('purple', 'orange')</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> <p>The figure and axes objects created by <code>plot_raw</code>.</p> <p>Raises:</p> Type Description <code>NoRawDataError</code> Source code in <code>magnetopy\\data_files.py</code> <pre><code>def plot_raw(\nself,\ndata_slice: tuple[int, int] | None = None,\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"fit\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"purple\", \"orange\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"If the `data` attribute contains raw data, this method will plot it.\n    Parameters\n    ----------\n    data_slice : tuple[int, int] | None, optional\n        The slice of data to plot (start, stop). `None` by default. If `None`, all\n        data will be plotted.\n    scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"fit\"], optional\n        Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n        scans (which have been adjusted for drift and shifted to center the waveform\n        around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the raw\n        voltages as the come straight off the SQUID, and `\"fit\"` will plot the\n        fit data (which is the result of fitting the up and down scans). `\"up\"` by\n        default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Only used if `scan` is `\"fit\"`; determines whether to plot the \"Free C\n        Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n        The figure and axes objects created by `plot_raw`.\n    Raises\n    ------\n    NoRawDataError\n    \"\"\"\nreturn plot_raw(self.data, data_slice, scan, center, colors, label, title)\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.DatFile.plot_raw_residual","title":"<code>plot_raw_residual(data_slice=None, scan='up', center='free', colors=None, label=True, title='')</code>","text":"<p>If the <code>data</code> attribute contains raw data, this method will plot the residual between the raw data and the fit data.</p> <p>Parameters:</p> Name Type Description Default <code>data_slice</code> <code>tuple[int, int] | None</code> <p>The slice of data to plot (start, stop). <code>None</code> by default. If <code>None</code>, all data will be plotted.</p> <code>None</code> <code>scan</code> <code>Literal['up', 'down']</code> <p>Which data to use in the residual calculation. <code>\"up\"</code> and <code>\"down\"</code> will use the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Only used if <code>scan</code> is <code>\"fit\"</code>; determines whether to plot the \"Free C Fitted\" or \"Fixed C Fitted\" data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"purple\"</code> and <code>\"orange\"</code> by default.</p> <code>None</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> <p>The figure and axes objects created by <code>plot_raw_residual</code>.</p> <p>Raises:</p> Type Description <code>NoRawDataError</code> Source code in <code>magnetopy\\data_files.py</code> <pre><code>def plot_raw_residual(\nself,\ndata_slice: tuple[int, int] | None = None,\nscan: Literal[\"up\", \"down\"] = \"up\",\ncenter: Literal[\"free\", \"fixed\"] = \"free\",\ncolors: tuple[str, str] | None = None,\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"If the `data` attribute contains raw data, this method will plot the\n    residual between the raw data and the fit data.\n    Parameters\n    ----------\n    data_slice : tuple[int, int] | None, optional\n        The slice of data to plot (start, stop). `None` by default. If `None`, all\n        data will be plotted.\n    scan : Literal[\"up\", \"down\"], optional\n        Which data to use in the residual calculation. `\"up\"` and `\"down\"` will use the\n        processed directional scans (which have been adjusted for drift and shifted to\n        center the waveform around 0, but have not been fit). `\"up\"` by default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Only used if `scan` is `\"fit\"`; determines whether to plot the \"Free C\n        Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n        The figure and axes objects created by `plot_raw_residual`.\n    Raises\n    ------\n    NoRawDataError\n    \"\"\"\nreturn plot_raw_residual(\nself.data, data_slice, scan, center, colors, label, title\n)\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.DatFile.as_dict","title":"<code>as_dict()</code>","text":"<p>Serializes the DatFile object to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Contains the following keys: local_path, length, date_created, sha512, experiments_in_file.</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Serializes the DatFile object to a dictionary.\n    Returns\n    -------\n    dict[str, Any]\n        Contains the following keys: local_path, length, date_created, sha512,\n        experiments_in_file.\n    \"\"\"\noutput = super().as_dict()\noutput[\"_class_\"] = self.__class__.__name__\noutput[\"experiments_in_file\"] = self.experiments_in_file\nreturn output\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.DcMeasurement","title":"<code>magnetopy.data_files.DcMeasurement</code>","text":"<p>The Quantum Design software fits the Processed Voltage data from the up and down scans and uses the fit values with system-specific calibration factors to convert the voltages to magnetic moment. This class stores both the raw and fit data from a single DC measurement.</p> <p>Parameters:</p> Name Type Description Default <code>up_header</code> <code>pd.Series</code> <p>The header information from the .rw.dat file for the up scan.</p> required <code>up_scan</code> <code>pd.DataFrame</code> <p>The raw scan data from the .rw.dat file for the up scan.</p> required <code>down_header</code> <code>pd.Series</code> <p>The header information from the .rw.dat file for the down scan.</p> required <code>down_scan</code> <code>pd.DataFrame</code> <p>The raw scan data from the .rw.dat file for the down scan.</p> required <code>fit_scan</code> <code>pd.DataFrame</code> <p>The fit scan data from the .rw.dat file.</p> required <p>Attributes:</p> Name Type Description <code>up</code> <code>RawDcScan</code> <p>The information about and data from the up scan.</p> <code>down</code> <code>RawDcScan</code> <p>The information about and data from the down scan.</p> <code>fit_scan</code> <code>FitDcScan</code> <p>The fit scan data determined by fitting the up and down scans.</p>"},{"location":"api/dat_file/#magnetopy.data_files.DcMeasurement--notes","title":"Notes","text":"<p>Information on the structure of a .rw.dat file can be found in the Quantum Design app note[1].</p> <p>The fit scan is determined by fitting the up and down scans to the following equation[1]:</p> <p>V(z)=S+A{2[R2+(z\u2212C)2]\u221232\u2212[R2+(L+z\u2212C)2]\u221232\u2212[R2+(\u2212L+z\u2212C)2]\u221232} V(z) = S + A \\left\\{ 2 \\left[ R^2 + (z - C)^2 \\right]^{-\\frac{3}{2}} - [R^2 + (L + z - C)^2]^{-\\frac{3}{2}} - [R^2 + (-L + z - C)^2]^{-\\frac{3}{2}} \\right\\} V(z)=S+A{2[R2+(z\u2212C)2]\u221223\u200b\u2212[R2+(L+z\u2212C)2]\u221223\u200b\u2212[R2+(\u2212L+z\u2212C)2]\u221223\u200b}</p> <p>where S is the offset voltage, A is the amplitude, R is the radius of the gradiometer, L is half the length of the gradiometer, and C is the sample center position.</p>"},{"location":"api/dat_file/#magnetopy.data_files.DcMeasurement--references","title":"References","text":"<p>MPMS3 Application Note 1500-022: MPMS3 .rw.dat file format</p> <p>MPMS3 Application Note 1500-023: Background subtraction using the MPMS3</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>class DcMeasurement:\nr\"\"\"\n    The Quantum Design software fits the Processed Voltage data from the up and down\n    scans and uses the fit values with system-specific calibration factors to convert\n    the voltages to magnetic moment. This class stores both the raw and fit\n    data from a single DC measurement.\n    Parameters\n    ----------\n    up_header : pd.Series\n        The header information from the .rw.dat file for the up scan.\n    up_scan : pd.DataFrame\n        The raw scan data from the .rw.dat file for the up scan.\n    down_header : pd.Series\n        The header information from the .rw.dat file for the down scan.\n    down_scan : pd.DataFrame\n        The raw scan data from the .rw.dat file for the down scan.\n    fit_scan : pd.DataFrame\n        The fit scan data from the .rw.dat file.\n    Attributes\n    ----------\n    up : RawDcScan\n        The information about and data from the up scan.\n    down : RawDcScan\n        The information about and data from the down scan.\n    fit_scan : FitDcScan\n        The fit scan data determined by fitting the up and down scans.\n    Notes\n    --------\n    Information on the structure of a .rw.dat file can be found in the Quantum Design\n    app note[1].\n    The fit scan is determined by fitting the up and down scans to the following\n    equation[1]:\n    ```math\n    V(z) = S + A \\left\\{ 2 \\left[ R^2 + (z - C)^2 \\right]^{-\\frac{3}{2}} -\n    [R^2 + (L + z - C)^2]^{-\\frac{3}{2}} - [R^2 + (-L + z - C)^2]^{-\\frac{3}{2}}\n    \\right\\}\n    ```\n    where S is the offset voltage, A is the amplitude, R is the radius of the\n    gradiometer, L is half the length of the gradiometer, and C is the sample center\n    position.\n    References\n    ----------\n    [MPMS3 Application Note 1500-022: MPMS3 .rw.dat file format](\n        https://www.qdusa.com/siteDocs/appNotes/1500-022.pdf\n    )\n    [MPMS3 Application Note 1500-023: Background subtraction using the MPMS3](\n        https://qdusa.com/siteDocs/appNotes/1500-023.pdf\n    )\n    \"\"\"\ndef __init__(\nself,\nup_header: pd.Series,\nup_scan: pd.DataFrame,\ndown_header: pd.Series,\ndown_scan: pd.DataFrame,\nfit_scan: pd.DataFrame,\n) -&gt; None:\nself.up = RawDcScan(\"up\", up_header, up_scan)\nself.down = RawDcScan(\"down\", down_header, down_scan)\nself.fit_scan = FitDcScan(fit_scan)\ndef __repr__(self):\nreturn f\"DcMeasurement({self.up.avg_field:.2f} Oe, {self.up.avg_temp:.2f} K)\"\ndef __str__(self):\nreturn f\"DcMeasurement({self.up.avg_field:.2f} Oe, {self.up.avg_temp:.2f} K)\"\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.RawDcScan","title":"<code>magnetopy.data_files.RawDcScan</code>","text":"<p>A class for storing the header information from a single raw scan.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>Literal['up', 'down']</code> <p>The direction of the scan.</p> required <code>header</code> <code>pd.Series</code> <p>The header information from the .dat file. The information is initially stored in the \"Comment\" column in a single row preceding the scan data.</p> required <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The original text from the \"Comment\" column.</p> <code>direction</code> <code>Literal['up', 'down']</code> <p>The direction of the scan.</p> <code>low_temp</code> <code>float</code> <p>The lowest temperature recorded during the combined DC scan.</p> <code>high_temp</code> <code>float</code> <p>The highest temperature recorded during the combined DC scan.</p> <code>avg_temp</code> <code>float</code> <p>The average temperature recorded during the combined DC scan.</p> <code>low_field</code> <code>float</code> <p>The lowest magnetic field (in Oe) recorded during the combined DC scan.</p> <code>high_field</code> <code>float</code> <p>The highest magnetic field (in Oe) recorded during the combined DC scan.</p> <code>drift</code> <code>float</code> <p>The amount of drift (in V/S) between the DOWN-&gt;UP and UP-&gt;DOWN scans.</p> <code>slope</code> <code>float</code> <p>The linear slope (in V/mm) between the DOWN-&gt;UP and UP-&gt;DOWN scans.</p> <code>squid_range</code> <code>float</code> <p>The SQUID range [1, 10, 100, or 1000] used during the combined DC scan.</p> <code>given_center</code> <code>float</code> <p>The center position (in mm) as set during the sample installation wizard.</p> <code>calculated_center</code> <code>float</code> <p>The calculated center position (in mm) from the Free C Fitted data.</p> <code>amp_fixed</code> <code>float</code> <p>The amplitude (in V) of the Fixed C Fitted data.</p> <code>amp_free</code> <code>float</code> <p>The amplitude (in V) of the Free C Fitted data.</p> <code>data</code> <code>pd.DataFrame</code> <p>The raw scan data. Columns are: \"Time Stamp (sec)\", \"Raw Position (mm)\", \"Raw Voltage (V)\", \"Processed Voltage (V)\". The Raw Voltage data from both up and down scans are corrected for drift and shifted to center the waveform around V=0, and the results of those corrections are stored in the \"Processed Voltage (V)\" column.</p> <code>start_time</code> <code>float</code> <p>The time stamp (in seconds) of the first data point in the scan.</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>class RawDcScan:\n\"\"\"A class for storing the header information from a single raw scan.\n    Parameters\n    ----------\n    direction : Literal[\"up\", \"down\"]\n        The direction of the scan.\n    header : pd.Series\n        The header information from the .dat file. The information is initially stored\n        in the \"Comment\" column in a single row preceding the scan data.\n    Attributes\n    ----------\n    text : str\n        The original text from the \"Comment\" column.\n    direction : Literal[\"up\", \"down\"]\n        The direction of the scan.\n    low_temp : float\n        The lowest temperature recorded during the combined DC scan.\n    high_temp : float\n        The highest temperature recorded during the combined DC scan.\n    avg_temp : float\n        The average temperature recorded during the combined DC scan.\n    low_field : float\n        The lowest magnetic field (in Oe) recorded during the combined DC scan.\n    high_field : float\n        The highest magnetic field (in Oe) recorded during the combined DC scan.\n    drift : float\n        The amount of drift (in V/S) between the DOWN-&gt;UP and UP-&gt;DOWN scans.\n    slope : float\n        The linear slope (in V/mm) between the DOWN-&gt;UP and UP-&gt;DOWN scans.\n    squid_range : float\n        The SQUID range [1, 10, 100, or 1000] used during the combined DC scan.\n    given_center : float\n        The center position (in mm) as set during the sample installation wizard.\n    calculated_center : float\n        The calculated center position (in mm) from the Free C Fitted data.\n    amp_fixed : float\n        The amplitude (in V) of the Fixed C Fitted data.\n    amp_free : float\n        The amplitude (in V) of the Free C Fitted data.\n    data : pd.DataFrame\n        The raw scan data. Columns are: \"Time Stamp (sec)\", \"Raw Position (mm)\",\n        \"Raw Voltage (V)\", \"Processed Voltage (V)\". The Raw Voltage data from both\n        up and down scans are corrected for drift and shifted to center the waveform\n        around V=0, and the results of those corrections are stored in the\n        \"Processed Voltage (V)\" column.\n    start_time : float\n        The time stamp (in seconds) of the first data point in the scan.\n    \"\"\"\ndef __init__(\nself, direction: Literal[\"up\", \"down\"], header: pd.Series, scan: pd.DataFrame\n) -&gt; None:\nself.text: str = header[\"Comment\"]\nself.direction = direction\nself.low_temp = self._get_value(r\"low temp = (\\d+\\.\\d+) K\")\nself.high_temp = self._get_value(r\"high temp = (\\d+\\.\\d+) K\")\nself.avg_temp = self._get_value(r\"avg. temp = (\\d+\\.\\d+) K\")\nself.low_field = self._get_value(r\"low field = (-?\\d+\\.\\d+) Oe\")\nself.high_field = self._get_value(r\"high field = (-?\\d+\\.\\d+) Oe\")\nself.drift = self._get_value(r\"drift = (-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?) V/s\")\nself.slope = self._get_value(r\"slope = (-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?) V/mm\")\nself.squid_range = self._get_value(r\"squid range = (\\d+)\")\nself.given_center = self._get_value(r\"given center = (\\d+\\.\\d+) mm\")\nself.calculated_center = self._get_value(r\"calculated center = (\\d+\\.\\d+) mm\")\nself.amp_fixed = self._get_value(r\"amp fixed = (-?\\d+\\.\\d+) V\")\nself.amp_free = self._get_value(r\"amp free =(-?\\d+\\.\\d+) V\")\nself.data = scan.copy()\nself.data.drop(\ncolumns=[\"Comment\", \"Fixed C Fitted (V)\", \"Free C Fitted (V)\"], inplace=True\n)\nself.data.reset_index(drop=True, inplace=True)\nself.start_time = self.data[\"Time Stamp (sec)\"].iloc[0]\ndef _get_value(self, regex: str) -&gt; float:\nreturn float(re.search(regex, self.text).group(1))\n@property\ndef avg_field(self):\nreturn (self.low_field + self.high_field) / 2\ndef __repr__(self):\nreturn f\"RawDcScan({self.direction}, {self.avg_field:.2f} Oe, {self.avg_temp:.2f} K)\"\ndef __str__(self):\nreturn f\"{self.direction} scan at {self.avg_field:.2f} Oe, {self.avg_temp:2f} K\"\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.FitDcScan","title":"<code>magnetopy.data_files.FitDcScan</code>","text":"<p>The FitDcScan class stores the simulated voltage data from fits to the directional scans; one for the case in which the center position is allowed to float (Free C Fitted) and one for the case in which the center position is fixed (Fixed C Fitted) based on the initial centering of the sample.</p> <p>Parameters:</p> Name Type Description Default <code>scan</code> <code>pd.DataFrame</code> <p>The fit scan data from the .rw.dat file.</p> required <p>Attributes:</p> Name Type Description <code>data</code> <code>pd.DataFrame</code> <p>The fit scan data from the .rw.dat file. Columns are: \"Time Stamp (sec)\", \"Raw Position (mm)\", \"Fixed C Fitted (V)\", \"Free C Fitted (V)\".</p> <code>start_time</code> <code>float</code> <p>The time stamp (in seconds) of the first data point in the scan.</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>class FitDcScan:\n\"\"\"The FitDcScan class stores the simulated voltage data from fits to the\n    directional scans; one for the case in which the center position is allowed to\n    float (Free C Fitted) and one for the case in which the center position is fixed\n    (Fixed C Fitted) based on the initial centering of the sample.\n    Parameters\n    ----------\n    scan : pd.DataFrame\n        The fit scan data from the .rw.dat file.\n    Attributes\n    ----------\n    data : pd.DataFrame\n        The fit scan data from the .rw.dat file. Columns are: \"Time Stamp (sec)\",\n        \"Raw Position (mm)\", \"Fixed C Fitted (V)\", \"Free C Fitted (V)\".\n    start_time : float\n        The time stamp (in seconds) of the first data point in the scan.\n    \"\"\"\ndef __init__(self, scan: pd.DataFrame) -&gt; None:\nself.data = scan.copy()\nself.data.drop(\ncolumns=[\"Comment\", \"Raw Voltage (V)\", \"Processed Voltage (V)\"],\ninplace=True,\n)\nself.data.reset_index(drop=True, inplace=True)\nself.start_time = self.data[\"Time Stamp (sec)\"].iloc[0]\ndef __repr__(self):\nreturn f\"FitDcScan({self.start_time} sec)\"\ndef __str__(self):\nreturn f\"FitDcScan({self.start_time} sec)\"\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.plot_raw","title":"<code>magnetopy.data_files.plot_raw(data, data_slice=None, scan='up', center='free', colors=('purple', 'orange'), label=True, title='')</code>","text":"<p>Plot the raw voltage data found in the \"raw_scan\" column of a <code>DataFrame</code>, where each row contains a <code>DcMeasurement</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The <code>DataFrame</code> containing the raw data.</p> required <code>data_slice</code> <code>tuple[int, int] | None</code> <p>The slice of data to plot (start, stop). <code>None</code> by default. If <code>None</code>, all data will be plotted.</p> <code>None</code> <code>scan</code> <code>Literal['up', 'up_raw', 'down', 'down_raw', 'fit']</code> <p>Which data to plot. <code>\"up\"</code> and <code>\"down\"</code> will plot the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit), <code>\"up_raw\"</code> and <code>\"down_raw\"</code> will plot the raw voltages as the come straight off the SQUID, and <code>\"fit\"</code> will plot the fit data (which is the result of fitting the up and down scans). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Only used if <code>scan</code> is <code>\"fit\"</code>; determines whether to plot the \"Free C Fitted\" or \"Fixed C Fitted\" data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"purple\"</code> and <code>\"orange\"</code> by default.</p> <code>('purple', 'orange')</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> <p>The figure and axes objects created by <code>plot_raw</code>.</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>def plot_raw(\ndata: pd.DataFrame,\ndata_slice: tuple[int, int] | None = None,\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"fit\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"purple\", \"orange\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plot the raw voltage data found in the \"raw_scan\" column of a `DataFrame`, where\n    each row contains a `DcMeasurement` object.\n    Parameters\n    ----------\n    data : pd.DataFrame\n        The `DataFrame` containing the raw data.\n    data_slice : tuple[int, int] | None, optional\n        The slice of data to plot (start, stop). `None` by default. If `None`, all\n        data will be plotted.\n    scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"fit\"], optional\n        Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n        scans (which have been adjusted for drift and shifted to center the waveform\n        around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the raw\n        voltages as the come straight off the SQUID, and `\"fit\"` will plot the\n        fit data (which is the result of fitting the up and down scans). `\"up\"` by\n        default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Only used if `scan` is `\"fit\"`; determines whether to plot the \"Free C\n        Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n        The figure and axes objects created by `plot_raw`.\n    \"\"\"\ndata = _prepare_data_for_plot(data, data_slice)\nstart_label, end_label = _get_voltage_scan_labels(data)\nscan_objs: list[DcMeasurement] = data[\"raw_scan\"]\nscans_w_squid_range = _get_selected_scans(scan, scan_objs)\nif colors is None:\ncolors = (\"purple\", \"orange\")\ncolors = linear_color_gradient(colors[0], colors[1], len(scans_w_squid_range))\nfig, ax = plt.subplots()\nfor i, ((scan_df, squid_range), color) in enumerate(\nzip(scans_w_squid_range, colors)\n):\nrow_label = None\nif label and i == 0:\nrow_label = start_label\nelif label and i == len(scans_w_squid_range) - 1:\nrow_label = end_label\nx = scan_df[\"Raw Position (mm)\"]\nif scan in [\"up\", \"down\"]:\ny = scan_df[\"Processed Voltage (V)\"] * squid_range\nelif scan in [\"up_raw\", \"down_raw\"]:\ny = scan_df[\"Raw Voltage (V)\"] * squid_range\nelse:\nif center == \"free\":\ny = scan_df[\"Free C Fitted (V)\"] * squid_range\nelse:\ny = scan_df[\"Fixed C Fitted (V)\"] * squid_range\nif row_label:\nax.plot(x, y, color=color, label=row_label)\nelse:\nax.plot(x, y, color=color)\nax.set_xlabel(\"Position (mm)\")\nax.set_ylabel(\"Scaled Voltage (V)\")\nif label:\nax.legend(frameon=False)\nif title:\nax.set_title(title)\nforce_aspect(ax)\nreturn fig, ax\n</code></pre>"},{"location":"api/dat_file/#magnetopy.data_files.plot_raw_residual","title":"<code>magnetopy.data_files.plot_raw_residual(data, data_slice=None, scan='up', center='free', colors=None, label=True, title='')</code>","text":"<p>Plot the residual between the raw and fit voltage data found in the \"raw_scan\" column of a <code>DataFrame</code>, where each row contains a <code>DcMeasurement</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The <code>DataFrame</code> containing the raw data.</p> required <code>data_slice</code> <code>tuple[int, int] | None</code> <p>The slice of data to plot (start, stop). <code>None</code> by default. If <code>None</code>, all data will be plotted.</p> <code>None</code> <code>scan</code> <code>Literal['up', 'down']</code> <p>Which data to use in the residual calculation. <code>\"up\"</code> and <code>\"down\"</code> will use the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Determines whether to use the \"Free C Fitted\" or \"Fixed C Fitted\" data for the fit data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"purple\"</code> and <code>\"orange\"</code> by default.</p> <code>None</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> <p>The figure and axes objects created by <code>plot_raw</code>.</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>def plot_raw_residual(\ndata: pd.DataFrame,\ndata_slice: tuple[int, int] | None = None,\nscan: Literal[\"up\", \"down\"] = \"up\",\ncenter: Literal[\"free\", \"fixed\"] = \"free\",\ncolors: tuple[str, str] | None = None,\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plot the residual between the raw and fit voltage data found in the\n    \"raw_scan\" column of a `DataFrame`, where each row contains a `DcMeasurement`\n    object.\n    Parameters\n    ----------\n    data : pd.DataFrame\n        The `DataFrame` containing the raw data.\n    data_slice : tuple[int, int] | None, optional\n        The slice of data to plot (start, stop). `None` by default. If `None`, all\n        data will be plotted.\n    scan : Literal[\"up\", \"down\"], optional\n        Which data to use in the residual calculation. `\"up\"` and `\"down\"` will use the\n        processed directional scans (which have been adjusted for drift and shifted to\n        center the waveform around 0, but have not been fit). `\"up\"` by default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Determines whether to use the \"Free C Fitted\" or \"Fixed C Fitted\" data for the\n        fit data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n        The figure and axes objects created by `plot_raw`.\n    \"\"\"\ndata = _prepare_data_for_plot(data, data_slice)\nstart_label, end_label = _get_voltage_scan_labels(data)\nscan_objs: list[DcMeasurement] = data[\"raw_scan\"]\nscans_w_squid_range = _get_selected_scans(scan, scan_objs)\nfit_scans = [scan_obj.fit_scan.data for scan_obj in scan_objs]\nif colors is None:\ncolors = (\"purple\", \"orange\")\ncolors = linear_color_gradient(colors[0], colors[1], len(scans_w_squid_range))\nfig, ax = plt.subplots()\nfor i, ((scan_df, squid_range), fit_df, color) in enumerate(\nzip(scans_w_squid_range, fit_scans, colors)\n):\nrow_label = None\nif label and i == 0:\nrow_label = start_label\nelif label and i == len(scans_w_squid_range) - 1:\nrow_label = end_label\nx = scan_df[\"Raw Position (mm)\"]\nif center == \"free\":\ny_fit = fit_df[\"Free C Fitted (V)\"] * squid_range\nelse:\ny_fit = fit_df[\"Fixed C Fitted (V)\"] * squid_range\ny_raw = scan_df[\"Processed Voltage (V)\"] * squid_range\ny = y_raw - y_fit\nif row_label:\nax.plot(x, y, color=color, label=row_label)\nelse:\nax.plot(x, y, color=color)\nax.set_xlabel(\"Position (mm)\")\nax.set_ylabel(\"Scaled Voltage (V)\")\nif label:\nax.legend(frameon=False)\nif title:\nax.set_title(title)\nforce_aspect(ax)\nreturn fig, ax\n</code></pre>"},{"location":"api/dc_experiment/","title":"DcExperiment","text":"<p>Any future classes pertaining to dc magnetometry experiments should follow the interface defined by <code>DcExperiment</code>.</p>"},{"location":"api/dc_experiment/#magnetopy.experiments.dc_experiment.DcExperiment","title":"<code>magnetopy.experiments.dc_experiment.DcExperiment</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>The protocol for a DC magnetometry experiment, e.g. M vs H, ZFC/FC, etc.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>pd.DataFrame</code> <p>The data as read in from the experiment file. It should include the columns <code>\"uncorrected_moment\"</code> and <code>\"uncorrected_moment_err\"</code>, which are the moment and moment error directly from the experiment file, whether the measurement was DC or VSM. Scaling methods will act on these columns.</p> <code>scaling</code> <code>list[str]</code> <p>A list of identifiers used to track what scaling was applied to the data, e.g., <code>\"mass\"</code>, <code>\"eicosane_mass\"</code>, <code>\"molecular_weight\"</code>, <code>\"diamagnetic_correction\"</code>.</p> Source code in <code>magnetopy\\experiments\\dc_experiment.py</code> <pre><code>class DcExperiment(Protocol):\n\"\"\"The protocol for a DC magnetometry experiment, e.g. M vs H, ZFC/FC, etc.\n    Attributes\n    ----------\n    data : pd.DataFrame\n        The data as read in from the experiment file. It should include the columns\n        `\"uncorrected_moment\"` and `\"uncorrected_moment_err\"`, which are the moment\n        and moment error directly from the experiment file, whether the measurement\n        was DC or VSM. Scaling methods will act on these columns.\n    scaling : list[str]\n        A list of identifiers used to track what scaling was applied to the data, e.g.,\n        `\"mass\"`, `\"eicosane_mass\"`, `\"molecular_weight\"`, `\"diamagnetic_correction\"`.\n    \"\"\"\ndata: pd.DataFrame\nscaling: list[str]\ndef __init__(self, *args, parse_raw: bool = False, **kwargs) -&gt; None:\n\"\"\"Creates the `DcExperiment` object.\n        Parameters\n        ----------\n        parse_raw : bool, optional\n            If True and there is a corresponding .rw.dat file, the raw data will be\n            parsed and added to the data attribute in the `\"raw_scan\"` column when\n            creating the underlying `DatFile` object.\n        \"\"\"\ndef scale_moment(\nself,\nmass: float = 0,\neicosane_mass: float = 0,\nmolecular_weight: float = 0,\ndiamagnetic_correction: float = 0,\n) -&gt; None:\n\"\"\"Scale the moment by the given values. Scaled values are added to the `data`\n        attribute in the following columns: `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`,\n        `\"chi_t_err\"`, `\"moment\"`, and `\"moment_err\"`. The units of these columns will\n        be determined by what scaling was applied.\n        Parameters\n        ----------\n        mass : float, optional\n            Mass in mg, by default 0\n        eicosane_mass : float, optional\n            Eicosane mass in mg, by default 0\n        molecular_weight : float, optional\n            Molecular weight in g/mol, by default 0\n        diamagnetic_correction : float, optional\n            Diamagnetic Correction in cm^3/mol, by default 0\n        \"\"\"\n...\ndef simplified_data(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Returns a simplified version of the data, with only the columns needed for\n        most analyses and plotting. These columns are: `\"time\"` (in seconds),\n        `\"temperature\"` (in Kelvin), `\"field\"` (in Oe), `\"moment\"`, `\"moment_err\"`,\n        `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and `\"chi_t_err\"`. Where units are not\n        specified, they are determined by what scaling was applied.\n        Returns\n        -------\n        pd.DataFrame\n            A `DataFrame` with the columns: `\"time\"` (in seconds),\n            `\"temperature\"` (in Kelvin), `\"field\"` (in Oe), `\"moment\"`, `\"moment_err\"`,\n            `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and `\"chi_t_err\"`. Where units are not\n            specified, they are determined by what scaling was applied.\n        \"\"\"\n...\n</code></pre>"},{"location":"api/dc_experiment/#magnetopy.experiments.dc_experiment.DcExperiment.__init__","title":"<code>__init__(*args, parse_raw=False, **kwargs)</code>","text":"<p>Creates the <code>DcExperiment</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>parse_raw</code> <code>bool</code> <p>If True and there is a corresponding .rw.dat file, the raw data will be parsed and added to the data attribute in the <code>\"raw_scan\"</code> column when creating the underlying <code>DatFile</code> object.</p> <code>False</code> Source code in <code>magnetopy\\experiments\\dc_experiment.py</code> <pre><code>def __init__(self, *args, parse_raw: bool = False, **kwargs) -&gt; None:\n\"\"\"Creates the `DcExperiment` object.\n    Parameters\n    ----------\n    parse_raw : bool, optional\n        If True and there is a corresponding .rw.dat file, the raw data will be\n        parsed and added to the data attribute in the `\"raw_scan\"` column when\n        creating the underlying `DatFile` object.\n    \"\"\"\n</code></pre>"},{"location":"api/dc_experiment/#magnetopy.experiments.dc_experiment.DcExperiment.scale_moment","title":"<code>scale_moment(mass=0, eicosane_mass=0, molecular_weight=0, diamagnetic_correction=0)</code>","text":"<p>Scale the moment by the given values. Scaled values are added to the <code>data</code> attribute in the following columns: <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, <code>\"chi_t_err\"</code>, <code>\"moment\"</code>, and <code>\"moment_err\"</code>. The units of these columns will be determined by what scaling was applied.</p> <p>Parameters:</p> Name Type Description Default <code>mass</code> <code>float</code> <p>Mass in mg, by default 0</p> <code>0</code> <code>eicosane_mass</code> <code>float</code> <p>Eicosane mass in mg, by default 0</p> <code>0</code> <code>molecular_weight</code> <code>float</code> <p>Molecular weight in g/mol, by default 0</p> <code>0</code> <code>diamagnetic_correction</code> <code>float</code> <p>Diamagnetic Correction in cm^3/mol, by default 0</p> <code>0</code> Source code in <code>magnetopy\\experiments\\dc_experiment.py</code> <pre><code>def scale_moment(\nself,\nmass: float = 0,\neicosane_mass: float = 0,\nmolecular_weight: float = 0,\ndiamagnetic_correction: float = 0,\n) -&gt; None:\n\"\"\"Scale the moment by the given values. Scaled values are added to the `data`\n    attribute in the following columns: `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`,\n    `\"chi_t_err\"`, `\"moment\"`, and `\"moment_err\"`. The units of these columns will\n    be determined by what scaling was applied.\n    Parameters\n    ----------\n    mass : float, optional\n        Mass in mg, by default 0\n    eicosane_mass : float, optional\n        Eicosane mass in mg, by default 0\n    molecular_weight : float, optional\n        Molecular weight in g/mol, by default 0\n    diamagnetic_correction : float, optional\n        Diamagnetic Correction in cm^3/mol, by default 0\n    \"\"\"\n...\n</code></pre>"},{"location":"api/dc_experiment/#magnetopy.experiments.dc_experiment.DcExperiment.simplified_data","title":"<code>simplified_data(*args, **kwargs)</code>","text":"<p>Returns a simplified version of the data, with only the columns needed for most analyses and plotting. These columns are: <code>\"time\"</code> (in seconds), <code>\"temperature\"</code> (in Kelvin), <code>\"field\"</code> (in Oe), <code>\"moment\"</code>, <code>\"moment_err\"</code>, <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, and <code>\"chi_t_err\"</code>. Where units are not specified, they are determined by what scaling was applied.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A <code>DataFrame</code> with the columns: <code>\"time\"</code> (in seconds), <code>\"temperature\"</code> (in Kelvin), <code>\"field\"</code> (in Oe), <code>\"moment\"</code>, <code>\"moment_err\"</code>, <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, and <code>\"chi_t_err\"</code>. Where units are not specified, they are determined by what scaling was applied.</p> Source code in <code>magnetopy\\experiments\\dc_experiment.py</code> <pre><code>def simplified_data(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Returns a simplified version of the data, with only the columns needed for\n    most analyses and plotting. These columns are: `\"time\"` (in seconds),\n    `\"temperature\"` (in Kelvin), `\"field\"` (in Oe), `\"moment\"`, `\"moment_err\"`,\n    `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and `\"chi_t_err\"`. Where units are not\n    specified, they are determined by what scaling was applied.\n    Returns\n    -------\n    pd.DataFrame\n        A `DataFrame` with the columns: `\"time\"` (in seconds),\n        `\"temperature\"` (in Kelvin), `\"field\"` (in Oe), `\"moment\"`, `\"moment_err\"`,\n        `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and `\"chi_t_err\"`. Where units are not\n        specified, they are determined by what scaling was applied.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/experiments_utils/","title":"Utils","text":"<p>These functions are used within the various experiment classes and it's unlikely you'll need them while performing data analysis using <code>magnetopy</code>. Future development of new classes for new experiments may find these useful, though.</p>"},{"location":"api/experiments_utils/#magnetopy.experiments.utils.add_uncorrected_moment_columns","title":"<code>magnetopy.experiments.utils.add_uncorrected_moment_columns(experiment)</code>","text":"<p><code>DataFrame</code>s from .dat files containing dc data have different columns for the moment depending on whether the measurement was done in VSM or DC mode. This function adds a column called \"uncorrected_moment\" and \"uncorrected_moment_err\" that contains the moment and moment error from the .dat file, regardless of whether the measurement was done in VSM or DC mode.</p> <p>Parameters:</p> Name Type Description Default <code>experiment</code> <code>DcExperiment</code> <p>A <code>DcExperiment</code> object (likely either a <code>MvsH</code>, <code>ZFC</code>, or <code>FC</code> object).</p> required Source code in <code>magnetopy\\experiments\\utils.py</code> <pre><code>def add_uncorrected_moment_columns(experiment: DcExperiment) -&gt; None:\n\"\"\"`DataFrame`s from .dat files containing dc data have different columns for the\n    moment depending on whether the measurement was done in VSM or DC mode. This\n    function adds a column called \"uncorrected_moment\" and \"uncorrected_moment_err\"\n    that contains the moment and moment error from the .dat file, regardless of\n    whether the measurement was done in VSM or DC mode.\n    Parameters\n    ----------\n    experiment : DcExperiment\n        A `DcExperiment` object (likely either a `MvsH`, `ZFC`, or `FC` object).\n    \"\"\"\n# set \"uncorrected_moment\" to be the moment directly from the dat file\n# whether the measurement was dc or vsm\nexperiment.data[\"uncorrected_moment\"] = experiment.data[\"Moment (emu)\"].fillna(\nexperiment.data[\"DC Moment Free Ctr (emu)\"]\n)\nexperiment.data[\"uncorrected_moment_err\"] = experiment.data[\n\"M. Std. Err. (emu)\"\n].fillna(experiment.data[\"DC Moment Err Free Ctr (emu)\"])\n</code></pre>"},{"location":"api/experiments_utils/#magnetopy.experiments.utils.scale_dc_data","title":"<code>magnetopy.experiments.utils.scale_dc_data(experiment, mass=0, eicosane_mass=0, molecular_weight=0, diamagnetic_correction=0)</code>","text":"<p>Adds columns to the <code>data</code> attribute of a <code>DcExperiment</code> object that contain the magnetic moment, magnetic susceptibility, and magnetic susceptibility times temperature. The columns added are <code>\"moment\"</code>, <code>\"moment_err\"</code>, <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, and <code>\"chi_t_err\"</code>. The units of these values depend on the values of the <code>mass</code>, <code>eicosane_mass</code>, <code>molecular_weight</code>, and <code>diamagnetic_correction</code>. A record of what scaling was applied is added to the <code>scaling</code> attribute of the <code>DcExperiment</code> object.</p> <p>Here are the currently supported scaling options:</p> <ul> <li> <p>If <code>mass</code> is given but not <code>molecular_weight</code>, the only available scaling is a mass correction.</p> </li> <li> <p>If <code>mass</code> and <code>molecular</code> weight are given, a molar correction is applied. The molar correction can be further modified by giving <code>eicosane_mass</code> and/or <code>diamagnetic_correction</code>.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>experiment</code> <code>DcExperiment</code> <p>A <code>DcExperiment</code> object with a <code>data</code> attribute that has already been processed by <code>add_uncorrected_moment_columns</code> and thus has a column called \"uncorrected_moment\" and \"uncorrected_moment_err\".</p> required <code>mass</code> <code>float</code> <p>mg of sample, by default 0.</p> <code>0</code> <code>eicosane_mass</code> <code>float</code> <p>mg of eicosane, by default 0.</p> <code>0</code> <code>molecular_weight</code> <code>float</code> <p>Molecular weight of the material in g/mol, by default 0.</p> <code>0</code> <code>diamagnetic_correction</code> <code>float</code> <p>Diamagnetic correction of the material in cm^3/mol, by default 0.</p> <code>0</code> Source code in <code>magnetopy\\experiments\\utils.py</code> <pre><code>def scale_dc_data(\nexperiment: DcExperiment,\nmass: float = 0,\neicosane_mass: float = 0,\nmolecular_weight: float = 0,\ndiamagnetic_correction: float = 0,\n) -&gt; None:\n\"\"\"Adds columns to the `data` attribute of a `DcExperiment` object that contain\n    the magnetic moment, magnetic susceptibility, and magnetic susceptibility times\n    temperature. The columns added are `\"moment\"`, `\"moment_err\"`, `\"chi\"`,\n    `\"chi_err\"`, `\"chi_t\"`, and `\"chi_t_err\"`. The units of these values depend on\n    the values of the `mass`, `eicosane_mass`, `molecular_weight`, and\n    `diamagnetic_correction`. A record of what scaling was applied is added to the\n    `scaling` attribute of the `DcExperiment` object.\n    Here are the currently supported scaling options:\n    - If `mass` is given but not `molecular_weight`, the only available scaling is\n    a mass correction.\n    - If `mass` and `molecular` weight are given, a molar correction is applied. The\n    molar correction can be further modified by giving `eicosane_mass` and/or\n    `diamagnetic_correction`.\n    Parameters\n    ----------\n    experiment : DcExperiment\n        A `DcExperiment` object with a `data` attribute that has already been\n        processed by `add_uncorrected_moment_columns` and thus has a column called\n        \"uncorrected_moment\" and \"uncorrected_moment_err\".\n    mass : float, optional\n        mg of sample, by default 0.\n    eicosane_mass : float, optional\n        mg of eicosane, by default 0.\n    molecular_weight : float, optional\n        Molecular weight of the material in g/mol, by default 0.\n    diamagnetic_correction : float, optional\n        Diamagnetic correction of the material in cm^3/mol, by default 0.\n    \"\"\"\nmass = mass / 1000  # convert to g\nif mass and molecular_weight:\nexperiment.scaling.append(\"molar\")\nif eicosane_mass:\nexperiment.scaling.append(\"eicosane\")\nif diamagnetic_correction:\nexperiment.scaling.append(\"diamagnetic_correction\")\nmol = mass / molecular_weight\n_scale_magnetic_data_molar_w_eicosane_and_diamagnet(\nexperiment.data, mol, eicosane_mass, diamagnetic_correction\n)\nelif mass:\nexperiment.scaling.append(\"mass\")\n_scale_magnetic_data_mass(experiment.data, mass)\n</code></pre>"},{"location":"api/experiments_utils/#magnetopy.experiments.utils.num_digits_after_decimal","title":"<code>magnetopy.experiments.utils.num_digits_after_decimal(number)</code>","text":"<p>Return the number of digits after the decimal point in a number.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> required <p>Returns:</p> Type Description <code>int</code> <p>The number of digits after the decimal point in the number.</p> Source code in <code>magnetopy\\experiments\\utils.py</code> <pre><code>def num_digits_after_decimal(number: int | float) -&gt; int:\n\"\"\"Return the number of digits after the decimal point in a number.\n    Parameters\n    ----------\n    number : int | float\n    Returns\n    -------\n    int\n        The number of digits after the decimal point in the number.\n    \"\"\"\nif isinstance(number, int):\nreturn 0\nreturn len(str(number).split(\".\")[1])\n</code></pre>"},{"location":"api/generic_file/","title":"GenericFile","text":""},{"location":"api/generic_file/#magnetopy.data_files.GenericFile","title":"<code>magnetopy.data_files.GenericFile</code>","text":"<p>A class containing basic metadata about a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>The path to the file.</p> required <code>experiment_type</code> <code>str</code> <p>The type of experiment the file is associated with, by default \"\".</p> <code>''</code> <p>Attributes:</p> Name Type Description <code>local_path</code> <code>Path</code> <p>The path to the file.</p> <code>length</code> <code>int</code> <p>The length of the file in bytes.</p> <code>sha512</code> <code>str</code> <p>The SHA512 hash of the file.</p> <code>date_created</code> <code>datetime</code> <p>The date and time the file was created.</p> <code>experiment_type</code> <code>str</code> <p>The type of experiment the file is associated with.</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>class GenericFile:\n\"\"\"A class containing basic metadata about a file.\n    Parameters\n    ----------\n    file_path : str | Path\n        The path to the file.\n    experiment_type : str, optional\n        The type of experiment the file is associated with, by default \"\".\n    Attributes\n    ----------\n    local_path : Path\n        The path to the file.\n    length : int\n        The length of the file in bytes.\n    sha512 : str\n        The SHA512 hash of the file.\n    date_created : datetime\n        The date and time the file was created.\n    experiment_type : str\n        The type of experiment the file is associated with.\n    \"\"\"\ndef __init__(self, file_path: str | Path, experiment_type: str = \"\") -&gt; None:\nself.local_path = Path(file_path)\nself.length = self.local_path.stat().st_size\nself.date_created = datetime.fromtimestamp(self.local_path.stat().st_ctime)\nself.sha512 = self._determine_sha512()\nself.experiment_type = experiment_type\ndef __str__(self) -&gt; str:\nreturn f\"GenericFile({self.local_path.name})\"\ndef __repr__(self) -&gt; str:\nreturn f\"GenericFile({self.local_path.name})\"\ndef _determine_sha512(self) -&gt; str:\nbuf_size = 4 * 1024 * 1024  # 4MB chunks\nhasher = hashlib.sha512()\nwith self.local_path.open(\"rb\") as f:\nwhile data := f.read(buf_size):\nhasher.update(data)\nreturn hasher.hexdigest()\ndef as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Serializes the GenericFile object to a dictionary.\n        Returns\n        -------\n        dict[str, Any]\n            Contains the following keys: local_path, length, date_created, sha512\n        \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"experiment_type\": self.experiment_type,\n\"local_path\": str(self.local_path),\n\"length\": self.length,\n\"date_created\": self.date_created.isoformat(),\n\"sha512\": self.sha512,\n}\n</code></pre>"},{"location":"api/generic_file/#magnetopy.data_files.GenericFile.as_dict","title":"<code>as_dict()</code>","text":"<p>Serializes the GenericFile object to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Contains the following keys: local_path, length, date_created, sha512</p> Source code in <code>magnetopy\\data_files.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Serializes the GenericFile object to a dictionary.\n    Returns\n    -------\n    dict[str, Any]\n        Contains the following keys: local_path, length, date_created, sha512\n    \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"experiment_type\": self.experiment_type,\n\"local_path\": str(self.local_path),\n\"length\": self.length,\n\"date_created\": self.date_created.isoformat(),\n\"sha512\": self.sha512,\n}\n</code></pre>"},{"location":"api/magnetometry/","title":"Magnetometry","text":""},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry","title":"<code>magnetopy.magnetometry.Magnetometry</code>","text":"<p>A class which contains magnetometry data for a single sample along with methods for parsing, processing, and analyzing the data. Note that \"single sample\" means that in situations in which a single material is measured in multiple samples, each sample should be treated as a separate <code>Magnetometry</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory containing the .dat files for the sample.</p> required <code>sample_id</code> <code>str</code> <p>The sample ID. If not provided, the name of the directory containing the .dat files will be used.</p> <code>'auto'</code> <code>magnetic_data_scaling</code> <code>str | list[str]</code> <p>Default <code>\"auto\"</code>. Instructions for scaling the magnetic moment. Options are \"mass\", \"molar\", \"eicosane\", \"diamagnetic_correction\", and \"auto\". If \"auto\" is specified, the scaling will be determined automatically based on the available sample information found in the first .dat file found in the directory.</p> <code>'auto'</code> <code>true_field_correction</code> <code>str | Path</code> <p>The path to a file containing the M vs. H data of a Pd standard sample and to be used for correcting the field of all <code>MvsH</code> objects. Note that this is a convenience method for situations in which all <code>MvsH</code> objects use the same sequence and can be corrected by the same file. Individual corrections can be performed by calling the <code>correct_field</code> method of the relevant <code>MvsH</code> object.</p> <code>''</code> <code>parse_raw</code> <code>bool</code> <p>Default <code>False</code>. If <code>True</code>, any .rw.dat files in the directory will be parsed and the raw data will be stored in the <code>\"raw_scan\"</code> column of the corresponding <code>data</code> attribute of the relevant <code>DcExperiment</code> object.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>sample_id</code> <code>str</code> <p>The sample ID.</p> <code>files</code> <code>list[DatFile]</code> <p>A list of the <code>DatFile</code> objects in the directory. Note that this includes both .dat and .rw.dat files.</p> <code>magnetic_data_scaling</code> <code>list[str]</code> <p>A record of the scaling options used to scale the magnetic data. Options are \"mass\", \"molar\", \"eicosane\", and \"diamagnetic_correction\". Currently supported combinations are: <code>[\"mass\"] | [\"molar\"] | [\"molar\", \"eicosane\"] | [\"molar\", \"diamagnetic_correction\"] | [\"molar\", \"eicosane\", \"diamagnetic_correction\"]</code>.</p> <code>sample_info</code> <code>SampleInfo</code> <p>Information specific to the particular sample used for magnetic measurements. Note that this is determined by reading the first <code>DatFile</code> in <code>files</code>, and it is assumed that all <code>DatFile</code> objects in <code>files</code> are for the same sample.</p> <code>mvsh</code> <code>list[MvsH]</code> <p>A list of the <code>MvsH</code> objects in the directory.</p> <code>zfc</code> <code>list[ZFC]</code> <p>A list of the <code>ZFC</code> objects in the directory.</p> <code>fc</code> <code>list[FC]</code> <p>A list of the <code>FC</code> objects in the directory.</p> <code>analyses</code> <code>list[Analysis]</code> <p>A list of the analyses performed on the data.</p>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry--notes","title":"Notes","text":"<p>Scaling of magnetic data occurs during object initialization, unless <code>magnetic_data_scaling</code> is set to <code>''</code>. If the user needs to overwrite the automatically scaled values (say, if the sample information from the .dat file needs to be altered), the user can do so by overwriting the relevant attributes of the <code>sample_info</code> attribute (e.g. <code>mass</code>, <code>molecular_weight</code>, etc.), then calling the <code>scale_dc_data</code> method.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>class Magnetometry:\n\"\"\"\n    A class which contains magnetometry data for a single sample along with methods for\n    parsing, processing, and analyzing the data. Note that \"single sample\" means that\n    in situations in which a single _material_ is measured in multiple samples, each\n    sample should be treated as a separate `Magnetometry` object.\n    Parameters\n    ----------\n    path : str | Path\n        The path to the directory containing the .dat files for the sample.\n    sample_id : str, optional\n        The sample ID. If not provided, the name of the directory containing the .dat\n        files will be used.\n    magnetic_data_scaling : str | list[str], optional\n        Default `\"auto\"`. Instructions for scaling the magnetic moment. Options are\n        \"mass\", \"molar\", \"eicosane\", \"diamagnetic_correction\", and \"auto\". If \"auto\" is\n        specified, the scaling will be determined automatically based on the available\n        sample information found in the first .dat file found in the directory.\n    true_field_correction : str | Path, optional\n        The path to a file containing the M vs. H data of a Pd standard sample and to\n        be used for correcting the field of all `MvsH` objects. Note that this is a\n        convenience method for situations in which all `MvsH` objects use the same\n        sequence and can be corrected by the same file. Individual corrections can be\n        performed by calling the `correct_field` method of the relevant `MvsH` object.\n    parse_raw : bool, optional\n        Default `False`. If `True`, any .rw.dat files in the directory will be parsed\n        and the raw data will be stored in the `\"raw_scan\"` column of the corresponding\n        `data` attribute of the relevant `DcExperiment` object.\n    Attributes\n    ----------\n    sample_id : str\n        The sample ID.\n    files : list[DatFile]\n        A list of the `DatFile` objects in the directory. Note that this includes both\n        .dat and .rw.dat files.\n    magnetic_data_scaling : list[str]\n        A record of the scaling options used to scale the magnetic data. Options are\n        \"mass\", \"molar\", \"eicosane\", and \"diamagnetic_correction\". Currently supported\n        combinations are: `[\"mass\"] | [\"molar\"] | [\"molar\", \"eicosane\"] | [\"molar\",\n        \"diamagnetic_correction\"] | [\"molar\", \"eicosane\", \"diamagnetic_correction\"]`.\n    sample_info : SampleInfo\n        Information specific to the particular sample used for magnetic measurements.\n        Note that this is determined by reading the first `DatFile` in `files`, and\n        it is assumed that all `DatFile` objects in `files` are for the same\n        sample.\n    mvsh : list[MvsH]\n        A list of the `MvsH` objects in the directory.\n    zfc : list[ZFC]\n        A list of the `ZFC` objects in the directory.\n    fc : list[FC]\n        A list of the `FC` objects in the directory.\n    analyses : list[Analysis]\n        A list of the analyses performed on the data.\n    Notes\n    -----\n    Scaling of magnetic data occurs during object initialization, unless\n    `magnetic_data_scaling` is set to `''`. If the user needs to overwrite the\n    automatically scaled values (say, if the sample information from the .dat file\n    needs to be altered), the user can do so by overwriting the relevant attributes of\n    the `sample_info` attribute (e.g. `mass`, `molecular_weight`, etc.), then calling\n    the `scale_dc_data` method.\n    \"\"\"\nclass ExperimentNotFoundError(Exception):\npass\ndef __init__(\nself,\npath: str | Path,\nsample_id: str = \"auto\",\nmagnetic_data_scaling: str | list[str] = \"auto\",\ntrue_field_correction: str | Path = \"\",\nparse_raw: bool = False,\n) -&gt; None:\npath = Path(path)\nself.sample_id = path.name if sample_id == \"auto\" else sample_id\nself.files = [\nDatFile(file, parse_raw) for file in path.rglob(\"*.dat\") if file.is_file()\n]\nself.magnetic_data_scaling = (\n[magnetic_data_scaling]\nif isinstance(magnetic_data_scaling, str)\nelse magnetic_data_scaling\n)\nself.sample_info = SampleInfo.from_dat_file(self.files[0])\nself.mvsh = self.extract_mvsh()\nself.zfc = self.extract_zfc()\nself.fc = self.extract_fc()\nself.scale_dc_data()\nif true_field_correction:\nself.correct_field(true_field_correction)\nself.analyses: list[Analysis] = []\ndef __str__(self) -&gt; str:\nreturn f\"Dataset({self.sample_id})\"\ndef __repr__(self) -&gt; str:\nreturn f\"Dataset({self.sample_id})\"\ndef extract_mvsh(\nself, eps: float = 0.001, min_samples: int = 10, ndigits: int = 0\n) -&gt; list[MvsH]:\n\"\"\"Extracts all M vs. H experiments found within `files`. This is run\n        during object initialization but is available to the user in the event that\n        the default parsing parameters need to be changed for proper data extraction.\n        See `magnetopy.experiments.mvsh.MvsH.get_all_in_file` for more information.\n        Parameters\n        ----------\n        eps : float, optional\n        min_samples : int, optional\n        ndigits : int, optional\n        Returns\n        -------\n        list[MvsH]\n            The `MvsH` objects found in `files`.\n        \"\"\"\nmvsh_files = [\ndat_file\nfor dat_file in self.files\nif \"mvsh\" in dat_file.experiments_in_file\n]\nmvsh_objs: list[MvsH] = []\nfor dat_file in mvsh_files:\nmvsh_objs.extend(MvsH.get_all_in_file(dat_file, eps, min_samples, ndigits))\nmvsh_objs.sort(key=lambda x: x.temperature)\nreturn mvsh_objs\ndef extract_zfc(self, n_digits: int = 0) -&gt; list[ZFC]:\n\"\"\"Extracts all ZFC experiments found within `files`. This is run\n        during object initialization but is available to the user in the event that\n        the default parsing parameters need to be changed for proper data extraction.\n        See `magnetopy.experiments.zfcfc.ZFC.get_all_in_file` for more information.\n        Parameters\n        ----------\n        n_digits : int, optional\n        Returns\n        -------\n        list[ZFC]\n            The `ZFC` objects found in `files`.\n        \"\"\"\nzfc_files = [\ndat_file\nfor dat_file in self.files\nif set([\"zfc\", \"zfcfc\"]).intersection(dat_file.experiments_in_file)\n]\nzfc_objs: list[ZFC] = []\nfor dat_file in zfc_files:\nzfc_objs.extend(ZFC.get_all_in_file(dat_file, n_digits))\nzfc_objs.sort(key=lambda x: x.field)\nreturn zfc_objs\ndef extract_fc(self, n_digits: int = 0) -&gt; list[FC]:\n\"\"\"Extracts all FC experiments found within `files`. This is run\n        during object initialization but is available to the user in the event that\n        the default parsing parameters need to be changed for proper data extraction.\n        See `magnetopy.experiments.zfcfc.FC.get_all_in_file` for more information.\n        Parameters\n        ----------\n        n_digits : int, optional\n            Default 0\n        Returns\n        -------\n        list[FC]\n            The `FC` objects found in `files`.\n        \"\"\"\nfc_files = [\ndat_file\nfor dat_file in self.files\nif set([\"fc\", \"zfcfc\"]).intersection(dat_file.experiments_in_file)\n]\nfc_objs: list[FC] = []\nfor dat_file in fc_files:\nfc_objs.extend(FC.get_all_in_file(dat_file, n_digits))\nfc_objs.sort(key=lambda x: x.field)\nreturn fc_objs\ndef scale_dc_data(self) -&gt; None:\n\"\"\"Scales the magnetic moment of all `DcExperiment` objects (i.e., `MvsH`,\n        `ZFC`, and `FC` objects) in the `Magnetometry` object according to the scaling\n        options specified in `magnetic_data_scaling` and the sample information in\n        `sample_info`. This is run during object initialization but is available to\n        the user in the event that either the defaul scaling options or the sample\n        information need to be changed for proper data scaling.\n        See `magnetopy.experiments.utils.scale_dc_data` for more information.\n        \"\"\"\nexperiments: list[DcExperiment] = []\nexperiments.extend(self.mvsh)\nexperiments.extend(self.zfc)\nexperiments.extend(self.fc)\nmass = (\nself.sample_info.mass\nif set(self.magnetic_data_scaling).intersection([\"mass\", \"molar\", \"auto\"])\nelse 0\n)\neicosane_mass = (\nself.sample_info.eicosane_mass\nif set(self.magnetic_data_scaling).intersection([\"eicosane\", \"auto\"])\nelse 0\n)\nmol_weight = (\nself.sample_info.molecular_weight\nif set(self.magnetic_data_scaling).intersection([\"molar\", \"auto\"])\nelse 0\n)\ndiamagnetic_correction = (\nself.sample_info.diamagnetic_correction\nif set(self.magnetic_data_scaling).intersection(\n[\"diamagnetic_correction\", \"auto\"]\n)\nelse 0\n)\nfor experiment in experiments:\nexperiment.scale_moment(\nmass, eicosane_mass, mol_weight, diamagnetic_correction\n)\ndef correct_field(self, field_correction_file: str | Path) -&gt; None:\n\"\"\"A convenience method for correcting the field of all `MvsH` objects in the\n        `Magnetometry` object using the same field correction file.\n        See `magnetopy.experiments.mvsh.MvsH.correct_field` for more information.\n        Parameters\n        ----------\n        field_correction_file : str | Path\n            The path to the field correction file.\n        \"\"\"\nfor experiment in self.mvsh:\nexperiment.correct_field(field_correction_file)\ndef get_mvsh(self, temperature: float) -&gt; MvsH:\n\"\"\"Get the `MvsH` object at the specified temperature.\n        Parameters\n        ----------\n        temperature : float\n            Temperature in Kelvin.\n        Returns\n        -------\n        MvsH\n            The `MvsH` object at the specified temperature.\n        Raises\n        ------\n        self.ExperimentNotFoundError\n            If no `MvsH` object is found at the specified temperature.\n        \"\"\"\nfor mvsh in self.mvsh:\nif mvsh.temperature == temperature:\nreturn mvsh\nraise self.ExperimentNotFoundError(\nf\"No MvsH experiment found at temperature {temperature} K\"\n)\ndef get_zfc(self, field: float) -&gt; ZFC:\n\"\"\"Get the `ZFC` object at the specified field.\n        Parameters\n        ----------\n        field : float\n            Field in Oe.\n        Returns\n        -------\n        ZFC\n            The `ZFC` object at the specified field.\n        Raises\n        ------\n        self.ExperimentNotFoundError\n            If no `ZFC` object is found at the specified field.\n        \"\"\"\nfor zfc in self.zfc:\nif zfc.field == field:\nreturn zfc\nraise self.ExperimentNotFoundError(\nf\"No ZFC experiment found at field {field} Oe\"\n)\ndef get_fc(self, field: float) -&gt; FC:\n\"\"\"Get the `FC` object at the specified field.\n        Parameters\n        ----------\n        field : float\n            Field in Oe.\n        Returns\n        -------\n        FC\n            The `FC` object at the specified field.\n        Raises\n        ------\n        self.ExperimentNotFoundError\n            If no `FC` object is found at the specified field.\n        \"\"\"\nfor fc in self.fc:\nif fc.field == field:\nreturn fc\nraise self.ExperimentNotFoundError(\nf\"No FC experiment found at field {field} Oe\"\n)\ndef add_analysis(self, analysis: Analysis | list[Analysis]) -&gt; None:\n\"\"\"Add an analysis to the `Magnetometry` object.\n        See `magnetopy.magnetometry.Analysis` for more information.\n        Parameters\n        ----------\n        analysis : Analysis | list[Analysis]\n            An instance of a class (or list of such instances) that implements the\n            `Analysis` protocol.\n        \"\"\"\nif isinstance(analysis, list):\nself.analyses.extend(analysis)\nelse:\nself.analyses.append(analysis)\ndef as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Create a dictionary representation of the `Magnetometry` object.\n        Returns\n        -------\n        dict[str, Any]\n        \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"sample_id\": self.sample_id,\n\"files\": self.files,\n\"sample_info\": self.sample_info,\n\"mvsh\": self.mvsh,\n\"zfc\": self.zfc,\n\"fc\": self.fc,\n\"analyses\": self.analyses,\n}\ndef plot_mvsh(\nself,\ntemperatures: float | list[float] | None = None,\nnormalized: bool = False,\nsegment: Literal[\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"] = \"\",\ncolors: str | list[str] = \"auto\",\nlabels: str | list[str] | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plot the M vs. H data in the `Magnetometry` object. If `temperatures` is\n        `None`, all `MvsH` objects will be plotted. Otherwise, only the `MvsH` objects\n        at the specified temperatures will be plotted.\n        Parameters\n        ----------\n        temperatures : float | list[float] | None, optional\n            Default `None`. The temperatures at which to plot the M vs. H data. If\n            `None`, all `MvsH` objects will be plotted. Otherwise, only the `MvsH`\n            objects at the specified temperatures will be plotted.\n        normalized : bool, optional\n            If `True`, the magnetization will be normalized to the maximum value, by\n            default False.\n        segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n            If a segment is given, only that segment will be plotted, by default \"\".\n        colors : str | list[str], optional\n            A list of colors corresponding to the `MvsH` objects in `mvsh`, by default\n            \"auto\". If \"auto\" and `mvsh` is a single `MvsH` object, the color will be\n            black. If \"auto\" and `mvsh` is a list of `MvsH` objects with different\n            temperatures, the colors will be a linear gradient from blue to red. If\n            \"auto\" and `mvsh` is a list of `MvsH` objects with the same temperature, the\n            colors will be the default `matplotlib` colors.\n        labels : str | list[str] | None, optional\n            The labels to assign the `MvsH` objects in the axes legend, by default \"auto\".\n            If \"auto\", the labels will be the `temperature` of the `MvsH` objects.\n        title : str, optional\n            The title of the plot, by default \"\".\n        **kwargs\n            Keyword arguments mostly meant to affect the plot style. See\n            `magnetopy.experiments.plot_utils.handle_options` for details.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n            The figure and axes objects of the plot.\n        \"\"\"\nif temperatures is None:\nreturn plot_mvsh(\nself.mvsh, normalized, segment, colors, labels, title, **kwargs\n)\ntemperatures = (\n[temperatures] if isinstance(temperatures, float) else temperatures\n)\nmvsh = [self.get_mvsh(temperature) for temperature in temperatures]\nreturn plot_mvsh(mvsh, normalized, segment, colors, labels, title, **kwargs)\ndef plot_zfcfc(\nself,\nfields: float | list[float] | None = None,\ny_val: Literal[\"moment\", \"chi\", \"chi_t\"] = \"moment\",\nnormalized: bool = False,\ncolors: str | list[str] = \"auto\",\nlabels: str | list[str] | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plot the ZFC/FC data in the `Magnetometry` object. If `fields` is `None`,\n        all `ZFC` and `FC` objects will be plotted. Otherwise, only the `ZFC` and `FC`\n        objects at the specified fields will be plotted.\n        Parameters\n        ----------\n        fields : float | list[float] | None, optional\n            Default `None`. The fields at which to plot the ZFC/FC data. If `None`, all\n            `ZFC` and `FC` objects will be plotted. Otherwise, only the `ZFC` and `FC`\n            objects at the specified fields will be plotted.\n        normalized : bool, optional\n            If `True`, the magnetization will be normalized to the maximum value, by\n            default False.\n        colors : str | list[str], optional\n            A list of colors corresponding to the `ZFC`/`FC` pairs, by default \"auto\". If\n            \"auto\" and there is a single pair, the color will be black. If \"auto\" and\n            there is a list of pairs with different fields, the colors will be a linear\n            gradient from purple to green. If \"auto\" and the list of pairs is at the same\n            field, the colors will be the default `matplotlib` colors.\n        labels : str | list[str] | None, optional\n            The labels to assign the `ZFC`/`FC` pair in the axes legend, by default \"auto\".\n            If \"auto\", the label will be the `field` of the `MvsH` object.\n        title : str, optional\n            The title of the plot, by default \"\".\n        **kwargs\n            Keyword arguments mostly meant to affect the plot style. See `handle_options`\n            for details.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n            The figure and axes objects of the plot.\n        \"\"\"\nif fields is None:\nreturn plot_zfcfc(\nself.zfc, self.fc, y_val, normalized, colors, labels, title, **kwargs\n)\nzfc = [self.get_zfc(field) for field in fields]\nfc = [self.get_fc(field) for field in fields]\nreturn plot_zfcfc(zfc, fc, y_val, normalized, colors, labels, title, **kwargs)\ndef as_json(self, indent: int = 0) -&gt; str:\n\"\"\"Create a JSON representation of the `Magnetometry` object.\n        Parameters\n        ----------\n        indent : int, optional\n            Default 0. The number of spaces to indent the JSON.\n        Returns\n        -------\n        str\n        \"\"\"\nreturn json.dumps(self, default=lambda x: x.as_dict(), indent=indent)\ndef create_report(\nself, directory: str | Path | None = None, overwrite: bool = False\n) -&gt; None:\n\"\"\"Create a JSON report of the `Magnetometry` object.\n        Parameters\n        ----------\n        directory : str | Path | None, optional\n            Default `None`. The directory to write the report to. If `None`, the report\n            will be written to the directory containing the .dat files.\n        overwrite : bool, optional\n            Default `False`. Whether to overwrite the report if it already exists. If\n            `False` and the report already exists, the user will be prompted to\n            overwrite the report.\n        \"\"\"\nif directory:\ndirectory = Path(directory)\nelse:\ndirectory = self.files[0].local_path.parent\npath = directory / f\"{self.sample_id}.json\"\nif path.exists() and overwrite is False:\nreponse = input(f\"File {path} already exists. Overwrite? [y/N] \")\nif reponse.lower() != \"y\":\nprint(\"Aborting report creation.\")\nreturn\nwith open(path, \"w\", encoding=\"utf-8\") as f:\nf.write(self.as_json(indent=4))\nprint(f\"Report written to {path}\")\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.get_mvsh","title":"<code>get_mvsh(temperature)</code>","text":"<p>Get the <code>MvsH</code> object at the specified temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>float</code> <p>Temperature in Kelvin.</p> required <p>Returns:</p> Type Description <code>MvsH</code> <p>The <code>MvsH</code> object at the specified temperature.</p> <p>Raises:</p> Type Description <code>self.ExperimentNotFoundError</code> <p>If no <code>MvsH</code> object is found at the specified temperature.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def get_mvsh(self, temperature: float) -&gt; MvsH:\n\"\"\"Get the `MvsH` object at the specified temperature.\n    Parameters\n    ----------\n    temperature : float\n        Temperature in Kelvin.\n    Returns\n    -------\n    MvsH\n        The `MvsH` object at the specified temperature.\n    Raises\n    ------\n    self.ExperimentNotFoundError\n        If no `MvsH` object is found at the specified temperature.\n    \"\"\"\nfor mvsh in self.mvsh:\nif mvsh.temperature == temperature:\nreturn mvsh\nraise self.ExperimentNotFoundError(\nf\"No MvsH experiment found at temperature {temperature} K\"\n)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.get_zfc","title":"<code>get_zfc(field)</code>","text":"<p>Get the <code>ZFC</code> object at the specified field.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>float</code> <p>Field in Oe.</p> required <p>Returns:</p> Type Description <code>ZFC</code> <p>The <code>ZFC</code> object at the specified field.</p> <p>Raises:</p> Type Description <code>self.ExperimentNotFoundError</code> <p>If no <code>ZFC</code> object is found at the specified field.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def get_zfc(self, field: float) -&gt; ZFC:\n\"\"\"Get the `ZFC` object at the specified field.\n    Parameters\n    ----------\n    field : float\n        Field in Oe.\n    Returns\n    -------\n    ZFC\n        The `ZFC` object at the specified field.\n    Raises\n    ------\n    self.ExperimentNotFoundError\n        If no `ZFC` object is found at the specified field.\n    \"\"\"\nfor zfc in self.zfc:\nif zfc.field == field:\nreturn zfc\nraise self.ExperimentNotFoundError(\nf\"No ZFC experiment found at field {field} Oe\"\n)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.get_fc","title":"<code>get_fc(field)</code>","text":"<p>Get the <code>FC</code> object at the specified field.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>float</code> <p>Field in Oe.</p> required <p>Returns:</p> Type Description <code>FC</code> <p>The <code>FC</code> object at the specified field.</p> <p>Raises:</p> Type Description <code>self.ExperimentNotFoundError</code> <p>If no <code>FC</code> object is found at the specified field.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def get_fc(self, field: float) -&gt; FC:\n\"\"\"Get the `FC` object at the specified field.\n    Parameters\n    ----------\n    field : float\n        Field in Oe.\n    Returns\n    -------\n    FC\n        The `FC` object at the specified field.\n    Raises\n    ------\n    self.ExperimentNotFoundError\n        If no `FC` object is found at the specified field.\n    \"\"\"\nfor fc in self.fc:\nif fc.field == field:\nreturn fc\nraise self.ExperimentNotFoundError(\nf\"No FC experiment found at field {field} Oe\"\n)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.correct_field","title":"<code>correct_field(field_correction_file)</code>","text":"<p>A convenience method for correcting the field of all <code>MvsH</code> objects in the <code>Magnetometry</code> object using the same field correction file.</p> <p>See <code>magnetopy.experiments.mvsh.MvsH.correct_field</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>field_correction_file</code> <code>str | Path</code> <p>The path to the field correction file.</p> required Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def correct_field(self, field_correction_file: str | Path) -&gt; None:\n\"\"\"A convenience method for correcting the field of all `MvsH` objects in the\n    `Magnetometry` object using the same field correction file.\n    See `magnetopy.experiments.mvsh.MvsH.correct_field` for more information.\n    Parameters\n    ----------\n    field_correction_file : str | Path\n        The path to the field correction file.\n    \"\"\"\nfor experiment in self.mvsh:\nexperiment.correct_field(field_correction_file)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.scale_dc_data","title":"<code>scale_dc_data()</code>","text":"<p>Scales the magnetic moment of all <code>DcExperiment</code> objects (i.e., <code>MvsH</code>, <code>ZFC</code>, and <code>FC</code> objects) in the <code>Magnetometry</code> object according to the scaling options specified in <code>magnetic_data_scaling</code> and the sample information in <code>sample_info</code>. This is run during object initialization but is available to the user in the event that either the defaul scaling options or the sample information need to be changed for proper data scaling.</p> <p>See <code>magnetopy.experiments.utils.scale_dc_data</code> for more information.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def scale_dc_data(self) -&gt; None:\n\"\"\"Scales the magnetic moment of all `DcExperiment` objects (i.e., `MvsH`,\n    `ZFC`, and `FC` objects) in the `Magnetometry` object according to the scaling\n    options specified in `magnetic_data_scaling` and the sample information in\n    `sample_info`. This is run during object initialization but is available to\n    the user in the event that either the defaul scaling options or the sample\n    information need to be changed for proper data scaling.\n    See `magnetopy.experiments.utils.scale_dc_data` for more information.\n    \"\"\"\nexperiments: list[DcExperiment] = []\nexperiments.extend(self.mvsh)\nexperiments.extend(self.zfc)\nexperiments.extend(self.fc)\nmass = (\nself.sample_info.mass\nif set(self.magnetic_data_scaling).intersection([\"mass\", \"molar\", \"auto\"])\nelse 0\n)\neicosane_mass = (\nself.sample_info.eicosane_mass\nif set(self.magnetic_data_scaling).intersection([\"eicosane\", \"auto\"])\nelse 0\n)\nmol_weight = (\nself.sample_info.molecular_weight\nif set(self.magnetic_data_scaling).intersection([\"molar\", \"auto\"])\nelse 0\n)\ndiamagnetic_correction = (\nself.sample_info.diamagnetic_correction\nif set(self.magnetic_data_scaling).intersection(\n[\"diamagnetic_correction\", \"auto\"]\n)\nelse 0\n)\nfor experiment in experiments:\nexperiment.scale_moment(\nmass, eicosane_mass, mol_weight, diamagnetic_correction\n)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.add_analysis","title":"<code>add_analysis(analysis)</code>","text":"<p>Add an analysis to the <code>Magnetometry</code> object.</p> <p>See <code>magnetopy.magnetometry.Analysis</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>analysis</code> <code>Analysis | list[Analysis]</code> <p>An instance of a class (or list of such instances) that implements the <code>Analysis</code> protocol.</p> required Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def add_analysis(self, analysis: Analysis | list[Analysis]) -&gt; None:\n\"\"\"Add an analysis to the `Magnetometry` object.\n    See `magnetopy.magnetometry.Analysis` for more information.\n    Parameters\n    ----------\n    analysis : Analysis | list[Analysis]\n        An instance of a class (or list of such instances) that implements the\n        `Analysis` protocol.\n    \"\"\"\nif isinstance(analysis, list):\nself.analyses.extend(analysis)\nelse:\nself.analyses.append(analysis)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.plot_mvsh","title":"<code>plot_mvsh(temperatures=None, normalized=False, segment='', colors='auto', labels='auto', title='', **kwargs)</code>","text":"<p>Plot the M vs. H data in the <code>Magnetometry</code> object. If <code>temperatures</code> is <code>None</code>, all <code>MvsH</code> objects will be plotted. Otherwise, only the <code>MvsH</code> objects at the specified temperatures will be plotted.</p> <p>Parameters:</p> Name Type Description Default <code>temperatures</code> <code>float | list[float] | None</code> <p>Default <code>None</code>. The temperatures at which to plot the M vs. H data. If <code>None</code>, all <code>MvsH</code> objects will be plotted. Otherwise, only the <code>MvsH</code> objects at the specified temperatures will be plotted.</p> <code>None</code> <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>segment</code> <code>Literal['', 'virgin', 'forward', 'reverse', 'loop']</code> <p>If a segment is given, only that segment will be plotted, by default \"\".</p> <code>\"\"</code> <code>colors</code> <code>str | list[str]</code> <p>A list of colors corresponding to the <code>MvsH</code> objects in <code>mvsh</code>, by default \"auto\". If \"auto\" and <code>mvsh</code> is a single <code>MvsH</code> object, the color will be black. If \"auto\" and <code>mvsh</code> is a list of <code>MvsH</code> objects with different temperatures, the colors will be a linear gradient from blue to red. If \"auto\" and <code>mvsh</code> is a list of <code>MvsH</code> objects with the same temperature, the colors will be the default <code>matplotlib</code> colors.</p> <code>'auto'</code> <code>labels</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>MvsH</code> objects in the axes legend, by default \"auto\". If \"auto\", the labels will be the <code>temperature</code> of the <code>MvsH</code> objects.</p> <code>'auto'</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> <p>The figure and axes objects of the plot.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def plot_mvsh(\nself,\ntemperatures: float | list[float] | None = None,\nnormalized: bool = False,\nsegment: Literal[\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"] = \"\",\ncolors: str | list[str] = \"auto\",\nlabels: str | list[str] | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plot the M vs. H data in the `Magnetometry` object. If `temperatures` is\n    `None`, all `MvsH` objects will be plotted. Otherwise, only the `MvsH` objects\n    at the specified temperatures will be plotted.\n    Parameters\n    ----------\n    temperatures : float | list[float] | None, optional\n        Default `None`. The temperatures at which to plot the M vs. H data. If\n        `None`, all `MvsH` objects will be plotted. Otherwise, only the `MvsH`\n        objects at the specified temperatures will be plotted.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n        If a segment is given, only that segment will be plotted, by default \"\".\n    colors : str | list[str], optional\n        A list of colors corresponding to the `MvsH` objects in `mvsh`, by default\n        \"auto\". If \"auto\" and `mvsh` is a single `MvsH` object, the color will be\n        black. If \"auto\" and `mvsh` is a list of `MvsH` objects with different\n        temperatures, the colors will be a linear gradient from blue to red. If\n        \"auto\" and `mvsh` is a list of `MvsH` objects with the same temperature, the\n        colors will be the default `matplotlib` colors.\n    labels : str | list[str] | None, optional\n        The labels to assign the `MvsH` objects in the axes legend, by default \"auto\".\n        If \"auto\", the labels will be the `temperature` of the `MvsH` objects.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n        The figure and axes objects of the plot.\n    \"\"\"\nif temperatures is None:\nreturn plot_mvsh(\nself.mvsh, normalized, segment, colors, labels, title, **kwargs\n)\ntemperatures = (\n[temperatures] if isinstance(temperatures, float) else temperatures\n)\nmvsh = [self.get_mvsh(temperature) for temperature in temperatures]\nreturn plot_mvsh(mvsh, normalized, segment, colors, labels, title, **kwargs)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.plot_zfcfc","title":"<code>plot_zfcfc(fields=None, y_val='moment', normalized=False, colors='auto', labels='auto', title='', **kwargs)</code>","text":"<p>Plot the ZFC/FC data in the <code>Magnetometry</code> object. If <code>fields</code> is <code>None</code>, all <code>ZFC</code> and <code>FC</code> objects will be plotted. Otherwise, only the <code>ZFC</code> and <code>FC</code> objects at the specified fields will be plotted.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>float | list[float] | None</code> <p>Default <code>None</code>. The fields at which to plot the ZFC/FC data. If <code>None</code>, all <code>ZFC</code> and <code>FC</code> objects will be plotted. Otherwise, only the <code>ZFC</code> and <code>FC</code> objects at the specified fields will be plotted.</p> <code>None</code> <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>colors</code> <code>str | list[str]</code> <p>A list of colors corresponding to the <code>ZFC</code>/<code>FC</code> pairs, by default \"auto\". If \"auto\" and there is a single pair, the color will be black. If \"auto\" and there is a list of pairs with different fields, the colors will be a linear gradient from purple to green. If \"auto\" and the list of pairs is at the same field, the colors will be the default <code>matplotlib</code> colors.</p> <code>'auto'</code> <code>labels</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>ZFC</code>/<code>FC</code> pair in the axes legend, by default \"auto\". If \"auto\", the label will be the <code>field</code> of the <code>MvsH</code> object.</p> <code>'auto'</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> <p>The figure and axes objects of the plot.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def plot_zfcfc(\nself,\nfields: float | list[float] | None = None,\ny_val: Literal[\"moment\", \"chi\", \"chi_t\"] = \"moment\",\nnormalized: bool = False,\ncolors: str | list[str] = \"auto\",\nlabels: str | list[str] | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plot the ZFC/FC data in the `Magnetometry` object. If `fields` is `None`,\n    all `ZFC` and `FC` objects will be plotted. Otherwise, only the `ZFC` and `FC`\n    objects at the specified fields will be plotted.\n    Parameters\n    ----------\n    fields : float | list[float] | None, optional\n        Default `None`. The fields at which to plot the ZFC/FC data. If `None`, all\n        `ZFC` and `FC` objects will be plotted. Otherwise, only the `ZFC` and `FC`\n        objects at the specified fields will be plotted.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    colors : str | list[str], optional\n        A list of colors corresponding to the `ZFC`/`FC` pairs, by default \"auto\". If\n        \"auto\" and there is a single pair, the color will be black. If \"auto\" and\n        there is a list of pairs with different fields, the colors will be a linear\n        gradient from purple to green. If \"auto\" and the list of pairs is at the same\n        field, the colors will be the default `matplotlib` colors.\n    labels : str | list[str] | None, optional\n        The labels to assign the `ZFC`/`FC` pair in the axes legend, by default \"auto\".\n        If \"auto\", the label will be the `field` of the `MvsH` object.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See `handle_options`\n        for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n        The figure and axes objects of the plot.\n    \"\"\"\nif fields is None:\nreturn plot_zfcfc(\nself.zfc, self.fc, y_val, normalized, colors, labels, title, **kwargs\n)\nzfc = [self.get_zfc(field) for field in fields]\nfc = [self.get_fc(field) for field in fields]\nreturn plot_zfcfc(zfc, fc, y_val, normalized, colors, labels, title, **kwargs)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.create_report","title":"<code>create_report(directory=None, overwrite=False)</code>","text":"<p>Create a JSON report of the <code>Magnetometry</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path | None</code> <p>Default <code>None</code>. The directory to write the report to. If <code>None</code>, the report will be written to the directory containing the .dat files.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Default <code>False</code>. Whether to overwrite the report if it already exists. If <code>False</code> and the report already exists, the user will be prompted to overwrite the report.</p> <code>False</code> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def create_report(\nself, directory: str | Path | None = None, overwrite: bool = False\n) -&gt; None:\n\"\"\"Create a JSON report of the `Magnetometry` object.\n    Parameters\n    ----------\n    directory : str | Path | None, optional\n        Default `None`. The directory to write the report to. If `None`, the report\n        will be written to the directory containing the .dat files.\n    overwrite : bool, optional\n        Default `False`. Whether to overwrite the report if it already exists. If\n        `False` and the report already exists, the user will be prompted to\n        overwrite the report.\n    \"\"\"\nif directory:\ndirectory = Path(directory)\nelse:\ndirectory = self.files[0].local_path.parent\npath = directory / f\"{self.sample_id}.json\"\nif path.exists() and overwrite is False:\nreponse = input(f\"File {path} already exists. Overwrite? [y/N] \")\nif reponse.lower() != \"y\":\nprint(\"Aborting report creation.\")\nreturn\nwith open(path, \"w\", encoding=\"utf-8\") as f:\nf.write(self.as_json(indent=4))\nprint(f\"Report written to {path}\")\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.as_dict","title":"<code>as_dict()</code>","text":"<p>Create a dictionary representation of the <code>Magnetometry</code> object.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Create a dictionary representation of the `Magnetometry` object.\n    Returns\n    -------\n    dict[str, Any]\n    \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"sample_id\": self.sample_id,\n\"files\": self.files,\n\"sample_info\": self.sample_info,\n\"mvsh\": self.mvsh,\n\"zfc\": self.zfc,\n\"fc\": self.fc,\n\"analyses\": self.analyses,\n}\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.as_json","title":"<code>as_json(indent=0)</code>","text":"<p>Create a JSON representation of the <code>Magnetometry</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>Default 0. The number of spaces to indent the JSON.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def as_json(self, indent: int = 0) -&gt; str:\n\"\"\"Create a JSON representation of the `Magnetometry` object.\n    Parameters\n    ----------\n    indent : int, optional\n        Default 0. The number of spaces to indent the JSON.\n    Returns\n    -------\n    str\n    \"\"\"\nreturn json.dumps(self, default=lambda x: x.as_dict(), indent=indent)\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.extract_mvsh","title":"<code>extract_mvsh(eps=0.001, min_samples=10, ndigits=0)</code>","text":"<p>Extracts all M vs. H experiments found within <code>files</code>. This is run during object initialization but is available to the user in the event that the default parsing parameters need to be changed for proper data extraction.</p> <p>See <code>magnetopy.experiments.mvsh.MvsH.get_all_in_file</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <code>0.001</code> <code>min_samples</code> <code>int</code> <code>10</code> <code>ndigits</code> <code>int</code> <code>0</code> <p>Returns:</p> Type Description <code>list[MvsH]</code> <p>The <code>MvsH</code> objects found in <code>files</code>.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def extract_mvsh(\nself, eps: float = 0.001, min_samples: int = 10, ndigits: int = 0\n) -&gt; list[MvsH]:\n\"\"\"Extracts all M vs. H experiments found within `files`. This is run\n    during object initialization but is available to the user in the event that\n    the default parsing parameters need to be changed for proper data extraction.\n    See `magnetopy.experiments.mvsh.MvsH.get_all_in_file` for more information.\n    Parameters\n    ----------\n    eps : float, optional\n    min_samples : int, optional\n    ndigits : int, optional\n    Returns\n    -------\n    list[MvsH]\n        The `MvsH` objects found in `files`.\n    \"\"\"\nmvsh_files = [\ndat_file\nfor dat_file in self.files\nif \"mvsh\" in dat_file.experiments_in_file\n]\nmvsh_objs: list[MvsH] = []\nfor dat_file in mvsh_files:\nmvsh_objs.extend(MvsH.get_all_in_file(dat_file, eps, min_samples, ndigits))\nmvsh_objs.sort(key=lambda x: x.temperature)\nreturn mvsh_objs\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.extract_zfc","title":"<code>extract_zfc(n_digits=0)</code>","text":"<p>Extracts all ZFC experiments found within <code>files</code>. This is run during object initialization but is available to the user in the event that the default parsing parameters need to be changed for proper data extraction.</p> <p>See <code>magnetopy.experiments.zfcfc.ZFC.get_all_in_file</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n_digits</code> <code>int</code> <code>0</code> <p>Returns:</p> Type Description <code>list[ZFC]</code> <p>The <code>ZFC</code> objects found in <code>files</code>.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def extract_zfc(self, n_digits: int = 0) -&gt; list[ZFC]:\n\"\"\"Extracts all ZFC experiments found within `files`. This is run\n    during object initialization but is available to the user in the event that\n    the default parsing parameters need to be changed for proper data extraction.\n    See `magnetopy.experiments.zfcfc.ZFC.get_all_in_file` for more information.\n    Parameters\n    ----------\n    n_digits : int, optional\n    Returns\n    -------\n    list[ZFC]\n        The `ZFC` objects found in `files`.\n    \"\"\"\nzfc_files = [\ndat_file\nfor dat_file in self.files\nif set([\"zfc\", \"zfcfc\"]).intersection(dat_file.experiments_in_file)\n]\nzfc_objs: list[ZFC] = []\nfor dat_file in zfc_files:\nzfc_objs.extend(ZFC.get_all_in_file(dat_file, n_digits))\nzfc_objs.sort(key=lambda x: x.field)\nreturn zfc_objs\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.Magnetometry.extract_fc","title":"<code>extract_fc(n_digits=0)</code>","text":"<p>Extracts all FC experiments found within <code>files</code>. This is run during object initialization but is available to the user in the event that the default parsing parameters need to be changed for proper data extraction.</p> <p>See <code>magnetopy.experiments.zfcfc.FC.get_all_in_file</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n_digits</code> <code>int</code> <p>Default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[FC]</code> <p>The <code>FC</code> objects found in <code>files</code>.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def extract_fc(self, n_digits: int = 0) -&gt; list[FC]:\n\"\"\"Extracts all FC experiments found within `files`. This is run\n    during object initialization but is available to the user in the event that\n    the default parsing parameters need to be changed for proper data extraction.\n    See `magnetopy.experiments.zfcfc.FC.get_all_in_file` for more information.\n    Parameters\n    ----------\n    n_digits : int, optional\n        Default 0\n    Returns\n    -------\n    list[FC]\n        The `FC` objects found in `files`.\n    \"\"\"\nfc_files = [\ndat_file\nfor dat_file in self.files\nif set([\"fc\", \"zfcfc\"]).intersection(dat_file.experiments_in_file)\n]\nfc_objs: list[FC] = []\nfor dat_file in fc_files:\nfc_objs.extend(FC.get_all_in_file(dat_file, n_digits))\nfc_objs.sort(key=lambda x: x.field)\nreturn fc_objs\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.SampleInfo","title":"<code>magnetopy.magnetometry.SampleInfo</code>  <code>dataclass</code>","text":"<p>Information specific to the particular sample used for magnetic measurements.</p> <p>Attributes:</p> Name Type Description <code>material</code> <code>str | None</code> <p>The material used for the sample. Possibly a chemical formula.</p> <code>comment</code> <code>str | None</code> <p>Any comments about the sample.</p> <code>mass</code> <code>float | None</code> <p>The mass of the sample in milligrams.</p> <code>volume</code> <code>float | None</code> <p>The volume of the sample in milliliters or cubic centimeters.</p> <code>molecular_weight</code> <code>float | None</code> <p>The molecular weight of the sample in grams per mole.</p> <code>size</code> <code>float | None</code> <p>The size of the sample in millimeters.</p> <code>shape</code> <code>str | None</code> <p>The shape of the sample.</p> <code>holder</code> <code>str | None</code> <p>The type of sample holder used. Usually \"quartz\", \"straw\", or \"brass\".</p> <code>holder_detail</code> <code>str | None</code> <p>Any additional details about the sample holder.</p> <code>offset</code> <code>float | None</code> <p>The vertical offset of the sample holder in millimeters.</p> <code>eicosane_mass</code> <code>float | None</code> <p>The mass of the eicosane in milligrams.</p> <code>diamagnetic_correction</code> <code>float | None</code> <p>The diamagnetic correction in emu/mol.</p> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>@dataclass\nclass SampleInfo:\n\"\"\"Information specific to the particular sample used for magnetic measurements.\n    Attributes\n    ----------\n    material : str | None\n        The material used for the sample. Possibly a chemical formula.\n    comment : str | None\n        Any comments about the sample.\n    mass : float | None\n        The mass of the sample in milligrams.\n    volume : float | None\n        The volume of the sample in milliliters or cubic centimeters.\n    molecular_weight : float | None\n        The molecular weight of the sample in grams per mole.\n    size : float | None\n        The size of the sample in millimeters.\n    shape : str | None\n        The shape of the sample.\n    holder : str | None\n        The type of sample holder used. Usually \"quartz\", \"straw\", or \"brass\".\n    holder_detail : str | None\n        Any additional details about the sample holder.\n    offset : float | None\n        The vertical offset of the sample holder in millimeters.\n    eicosane_mass : float | None\n        The mass of the eicosane in milligrams.\n    diamagnetic_correction : float | None\n        The diamagnetic correction in emu/mol.\n    \"\"\"\nmaterial: str | None = None\ncomment: str | None = None\nmass: float | None = None\nvolume: float | None = None\nmolecular_weight: float | None = None\nsize: float | None = None\nshape: str | None = None\nholder: str | None = None\nholder_detail: str | None = None\noffset: float | None = None\neicosane_mass: float | None = None\ndiamagnetic_correction: float | None = None\n@classmethod\ndef from_dat_file(\ncls, dat_file: str | Path | DatFile, eicosane_field_hack: bool = True\n) -&gt; SampleInfo:\n\"\"\"\n        Create a SampleInfo object from a .dat file (either a path to the file or a\n        DatFile object). Sample information is extracted from the header of the .dat\n        file.\n        Parameters\n        ----------\n        dat_file : str | Path | DatFile\n            The .dat file to read the sample information from.\n        eicosane_field_hack : bool, optional\n            For abuse of the Quantum Design sample info fields, where the \"volume\" and\n            \"size\" fields are used to store the eicosane mass and diamagnetic\n            correction, respectively. The default is True.\n        Returns\n        -------\n        SampleInfo\n        \"\"\"\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(dat_file)\nsample = cls()\nfor line in dat_file.header:\ncategory = line[0]\nif category != \"INFO\":\ncontinue\nif not line[1]:\ncontinue\ninfo = line[2]\nif info == \"SAMPLE_MATERIAL\":\nsample.material = line[1]\nelif info == \"SAMPLE_COMMENT\":\nsample.comment = line[1]\nelif info == \"SAMPLE_MASS\":\nsample.mass = float(line[1])\nelif info == \"SAMPLE_VOLUME\":\nsample.volume = float(line[1])\nelif info == \"SAMPLE_MOLECULAR_WEIGHT\":\nsample.molecular_weight = float(line[1])\nelif info == \"SAMPLE_SIZE\":\nsample.size = float(line[1])\nelif info == \"SAMPLE_SHAPE\":\nsample.shape = line[1]\nelif info == \"SAMPLE_HOLDER\":\nsample.holder = line[1]\nelif info == \"SAMPLE_HOLDER_DETAIL\":\nsample.holder_detail = line[1]\nelif info == \"SAMPLE_OFFSET\":\nsample.offset = float(line[1])\nif eicosane_field_hack:\nsample.eicosane_mass = sample.volume\nsample.diamagnetic_correction = sample.size\nsample.size, sample.volume = None, None\nreturn sample\ndef as_dict(self) -&gt; dict[str, float | str | None]:\n\"\"\"Create a dictionary representation of the SampleInfo object.\n        Returns\n        -------\n        dict[str, foat | str | None]\n        \"\"\"\noutput = asdict(self)\noutput[\"_class_\"] = self.__class__.__name__\nreturn output\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.SampleInfo.from_dat_file","title":"<code>from_dat_file(dat_file, eicosane_field_hack=True)</code>  <code>classmethod</code>","text":"<p>Create a SampleInfo object from a .dat file (either a path to the file or a DatFile object). Sample information is extracted from the header of the .dat file.</p> <p>Parameters:</p> Name Type Description Default <code>dat_file</code> <code>str | Path | DatFile</code> <p>The .dat file to read the sample information from.</p> required <code>eicosane_field_hack</code> <code>bool</code> <p>For abuse of the Quantum Design sample info fields, where the \"volume\" and \"size\" fields are used to store the eicosane mass and diamagnetic correction, respectively. The default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>SampleInfo</code> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>@classmethod\ndef from_dat_file(\ncls, dat_file: str | Path | DatFile, eicosane_field_hack: bool = True\n) -&gt; SampleInfo:\n\"\"\"\n    Create a SampleInfo object from a .dat file (either a path to the file or a\n    DatFile object). Sample information is extracted from the header of the .dat\n    file.\n    Parameters\n    ----------\n    dat_file : str | Path | DatFile\n        The .dat file to read the sample information from.\n    eicosane_field_hack : bool, optional\n        For abuse of the Quantum Design sample info fields, where the \"volume\" and\n        \"size\" fields are used to store the eicosane mass and diamagnetic\n        correction, respectively. The default is True.\n    Returns\n    -------\n    SampleInfo\n    \"\"\"\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(dat_file)\nsample = cls()\nfor line in dat_file.header:\ncategory = line[0]\nif category != \"INFO\":\ncontinue\nif not line[1]:\ncontinue\ninfo = line[2]\nif info == \"SAMPLE_MATERIAL\":\nsample.material = line[1]\nelif info == \"SAMPLE_COMMENT\":\nsample.comment = line[1]\nelif info == \"SAMPLE_MASS\":\nsample.mass = float(line[1])\nelif info == \"SAMPLE_VOLUME\":\nsample.volume = float(line[1])\nelif info == \"SAMPLE_MOLECULAR_WEIGHT\":\nsample.molecular_weight = float(line[1])\nelif info == \"SAMPLE_SIZE\":\nsample.size = float(line[1])\nelif info == \"SAMPLE_SHAPE\":\nsample.shape = line[1]\nelif info == \"SAMPLE_HOLDER\":\nsample.holder = line[1]\nelif info == \"SAMPLE_HOLDER_DETAIL\":\nsample.holder_detail = line[1]\nelif info == \"SAMPLE_OFFSET\":\nsample.offset = float(line[1])\nif eicosane_field_hack:\nsample.eicosane_mass = sample.volume\nsample.diamagnetic_correction = sample.size\nsample.size, sample.volume = None, None\nreturn sample\n</code></pre>"},{"location":"api/magnetometry/#magnetopy.magnetometry.SampleInfo.as_dict","title":"<code>as_dict()</code>","text":"<p>Create a dictionary representation of the SampleInfo object.</p> <p>Returns:</p> Type Description <code>dict[str, foat | str | None]</code> Source code in <code>magnetopy\\magnetometry.py</code> <pre><code>def as_dict(self) -&gt; dict[str, float | str | None]:\n\"\"\"Create a dictionary representation of the SampleInfo object.\n    Returns\n    -------\n    dict[str, foat | str | None]\n    \"\"\"\noutput = asdict(self)\noutput[\"_class_\"] = self.__class__.__name__\nreturn output\n</code></pre>"},{"location":"api/mvsh/","title":"MvsH","text":""},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH","title":"<code>magnetopy.experiments.mvsh.MvsH</code>","text":"<p>A single magnetization vs. field (hysteresis) experiment at a single temperature.</p> <p>Parameters:</p> Name Type Description Default <code>dat_file</code> <code>str, Path, or DatFile</code> <p>The .dat file containing the data for the experiment.</p> required <code>temperature</code> <code>int or float</code> <p>The temperature of the experiment in Kelvin. Requied if the .dat file contains multiple uncommented experiments at different temperatures. If <code>None</code> and the .dat file contains a single experiment, the temperature will be automatically detected. Defaults to <code>None</code>.</p> <code>None</code> <code>parse_raw</code> <code>bool</code> <p>If <code>True</code> and there is a corresponding .rw.dat file, the raw data will be parsed and added to the <code>data</code> attribute. Defaults to <code>False</code>.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments used for algorithmic separation of data at the requested temperature. See <code>magnetopy.parsing_utils.label_clusters</code> for details.</p> <ul> <li> <p>eps : float, optional</p> </li> <li> <p>min_samples : int, optional</p> </li> <li> <p>n_digits : int, optional</p> </li> </ul> <code>{}</code> <p>Attributes:</p> Name Type Description <code>origin_file</code> <code>str</code> <p>The name of the .dat file from which the data was parsed.</p> <code>temperature</code> <code>float</code> <p>The temperature of the experiment in Kelvin.</p> <code>data</code> <code>pandas.DataFrame</code> <p>The data from the experiment. Columns are taken directly from the .dat file.</p> <code>field_correction_file</code> <code>str</code> <p>The name of the .dat file containing the Pd standard sequence used to correct the magnetic field for flux trapping. If no field correction has been applied, this will be an empty string.</p> <code>scaling</code> <code>list of str</code> <p>The scaling applied to the data. If no scaling has been applied, this will be an empty list. Possible values are: <code>\"mass\"</code>, <code>\"molar\"</code>, <code>\"eicosane\"</code>, and <code>\"diamagnetic_correction\"</code>.</p> <code>field_range</code> <code>tuple of float</code> <p>The minimum and maximum field values in the data.</p> <p>Raises:</p> Type Description <code>self.TemperatureNotInDataError</code> <p>If the requested temperature is not in the data or the comments are not formatted correctly and the temperature cannot be automatically detected.</p> <code>self.FieldCorrectionError</code> <p>If a field correction is applied but the Pd standard sequence does not have the same number of data points as the MvsH sequence.</p> <code>self.SegmentError</code> <p>If the requested segment is not found in the data.</p> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>class MvsH:\n\"\"\"A single magnetization vs. field (hysteresis) experiment at a single temperature.\n    Parameters\n    ----------\n    dat_file : str, Path, or DatFile\n        The .dat file containing the data for the experiment.\n    temperature : int or float, optional\n        The temperature of the experiment in Kelvin. Requied if the .dat file contains\n        multiple uncommented experiments at different temperatures. If `None` and the\n        .dat file contains a single experiment, the temperature will be automatically\n        detected. Defaults to `None`.\n    parse_raw : bool, optional\n        If `True` and there is a corresponding .rw.dat file, the raw data will be\n        parsed and added to the `data` attribute. Defaults to `False`.\n    **kwargs : dict, optional\n        Keyword arguments used for algorithmic separation of data at the requested\n        temperature. See `magnetopy.parsing_utils.label_clusters` for details.\n        - eps : float, optional\n        - min_samples : int, optional\n        - n_digits : int, optional\n    Attributes\n    ----------\n    origin_file : str\n        The name of the .dat file from which the data was parsed.\n    temperature : float\n        The temperature of the experiment in Kelvin.\n    data : pandas.DataFrame\n        The data from the experiment. Columns are taken directly from the .dat file.\n    field_correction_file : str\n        The name of the .dat file containing the Pd standard sequence used to correct\n        the magnetic field for flux trapping. If no field correction has been applied,\n        this will be an empty string.\n    scaling : list of str\n        The scaling applied to the data. If no scaling has been applied, this will be\n        an empty list. Possible values are: `\"mass\"`, `\"molar\"`, `\"eicosane\"`,\n        and `\"diamagnetic_correction\"`.\n    field_range : tuple of float\n        The minimum and maximum field values in the data.\n    Raises\n    ------\n    self.TemperatureNotInDataError\n        If the requested temperature is not in the data or the comments are not\n        formatted correctly and the temperature cannot be automatically detected.\n    self.FieldCorrectionError\n        If a field correction is applied but the Pd standard sequence does not have the\n        same number of data points as the MvsH sequence.\n    self.SegmentError\n        If the requested segment is not found in the data.\n    \"\"\"\nclass TemperatureNotInDataError(Exception):\npass\nclass SegmentError(Exception):\npass\nclass FieldCorrectionError(Exception):\npass\ndef __init__(\nself,\ndat_file: str | Path | DatFile,\ntemperature: int | float | None = None,\nparse_raw: bool = False,\n**kwargs,\n) -&gt; None:\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(Path(dat_file), parse_raw)\nself.origin_file = dat_file.local_path.name\n# optional arguments used for algorithmic separation of\n# data at the requested temperature\nn_digits = num_digits_after_decimal(temperature) if temperature else 0\noptions = {\"eps\": 0.001, \"min_samples\": 10, \"n_digits\": n_digits}\noptions.update(kwargs)\nif temperature is None:\ntemperature = _auto_detect_temperature(\ndat_file, options[\"eps\"], options[\"min_samples\"], options[\"n_digits\"]\n)\nself.temperature = temperature\nif dat_file.comments:\nself.data = self._set_data_from_comments(dat_file)\nelse:\nself.data = self._set_data_auto(\ndat_file, options[\"eps\"], options[\"min_samples\"], options[\"n_digits\"]\n)\nadd_uncorrected_moment_columns(self)\nself.field_correction_file = \"\"\nself.scaling: list[str] = []\nself.field_range = self._determine_field_range()\nself._field_fluctuation_tolerance = 1\ndef __str__(self) -&gt; str:\nreturn f\"MvsH at {self.temperature} K\"\ndef __repr__(self) -&gt; str:\nreturn f\"MvsH at {self.temperature} K\"\ndef _set_data_from_comments(self, dat_file: DatFile) -&gt; pd.DataFrame:\nstart_idx: int | None = None\nend_idx: int | None = None\nfor comment_idx, (data_idx, comment_list) in enumerate(\ndat_file.comments.items()\n):\n# ignore other experiments\nif \"mvsh\" not in map(str.lower, comment_list):\ncontinue\n# one of the comments should be a number denoting the temperature\n# may also include a unit, e.g. \"300 K\"\nfor comment in comment_list:\nif match := re.search(r\"\\d+\", comment):\nfound_temp = float(match.group())\n# check to see if the unit is C otherwise assume K\nif \"C\" in comment:\nfound_temp += 273\nif found_temp == self.temperature:\nstart_idx = (\ndata_idx + 1\n)  # +1 to skip the line containing the comment\nend_idx = (\nlist(dat_file.comments.keys())[comment_idx + 1]\nif comment_idx + 1 &lt; len(dat_file.comments)\nelse (len(dat_file.data))\n)\nbreak\nif start_idx is not None:\nbreak\nelse:\nraise self.TemperatureNotInDataError(\nf\"Temperature {self.temperature} not in data in {dat_file}. \"\n\"Or the comments are not formatted correctly.\"\n)\ndf = dat_file.data.iloc[start_idx:end_idx].reset_index(drop=True)\nreturn df\ndef _set_data_auto(\nself, dat_file: DatFile, eps: float, min_samples: int, ndigits: int\n) -&gt; pd.DataFrame:\nfile_data = dat_file.data.copy()\nfile_data[\"cluster\"] = label_clusters(\nfile_data[\"Temperature (K)\"], eps, min_samples\n)\ntemps = unique_values(file_data[\"Temperature (K)\"], eps, min_samples, ndigits)\nif self.temperature not in temps:\nraise self.TemperatureNotInDataError(\nf\"Temperature {self.temperature} not in data in {dat_file}.\"\n)\ntemperature_index = temps.index(self.temperature)\ncluster = file_data[\"cluster\"].unique()[temperature_index]\ndf = (\nfile_data[file_data[\"cluster\"] == cluster]\n.drop(columns=[\"cluster\"])\n.reset_index(drop=True)\n)\nfile_data.drop(columns=[\"cluster\"], inplace=True)\nreturn df\ndef simplified_data(\nself, segment: Literal[\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"] = \"\"\n) -&gt; pd.DataFrame:\n\"\"\"Returns a simplified version of the data, removing unnecessary columns\n        and renaming the remaining columns to more convenient names.\n        Parameters\n        ----------\n        segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n            Return the selected segment. By default \"\", which returns the full data.\n        Returns\n        -------\n        pd.DataFrame\n            The simplified data. Contains the columns:\n            - `\"time\"` in seconds\n            - `\"temperature\"` in Kelvin\n            - `\"field\"` in Oe\n            - `\"moment\"`\n            - `\"moment_err\"`\n            - `\"chi\"`\n            - `\"chi_err\"`\n            - `\"chi_t\"`\n            - `\"chi_t_err\"`\n            Where units are not specified, they are determined by the scaling applied to the\n            data (see `scaling` attribute).\n        \"\"\"\nfull_df = self.select_segment(segment) if segment else self.data.copy()\ndf = pd.DataFrame()\ndf[\"time\"] = full_df[\"Time Stamp (sec)\"]\ndf[\"temperature\"] = full_df[\"Temperature (K)\"]\nif self.field_correction_file:\ndf[\"field\"] = full_df[\"true_field\"]\nelse:\ndf[\"field\"] = full_df[\"Magnetic Field (Oe)\"]\nif self.scaling:\ndf[\"moment\"] = full_df[\"moment\"]\ndf[\"moment_err\"] = full_df[\"moment_err\"]\ndf[\"chi\"] = full_df[\"chi\"]\ndf[\"chi_err\"] = full_df[\"chi_err\"]\ndf[\"chi_t\"] = full_df[\"chi_t\"]\ndf[\"chi_t_err\"] = full_df[\"chi_t_err\"]\nelse:\ndf[\"moment\"] = full_df[\"uncorrected_moment\"]\ndf[\"moment_err\"] = full_df[\"uncorrected_moment_err\"]\ndf[\"chi\"] = df[\"moment\"] / df[\"field\"]\ndf[\"chi_err\"] = df[\"moment_err\"] / df[\"field\"]\ndf[\"chi_t\"] = df[\"chi\"] * df[\"temperature\"]\ndf[\"chi_t_err\"] = df[\"chi_err\"] * df[\"temperature\"]\nreturn df\ndef scale_moment(\nself,\nmass: float = 0,\neicosane_mass: float = 0,\nmolecular_weight: float = 0,\ndiamagnetic_correction: float = 0,\n) -&gt; None:\n\"\"\"Adds the following columns to the `DataFrame` in the `data` attribute:\n        `\"moment\"`, `\"moment_err\"`, `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and\n        `\"chi_t_err\"`. A record of what scaling was applied is added to the\n        `scaling` attribute.\n        See `magnetopy.experiments.utils.scale_dc_data` for more information.\n        Parameters\n        ----------\n        mass : float, optional\n            mg of sample, by default 0.\n        eicosane_mass : float, optional\n            mg of eicosane, by default 0.\n        molecular_weight : float, optional\n            Molecular weight of the material in g/mol, by default 0.\n        diamagnetic_correction : float, optional\n            Diamagnetic correction of the material in cm^3/mol, by default 0.\n        \"\"\"\nscale_dc_data(\nself,\nmass,\neicosane_mass,\nmolecular_weight,\ndiamagnetic_correction,\n)\ndef correct_field(self, field_correction_file: str | Path) -&gt; None:\n\"\"\"Applies a field correction to the data given data collected on the palladium\n        standard with the same sequence as the current `MvsH` object. Adds a column\n        called `\"true_field\"` to the `DataFrame` in the `data` attribute.\n        See `magnetopy.cli.calibration_insall` for information on how to create a\n        calibration directory.\n        Parameters\n        ----------\n        field_correction_file : str | Path\n            The name of the .dat file containing the Pd standard sequence, or if a\n            configuration file containing calibration data is present, the name of the\n            sequence in the configuration file.\n        Raises\n        ------\n        self.FieldCorrectionError\n            The true field calibration requires that the sequences of both the\n            M vs. H experiment and the calibration experiment be exactly the same. This\n            function only checks that they are the same length, and if they are not,\n            raises this error.\n        Notes\n        -----\n        As described in the Quantum Design application note[1], the magnetic field\n        reported by the magnetometer is determined by current from the magnet power\n        supply and not by direct measurement. Flux trapping in the magnet can cause\n        the reported field to be different from the actual field. While always present,\n        it is most obvious in hysteresis curves of soft, non-hysteretic materials. In\n        some cases the forward and reverse scans can have negative and postive\n        coercivities, respectively, which is not physically possible.\n        The true field correction remedies this by using a Pd standard to determine the\n        actual field applied to the sample. Assuming the calibration and sample\n        sequences are the same, it is assumed that the flux trapping is the same for\n        both sequences, and the calculated field from the measurement on the Pd\n        standard is applied to the sample data.\n        References\n        ----------\n        [1] [Correcting for the Absolute Field Error using the Pd Standard](https://qdusa.com/siteDocs/appNotes/1500-021.pdf)\n        \"\"\"\npd_mvsh = TrueFieldCorrection(field_correction_file)\nif len(pd_mvsh.data) != len(self.data):\nraise self.FieldCorrectionError(\n\"The given Pd standard sequence does not have the same number of data \"\n\"points as the MvsH sequence.\"\n)\nself.field_correction_file = pd_mvsh.origin_file\nself.data[\"true_field\"] = pd_mvsh.data[\"true_field\"]\nself.field_range = self._determine_field_range()\ndef _determine_field_range(self) -&gt; tuple[float, float]:\nsimplified_data = self.simplified_data()\nreturn simplified_data[\"field\"].min(), simplified_data[\"field\"].max()\n@property\ndef virgin(self) -&gt; pd.DataFrame:\nreturn self.select_segment(\"virgin\")\n@property\ndef forward(self) -&gt; pd.DataFrame:\nreturn self.select_segment(\"forward\")\n@property\ndef reverse(self) -&gt; pd.DataFrame:\nreturn self.select_segment(\"reverse\")\n@property\ndef loop(self) -&gt; pd.DataFrame:\nreturn self.select_segment(\"loop\")\ndef select_segment(\nself, segment: Literal[\"virgin\", \"forward\", \"reverse\", \"loop\"]\n) -&gt; pd.DataFrame:\n\"\"\"Returns the requested segment of the data, if it exists.\n        Parameters\n        ----------\n        segment : {\"virgin\", \"forward\", \"reverse\", \"loop\"}\n            The segment of the M vs. H data to return. \"loop\" refers to the combination\n            of the forward and reverse scans.\n        Returns\n        -------\n        pd.DataFrame\n            The requested segment of the data.\n        Raises\n        ------\n        self.SegmentError\n            If the requested segment is not found in the data.\n        \"\"\"\nsegment_starts = find_sequence_starts(\nself.data[\"Magnetic Field (Oe)\"], self._field_fluctuation_tolerance\n)\ndf = self.data.copy()\nrequested_segment = None\nif len(segment_starts) == 3:\n# assume virgin -&gt; reverse -&gt; forward\nif segment == \"virgin\":\nrequested_segment = df[\nsegment_starts[0] : segment_starts[1]\n].reset_index(drop=True)\nelif segment == \"reverse\":\nrequested_segment = df[\nsegment_starts[1] - 1 : segment_starts[2]\n].reset_index(drop=True)\nelif segment == \"forward\":\nrequested_segment = df[segment_starts[2] - 1 :].reset_index(drop=True)\nelif segment == \"loop\":\nrequested_segment = df[segment_starts[1] - 1 :].reset_index(drop=True)\nelif len(segment_starts) == 2:\nif segment == \"loop\":\nrequested_segment = df\n# check to see if it's forward -&gt; reverse or reverse -&gt; forward\nelif (\ndf.at[segment_starts[0], \"Magnetic Field (Oe)\"]\n&gt; df.at[segment_starts[1], \"Magnetic Field (Oe)\"]\n):\nif segment == \"reverse\":\nrequested_segment = df[\nsegment_starts[0] : segment_starts[1]\n].reset_index(drop=True)\nelif segment == \"forward\":\nrequested_segment = df[segment_starts[1] - 1 :].reset_index(\ndrop=True\n)\nelse:\nif segment == \"forward\":\nrequested_segment = df[\nsegment_starts[0] : segment_starts[1]\n].reset_index(drop=True)\nelif segment == \"reverse\":\nrequested_segment = df[segment_starts[1] - 1 :].reset_index(\ndrop=True\n)\nelif len(segment_starts) == 1:\nif segment == \"loop\":\nraise self.SegmentError(\n\"Full loop requested but only one segment found\"\n)\nelif segment == \"virgin\":\nif abs(df.at[0, \"Magnetic Field (Oe)\"]) &gt; 5:\nraise self.SegmentError(\n\"Virgin scan requested but data does not start at zero field\"\n)\nrequested_segment = df\nelif segment == \"forward\":\nif df.at[0, \"Magnetic Field (Oe)\"] &gt; 0:\nraise self.SegmentError(\n\"Forward scan requested but start field is greater than end field.\"\n)\nrequested_segment = df\nelif segment == \"reverse\":\nif df.at[0, \"Magnetic Field (Oe)\"] &lt; 0:\nraise self.SegmentError(\n\"Reverse scan requested but start field is less than end field.\"\n)\nrequested_segment = df\nelse:\nraise self.SegmentError(\nf\"Something went wrong. {len(segment_starts)} segments found\"\n)\nif requested_segment is None:\nraise self.SegmentError(f\"Sequence {segment} not found in data\")\nreturn requested_segment\ndef plot(\nself,\nnormalized: bool = False,\nsegment: str = \"\",\ncolor: str = \"black\",\nlabel: str | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the M vs. H data data.\n        Parameters\n        ----------\n        normalized : bool, optional\n            If `True`, the magnetization will be normalized to the maximum value, by\n            default False.\n        segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n            If a segment is given, only that segment will be plotted, by default \"\".\n        color : str | list[str], optional\n            The color of the plot, by default \"auto\". If \"auto\", the color will be black.\n        label : str | list[str] | None, optional\n            The labels to assign the `MvsH` object in the axes legend, by default \"auto\".\n            If \"auto\", the label will be the `temperature` of the `MvsH` object.\n        title : str, optional\n            The title of the plot, by default \"\".\n        **kwargs\n            Keyword arguments mostly meant to affect the plot style. See\n            `magnetopy.experiments.plot_utils.handle_options` for details.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n        \"\"\"\nreturn plot_single_mvsh(\nself, normalized, segment, color, label, title, **kwargs\n)\ndef plot_raw(\nself,\nsegment: Literal[\"virgin\", \"forward\", \"reverse\"] = \"forward\",\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"processed\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"purple\", \"orange\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the raw voltage data for the requested segment.\n        Parameters\n        ----------\n        segment : {\"virgin\", \"forward\", \"reverse\"}, optional\n            The segment of the M vs. H data to plot, by default \"forward\"\n        scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"procssed\"], optional\n            Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n            scans (which have been adjusted for drift and shifted to center the waveform\n            around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the raw\n            voltages as the come straight off the SQUID, and `\"processed\"` will plot the\n            processed data (which is the result of fitting the up and down scans). `\"up\"` by\n            default.\n        center : Literal[\"free\", \"fixed\"], optional\n            Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n            Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n        colors : tuple[str, str], optional\n            The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n            default.\n        label : bool, optional\n            Default `True`. Whether to put labels on the plot for the initial and final\n            scans.\n        title : str, optional\n            The title of the plot. `\"\"` by default.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n        \"\"\"\nreturn plot_raw(\nself.select_segment(segment), None, scan, center, colors, label, title\n)\ndef plot_raw_residual(\nself,\nsegment: Literal[\"virgin\", \"forward\", \"reverse\"] = \"forward\",\nscan: Literal[\"up\", \"down\"] = \"up\",\ncenter: Literal[\"free\", \"fixed\"] = \"free\",\ncolors: tuple[str, str] | None = None,\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the residual of the raw voltage data for the requested segment.\n        Parameters\n        ----------\n        segment : {\"virgin\", \"forward\", \"reverse\"}, optional\n            The segment of the M vs. H data to plot, by default \"forward\"\n        scan : Literal[\"up\", \"down\"], optional\n            Which data to use in the residual calculation. `\"up\"` and `\"down\"` will use the\n            processed directional scans (which have been adjusted for drift and shifted to\n            center the waveform around 0, but have not been fit). `\"up\"` by default.\n        center : Literal[\"free\", \"fixed\"], optional\n            Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n            Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n        colors : tuple[str, str], optional\n            The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n            default.\n        label : bool, optional\n            Default `True`. Whether to put labels on the plot for the initial and final\n            scans.\n        title : str, optional\n            The title of the plot. `\"\"` by default.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n        \"\"\"\nreturn plot_raw_residual(\nself.select_segment(segment), None, scan, center, colors, label, title\n)\ndef as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Returns a dictionary representation of the `MvsH` object.\n        Returns\n        -------\n        dict[str, Any]\n            Keys are: `\"origin_file\"`, `\"temperature\"`, `\"field_range\"`,\n            `\"field_correction_file\"`, and `\"scaling\"`.\n        \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"origin_file\": self.origin_file,\n\"temperature\": self.temperature,\n\"field_range\": self.field_range,\n\"field_correction_file\": self.field_correction_file,\n\"scaling\": self.scaling,\n}\n@classmethod\ndef get_all_in_file(\ncls,\ndat_file: str | Path | DatFile,\neps: float = 0.001,\nmin_samples: int = 10,\nndigits: int = 0,\nparse_raw: bool = False,\n) -&gt; list[MvsH]:\n\"\"\"Given a .dat file that contains one or more M vs. H experiments, returns a\n        list of `MvsH` objects, one for each experiment.\n        Parameters\n        ----------\n        dat_file : str | Path | DatFile\n            The .dat file containing the data for the experiment.\n        eps : float, optional\n            See `magnetopy.parsing_utils.label_clusters` for details, by default 0.001\n        min_samples : int, optional\n            See `magnetopy.parsing_utils.label_clusters` for details, by default 10\n        ndigits : int, optional\n            See `magnetopy.parsing_utils.label_clusters` for details, by default 0\n        parse_raw : bool, optional\n            If `True` and there is a corresponding .rw.dat file, the raw data will be\n            parsed and added to the `data` attribute. Defaults to `False`.\n        Returns\n        -------\n        list[MvsH]\n            A list of `MvsH` objects, one for each experiment in the .dat file, sorted\n            by increasing temperature.\n        \"\"\"\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(Path(dat_file), parse_raw)\nif dat_file.comments:\nmvsh_objs = cls._get_all_mvsh_in_commented_file(dat_file)\nelse:\nmvsh_objs = cls._get_all_mvsh_in_uncommented_file(\ndat_file,\neps,\nmin_samples,\nndigits,\n)\nmvsh_objs.sort(key=lambda x: x.temperature)\nreturn mvsh_objs\n@classmethod\ndef _get_all_mvsh_in_commented_file(cls, dat_file: DatFile) -&gt; list[MvsH]:\nmvsh_objs = []\nfor comment_list in dat_file.comments.values():\n# ignore other experiments\nif \"mvsh\" not in map(str.lower, comment_list):\ncontinue\n# one of the comments should be a number denoting the temperature\n# may also include a unit, e.g. \"300 K\"\nfor comment in comment_list:\nif match := re.search(r\"\\d+\", comment):\ntemp = float(match.group())\n# check to see if the unit is C otherwise assume K\nif \"C\" in comment:\ntemp += 273\nmvsh_objs.append(cls(dat_file, temp))\nreturn mvsh_objs\n@classmethod\ndef _get_all_mvsh_in_uncommented_file(\ncls,\ndat_file: DatFile,\neps: float,\nmin_samples: int,\nndigits: int,\n) -&gt; list[MvsH]:\nfile_data = dat_file.data\nfile_data[\"cluster\"] = label_clusters(\nfile_data[\"Temperature (K)\"], eps, min_samples\n)\ntemps = unique_values(file_data[\"Temperature (K)\"], eps, min_samples, ndigits)\nmvsh_objs = []\nfor temp in temps:\nmvsh_objs.append(cls(dat_file, temp, eps=eps, min_samples=min_samples))\nreturn mvsh_objs\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.simplified_data","title":"<code>simplified_data(segment='')</code>","text":"<p>Returns a simplified version of the data, removing unnecessary columns and renaming the remaining columns to more convenient names.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Literal['', 'virgin', 'forward', 'reverse', 'loop']</code> <p>Return the selected segment. By default \"\", which returns the full data.</p> <code>\"\"</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>The simplified data. Contains the columns: - <code>\"time\"</code> in seconds - <code>\"temperature\"</code> in Kelvin - <code>\"field\"</code> in Oe - <code>\"moment\"</code> - <code>\"moment_err\"</code> - <code>\"chi\"</code> - <code>\"chi_err\"</code> - <code>\"chi_t\"</code> - <code>\"chi_t_err\"</code></p> <p>Where units are not specified, they are determined by the scaling applied to the data (see <code>scaling</code> attribute).</p> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def simplified_data(\nself, segment: Literal[\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"] = \"\"\n) -&gt; pd.DataFrame:\n\"\"\"Returns a simplified version of the data, removing unnecessary columns\n    and renaming the remaining columns to more convenient names.\n    Parameters\n    ----------\n    segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n        Return the selected segment. By default \"\", which returns the full data.\n    Returns\n    -------\n    pd.DataFrame\n        The simplified data. Contains the columns:\n        - `\"time\"` in seconds\n        - `\"temperature\"` in Kelvin\n        - `\"field\"` in Oe\n        - `\"moment\"`\n        - `\"moment_err\"`\n        - `\"chi\"`\n        - `\"chi_err\"`\n        - `\"chi_t\"`\n        - `\"chi_t_err\"`\n        Where units are not specified, they are determined by the scaling applied to the\n        data (see `scaling` attribute).\n    \"\"\"\nfull_df = self.select_segment(segment) if segment else self.data.copy()\ndf = pd.DataFrame()\ndf[\"time\"] = full_df[\"Time Stamp (sec)\"]\ndf[\"temperature\"] = full_df[\"Temperature (K)\"]\nif self.field_correction_file:\ndf[\"field\"] = full_df[\"true_field\"]\nelse:\ndf[\"field\"] = full_df[\"Magnetic Field (Oe)\"]\nif self.scaling:\ndf[\"moment\"] = full_df[\"moment\"]\ndf[\"moment_err\"] = full_df[\"moment_err\"]\ndf[\"chi\"] = full_df[\"chi\"]\ndf[\"chi_err\"] = full_df[\"chi_err\"]\ndf[\"chi_t\"] = full_df[\"chi_t\"]\ndf[\"chi_t_err\"] = full_df[\"chi_t_err\"]\nelse:\ndf[\"moment\"] = full_df[\"uncorrected_moment\"]\ndf[\"moment_err\"] = full_df[\"uncorrected_moment_err\"]\ndf[\"chi\"] = df[\"moment\"] / df[\"field\"]\ndf[\"chi_err\"] = df[\"moment_err\"] / df[\"field\"]\ndf[\"chi_t\"] = df[\"chi\"] * df[\"temperature\"]\ndf[\"chi_t_err\"] = df[\"chi_err\"] * df[\"temperature\"]\nreturn df\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.scale_moment","title":"<code>scale_moment(mass=0, eicosane_mass=0, molecular_weight=0, diamagnetic_correction=0)</code>","text":"<p>Adds the following columns to the <code>DataFrame</code> in the <code>data</code> attribute: <code>\"moment\"</code>, <code>\"moment_err\"</code>, <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, and <code>\"chi_t_err\"</code>. A record of what scaling was applied is added to the <code>scaling</code> attribute.</p> <p>See <code>magnetopy.experiments.utils.scale_dc_data</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>mass</code> <code>float</code> <p>mg of sample, by default 0.</p> <code>0</code> <code>eicosane_mass</code> <code>float</code> <p>mg of eicosane, by default 0.</p> <code>0</code> <code>molecular_weight</code> <code>float</code> <p>Molecular weight of the material in g/mol, by default 0.</p> <code>0</code> <code>diamagnetic_correction</code> <code>float</code> <p>Diamagnetic correction of the material in cm^3/mol, by default 0.</p> <code>0</code> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def scale_moment(\nself,\nmass: float = 0,\neicosane_mass: float = 0,\nmolecular_weight: float = 0,\ndiamagnetic_correction: float = 0,\n) -&gt; None:\n\"\"\"Adds the following columns to the `DataFrame` in the `data` attribute:\n    `\"moment\"`, `\"moment_err\"`, `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and\n    `\"chi_t_err\"`. A record of what scaling was applied is added to the\n    `scaling` attribute.\n    See `magnetopy.experiments.utils.scale_dc_data` for more information.\n    Parameters\n    ----------\n    mass : float, optional\n        mg of sample, by default 0.\n    eicosane_mass : float, optional\n        mg of eicosane, by default 0.\n    molecular_weight : float, optional\n        Molecular weight of the material in g/mol, by default 0.\n    diamagnetic_correction : float, optional\n        Diamagnetic correction of the material in cm^3/mol, by default 0.\n    \"\"\"\nscale_dc_data(\nself,\nmass,\neicosane_mass,\nmolecular_weight,\ndiamagnetic_correction,\n)\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.correct_field","title":"<code>correct_field(field_correction_file)</code>","text":"<p>Applies a field correction to the data given data collected on the palladium standard with the same sequence as the current <code>MvsH</code> object. Adds a column called <code>\"true_field\"</code> to the <code>DataFrame</code> in the <code>data</code> attribute.</p> <p>See <code>magnetopy.cli.calibration_insall</code> for information on how to create a calibration directory.</p> <p>Parameters:</p> Name Type Description Default <code>field_correction_file</code> <code>str | Path</code> <p>The name of the .dat file containing the Pd standard sequence, or if a configuration file containing calibration data is present, the name of the sequence in the configuration file.</p> required <p>Raises:</p> Type Description <code>self.FieldCorrectionError</code> <p>The true field calibration requires that the sequences of both the M vs. H experiment and the calibration experiment be exactly the same. This function only checks that they are the same length, and if they are not, raises this error.</p>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.correct_field--notes","title":"Notes","text":"<p>As described in the Quantum Design application note[1], the magnetic field reported by the magnetometer is determined by current from the magnet power supply and not by direct measurement. Flux trapping in the magnet can cause the reported field to be different from the actual field. While always present, it is most obvious in hysteresis curves of soft, non-hysteretic materials. In some cases the forward and reverse scans can have negative and postive coercivities, respectively, which is not physically possible.</p> <p>The true field correction remedies this by using a Pd standard to determine the actual field applied to the sample. Assuming the calibration and sample sequences are the same, it is assumed that the flux trapping is the same for both sequences, and the calculated field from the measurement on the Pd standard is applied to the sample data.</p>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.correct_field--references","title":"References","text":"<p>[1] Correcting for the Absolute Field Error using the Pd Standard</p> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def correct_field(self, field_correction_file: str | Path) -&gt; None:\n\"\"\"Applies a field correction to the data given data collected on the palladium\n    standard with the same sequence as the current `MvsH` object. Adds a column\n    called `\"true_field\"` to the `DataFrame` in the `data` attribute.\n    See `magnetopy.cli.calibration_insall` for information on how to create a\n    calibration directory.\n    Parameters\n    ----------\n    field_correction_file : str | Path\n        The name of the .dat file containing the Pd standard sequence, or if a\n        configuration file containing calibration data is present, the name of the\n        sequence in the configuration file.\n    Raises\n    ------\n    self.FieldCorrectionError\n        The true field calibration requires that the sequences of both the\n        M vs. H experiment and the calibration experiment be exactly the same. This\n        function only checks that they are the same length, and if they are not,\n        raises this error.\n    Notes\n    -----\n    As described in the Quantum Design application note[1], the magnetic field\n    reported by the magnetometer is determined by current from the magnet power\n    supply and not by direct measurement. Flux trapping in the magnet can cause\n    the reported field to be different from the actual field. While always present,\n    it is most obvious in hysteresis curves of soft, non-hysteretic materials. In\n    some cases the forward and reverse scans can have negative and postive\n    coercivities, respectively, which is not physically possible.\n    The true field correction remedies this by using a Pd standard to determine the\n    actual field applied to the sample. Assuming the calibration and sample\n    sequences are the same, it is assumed that the flux trapping is the same for\n    both sequences, and the calculated field from the measurement on the Pd\n    standard is applied to the sample data.\n    References\n    ----------\n    [1] [Correcting for the Absolute Field Error using the Pd Standard](https://qdusa.com/siteDocs/appNotes/1500-021.pdf)\n    \"\"\"\npd_mvsh = TrueFieldCorrection(field_correction_file)\nif len(pd_mvsh.data) != len(self.data):\nraise self.FieldCorrectionError(\n\"The given Pd standard sequence does not have the same number of data \"\n\"points as the MvsH sequence.\"\n)\nself.field_correction_file = pd_mvsh.origin_file\nself.data[\"true_field\"] = pd_mvsh.data[\"true_field\"]\nself.field_range = self._determine_field_range()\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.select_segment","title":"<code>select_segment(segment)</code>","text":"<p>Returns the requested segment of the data, if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Literal['virgin', 'forward', 'reverse', 'loop']</code> <p>The segment of the M vs. H data to return. \"loop\" refers to the combination of the forward and reverse scans.</p> <code>\"virgin\"</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>The requested segment of the data.</p> <p>Raises:</p> Type Description <code>self.SegmentError</code> <p>If the requested segment is not found in the data.</p> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def select_segment(\nself, segment: Literal[\"virgin\", \"forward\", \"reverse\", \"loop\"]\n) -&gt; pd.DataFrame:\n\"\"\"Returns the requested segment of the data, if it exists.\n    Parameters\n    ----------\n    segment : {\"virgin\", \"forward\", \"reverse\", \"loop\"}\n        The segment of the M vs. H data to return. \"loop\" refers to the combination\n        of the forward and reverse scans.\n    Returns\n    -------\n    pd.DataFrame\n        The requested segment of the data.\n    Raises\n    ------\n    self.SegmentError\n        If the requested segment is not found in the data.\n    \"\"\"\nsegment_starts = find_sequence_starts(\nself.data[\"Magnetic Field (Oe)\"], self._field_fluctuation_tolerance\n)\ndf = self.data.copy()\nrequested_segment = None\nif len(segment_starts) == 3:\n# assume virgin -&gt; reverse -&gt; forward\nif segment == \"virgin\":\nrequested_segment = df[\nsegment_starts[0] : segment_starts[1]\n].reset_index(drop=True)\nelif segment == \"reverse\":\nrequested_segment = df[\nsegment_starts[1] - 1 : segment_starts[2]\n].reset_index(drop=True)\nelif segment == \"forward\":\nrequested_segment = df[segment_starts[2] - 1 :].reset_index(drop=True)\nelif segment == \"loop\":\nrequested_segment = df[segment_starts[1] - 1 :].reset_index(drop=True)\nelif len(segment_starts) == 2:\nif segment == \"loop\":\nrequested_segment = df\n# check to see if it's forward -&gt; reverse or reverse -&gt; forward\nelif (\ndf.at[segment_starts[0], \"Magnetic Field (Oe)\"]\n&gt; df.at[segment_starts[1], \"Magnetic Field (Oe)\"]\n):\nif segment == \"reverse\":\nrequested_segment = df[\nsegment_starts[0] : segment_starts[1]\n].reset_index(drop=True)\nelif segment == \"forward\":\nrequested_segment = df[segment_starts[1] - 1 :].reset_index(\ndrop=True\n)\nelse:\nif segment == \"forward\":\nrequested_segment = df[\nsegment_starts[0] : segment_starts[1]\n].reset_index(drop=True)\nelif segment == \"reverse\":\nrequested_segment = df[segment_starts[1] - 1 :].reset_index(\ndrop=True\n)\nelif len(segment_starts) == 1:\nif segment == \"loop\":\nraise self.SegmentError(\n\"Full loop requested but only one segment found\"\n)\nelif segment == \"virgin\":\nif abs(df.at[0, \"Magnetic Field (Oe)\"]) &gt; 5:\nraise self.SegmentError(\n\"Virgin scan requested but data does not start at zero field\"\n)\nrequested_segment = df\nelif segment == \"forward\":\nif df.at[0, \"Magnetic Field (Oe)\"] &gt; 0:\nraise self.SegmentError(\n\"Forward scan requested but start field is greater than end field.\"\n)\nrequested_segment = df\nelif segment == \"reverse\":\nif df.at[0, \"Magnetic Field (Oe)\"] &lt; 0:\nraise self.SegmentError(\n\"Reverse scan requested but start field is less than end field.\"\n)\nrequested_segment = df\nelse:\nraise self.SegmentError(\nf\"Something went wrong. {len(segment_starts)} segments found\"\n)\nif requested_segment is None:\nraise self.SegmentError(f\"Sequence {segment} not found in data\")\nreturn requested_segment\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.plot","title":"<code>plot(normalized=False, segment='', color='black', label='auto', title='', **kwargs)</code>","text":"<p>Plots the M vs. H data data.</p> <p>Parameters:</p> Name Type Description Default <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>segment</code> <code>str</code> <p>If a segment is given, only that segment will be plotted, by default \"\".</p> <code>\"\"</code> <code>color</code> <code>str | list[str]</code> <p>The color of the plot, by default \"auto\". If \"auto\", the color will be black.</p> <code>'black'</code> <code>label</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>MvsH</code> object in the axes legend, by default \"auto\". If \"auto\", the label will be the <code>temperature</code> of the <code>MvsH</code> object.</p> <code>'auto'</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def plot(\nself,\nnormalized: bool = False,\nsegment: str = \"\",\ncolor: str = \"black\",\nlabel: str | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the M vs. H data data.\n    Parameters\n    ----------\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n        If a segment is given, only that segment will be plotted, by default \"\".\n    color : str | list[str], optional\n        The color of the plot, by default \"auto\". If \"auto\", the color will be black.\n    label : str | list[str] | None, optional\n        The labels to assign the `MvsH` object in the axes legend, by default \"auto\".\n        If \"auto\", the label will be the `temperature` of the `MvsH` object.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\nreturn plot_single_mvsh(\nself, normalized, segment, color, label, title, **kwargs\n)\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.plot_raw","title":"<code>plot_raw(segment='forward', scan='up', center='free', colors=('purple', 'orange'), label=True, title='')</code>","text":"<p>Plots the raw voltage data for the requested segment.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Literal['virgin', 'forward', 'reverse']</code> <p>The segment of the M vs. H data to plot, by default \"forward\"</p> <code>\"virgin\"</code> <code>scan</code> <code>Literal['up', 'up_raw', 'down', 'down_raw', 'procssed']</code> <p>Which data to plot. <code>\"up\"</code> and <code>\"down\"</code> will plot the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit), <code>\"up_raw\"</code> and <code>\"down_raw\"</code> will plot the raw voltages as the come straight off the SQUID, and <code>\"processed\"</code> will plot the processed data (which is the result of fitting the up and down scans). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Only used if <code>scan</code> is <code>\"processed\"</code>; determines whether to plot the \"Free C Fitted\" or \"Fixed C Fitted\" data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"purple\"</code> and <code>\"orange\"</code> by default.</p> <code>('purple', 'orange')</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def plot_raw(\nself,\nsegment: Literal[\"virgin\", \"forward\", \"reverse\"] = \"forward\",\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"processed\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"purple\", \"orange\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the raw voltage data for the requested segment.\n    Parameters\n    ----------\n    segment : {\"virgin\", \"forward\", \"reverse\"}, optional\n        The segment of the M vs. H data to plot, by default \"forward\"\n    scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"procssed\"], optional\n        Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n        scans (which have been adjusted for drift and shifted to center the waveform\n        around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the raw\n        voltages as the come straight off the SQUID, and `\"processed\"` will plot the\n        processed data (which is the result of fitting the up and down scans). `\"up\"` by\n        default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n        Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\nreturn plot_raw(\nself.select_segment(segment), None, scan, center, colors, label, title\n)\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.plot_raw_residual","title":"<code>plot_raw_residual(segment='forward', scan='up', center='free', colors=None, label=True, title='')</code>","text":"<p>Plots the residual of the raw voltage data for the requested segment.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Literal['virgin', 'forward', 'reverse']</code> <p>The segment of the M vs. H data to plot, by default \"forward\"</p> <code>\"virgin\"</code> <code>scan</code> <code>Literal['up', 'down']</code> <p>Which data to use in the residual calculation. <code>\"up\"</code> and <code>\"down\"</code> will use the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Only used if <code>scan</code> is <code>\"processed\"</code>; determines whether to plot the \"Free C Fitted\" or \"Fixed C Fitted\" data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"purple\"</code> and <code>\"orange\"</code> by default.</p> <code>None</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def plot_raw_residual(\nself,\nsegment: Literal[\"virgin\", \"forward\", \"reverse\"] = \"forward\",\nscan: Literal[\"up\", \"down\"] = \"up\",\ncenter: Literal[\"free\", \"fixed\"] = \"free\",\ncolors: tuple[str, str] | None = None,\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the residual of the raw voltage data for the requested segment.\n    Parameters\n    ----------\n    segment : {\"virgin\", \"forward\", \"reverse\"}, optional\n        The segment of the M vs. H data to plot, by default \"forward\"\n    scan : Literal[\"up\", \"down\"], optional\n        Which data to use in the residual calculation. `\"up\"` and `\"down\"` will use the\n        processed directional scans (which have been adjusted for drift and shifted to\n        center the waveform around 0, but have not been fit). `\"up\"` by default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n        Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"purple\"` and `\"orange\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\nreturn plot_raw_residual(\nself.select_segment(segment), None, scan, center, colors, label, title\n)\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.as_dict","title":"<code>as_dict()</code>","text":"<p>Returns a dictionary representation of the <code>MvsH</code> object.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Keys are: <code>\"origin_file\"</code>, <code>\"temperature\"</code>, <code>\"field_range\"</code>, <code>\"field_correction_file\"</code>, and <code>\"scaling\"</code>.</p> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Returns a dictionary representation of the `MvsH` object.\n    Returns\n    -------\n    dict[str, Any]\n        Keys are: `\"origin_file\"`, `\"temperature\"`, `\"field_range\"`,\n        `\"field_correction_file\"`, and `\"scaling\"`.\n    \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"origin_file\": self.origin_file,\n\"temperature\": self.temperature,\n\"field_range\": self.field_range,\n\"field_correction_file\": self.field_correction_file,\n\"scaling\": self.scaling,\n}\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.MvsH.get_all_in_file","title":"<code>get_all_in_file(dat_file, eps=0.001, min_samples=10, ndigits=0, parse_raw=False)</code>  <code>classmethod</code>","text":"<p>Given a .dat file that contains one or more M vs. H experiments, returns a list of <code>MvsH</code> objects, one for each experiment.</p> <p>Parameters:</p> Name Type Description Default <code>dat_file</code> <code>str | Path | DatFile</code> <p>The .dat file containing the data for the experiment.</p> required <code>eps</code> <code>float</code> <p>See <code>magnetopy.parsing_utils.label_clusters</code> for details, by default 0.001</p> <code>0.001</code> <code>min_samples</code> <code>int</code> <p>See <code>magnetopy.parsing_utils.label_clusters</code> for details, by default 10</p> <code>10</code> <code>ndigits</code> <code>int</code> <p>See <code>magnetopy.parsing_utils.label_clusters</code> for details, by default 0</p> <code>0</code> <code>parse_raw</code> <code>bool</code> <p>If <code>True</code> and there is a corresponding .rw.dat file, the raw data will be parsed and added to the <code>data</code> attribute. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[MvsH]</code> <p>A list of <code>MvsH</code> objects, one for each experiment in the .dat file, sorted by increasing temperature.</p> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>@classmethod\ndef get_all_in_file(\ncls,\ndat_file: str | Path | DatFile,\neps: float = 0.001,\nmin_samples: int = 10,\nndigits: int = 0,\nparse_raw: bool = False,\n) -&gt; list[MvsH]:\n\"\"\"Given a .dat file that contains one or more M vs. H experiments, returns a\n    list of `MvsH` objects, one for each experiment.\n    Parameters\n    ----------\n    dat_file : str | Path | DatFile\n        The .dat file containing the data for the experiment.\n    eps : float, optional\n        See `magnetopy.parsing_utils.label_clusters` for details, by default 0.001\n    min_samples : int, optional\n        See `magnetopy.parsing_utils.label_clusters` for details, by default 10\n    ndigits : int, optional\n        See `magnetopy.parsing_utils.label_clusters` for details, by default 0\n    parse_raw : bool, optional\n        If `True` and there is a corresponding .rw.dat file, the raw data will be\n        parsed and added to the `data` attribute. Defaults to `False`.\n    Returns\n    -------\n    list[MvsH]\n        A list of `MvsH` objects, one for each experiment in the .dat file, sorted\n        by increasing temperature.\n    \"\"\"\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(Path(dat_file), parse_raw)\nif dat_file.comments:\nmvsh_objs = cls._get_all_mvsh_in_commented_file(dat_file)\nelse:\nmvsh_objs = cls._get_all_mvsh_in_uncommented_file(\ndat_file,\neps,\nmin_samples,\nndigits,\n)\nmvsh_objs.sort(key=lambda x: x.temperature)\nreturn mvsh_objs\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.TrueFieldCorrection","title":"<code>magnetopy.experiments.mvsh.TrueFieldCorrection</code>","text":"<p>             Bases: <code>MvsH</code></p> <p>A special <code>MvsH</code> class for handling the palladium standard calibration data used to correct the magnetic field for flux trapping. Unlikely to be used directly by the user, and instead will be called from the <code>correct_field</code> method of the <code>MvsH</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str | Path</code> <p>This could be a path to a .dat file containing the Pd standard sequence, or if a configuration file containing calibration data is present, the name of the sequence in the configuration file.</p> required"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.TrueFieldCorrection--see-also","title":"See Also","text":"<p>magnetopy.cli.calibration_install</p>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.TrueFieldCorrection--notes","title":"Notes","text":"<p>As described in the Quantum Design application note[1], the magnetic field reported by the magnetometer is determined by current from the magnet power supply and not by direct measurement. Flux trapping in the magnet can cause the reported field to be different from the actual field. While always present, it is most obvious in hysteresis curves of soft, non-hysteretic materials. In some cases the forward and reverse scans can have negative and postive coercivities, respectively, which is not physically possible.</p> <p>The true field correction remedies this by using a Pd standard to determine the actual field applied to the sample. Provided the calibration and sample sequences are the same, it is assumed that the flux trapping is the same for both sequences, and the calculated field from the measurement on the Pd standard is applied to the sample data.</p>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.TrueFieldCorrection--references","title":"References","text":"<p>[1] Correcting for the Absolute Field Error using the Pd Standard</p> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>class TrueFieldCorrection(MvsH):\n\"\"\"A special `MvsH` class for handling the palladium standard calibration data\n    used to correct the magnetic field for flux trapping. Unlikely to be used directly\n    by the user, and instead will be called from the `correct_field` method of the\n    `MvsH` class.\n    Parameters\n    ----------\n    sequence : str | Path\n        This could be a path to a .dat file containing the Pd standard sequence, or if\n        a configuration file containing calibration data is present, the name of the\n        sequence in the configuration file.\n    See Also\n    --------\n    magnetopy.cli.calibration_install\n    Notes\n    -----\n    As described in the Quantum Design application note[1], the magnetic field\n    reported by the magnetometer is determined by current from the magnet power\n    supply and not by direct measurement. Flux trapping in the magnet can cause\n    the reported field to be different from the actual field. While always present,\n    it is most obvious in hysteresis curves of soft, non-hysteretic materials. In\n    some cases the forward and reverse scans can have negative and postive\n    coercivities, respectively, which is not physically possible.\n    The true field correction remedies this by using a Pd standard to determine the\n    actual field applied to the sample. Provided the calibration and sample\n    sequences are the same, it is assumed that the flux trapping is the same for\n    both sequences, and the calculated field from the measurement on the Pd\n    standard is applied to the sample data.\n    References\n    ----------\n    [1] [Correcting for the Absolute Field Error using the Pd Standard](https://qdusa.com/siteDocs/appNotes/1500-021.pdf)\n    \"\"\"\ndef __init__(self, sequence: str | Path):\ndat_file = self._get_dat_file(sequence)\nsuper().__init__(dat_file)\nself.pd_mass = self._get_mass(dat_file)  # mass of the Pd standard in mg\nself._add_true_field()\ndef _get_dat_file(self, sequence: str) -&gt; DatFile:\nif Path(sequence).is_file():\nreturn DatFile(sequence)\nmp_cal = Path().home() / \".magnetopy/calibration\"\nif (Path(sequence).suffix == \".dat\") and (\nmp_cal / \"calibration_files\" / sequence\n).is_file():\nreturn DatFile(mp_cal / \"calibration_files\" / sequence)\nwith open(mp_cal / \"calibration.json\", \"r\", encoding=\"utf-8\") as f:\ncal_json = json.load(f)\nif sequence in cal_json[\"mvsh\"]:\nseq_dat = cal_json[\"mvsh\"][sequence]\nreturn DatFile(mp_cal / \"calibration_files\" / seq_dat)\nraise FileNotFoundError(\nf\"Could not find the requested sequence: {sequence}. \"\n\"TrueFieldCorrection requires either the name of a sequence listed in \"\nf\"{mp_cal / 'calibration.json'}, the name of a .dat file in \"\nf\"{mp_cal / 'calibration_files'}, or the path to a .dat file.\"\n)\n@staticmethod\ndef _get_mass(dat_file: DatFile) -&gt; float:\nfor line in dat_file.header:\ncategory = line[0]\nif category != \"INFO\":\ncontinue\ninfo = line[2]\nif info == \"SAMPLE_MASS\":\nreturn float(line[1])\nraise ValueError(\"Could not find the sample mass in the .dat file header.\")\ndef _add_true_field(self):\nchi_g = 5.25e-6  # emu Oe / g\nself.data[\"true_field\"] = self.data[\"uncorrected_moment\"] / (\nchi_g * self.pd_mass * 1e-3\n)\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.plot_mvsh","title":"<code>magnetopy.experiments.mvsh.plot_mvsh(mvsh, normalized=False, segment='', colors='auto', labels='auto', title='', **kwargs)</code>","text":"<p>Plots either a single M vs. H experiment or several on the same axes.</p> <p>Parameters:</p> Name Type Description Default <code>mvsh</code> <code>MvsH | list[MvsH]</code> <p>The data to plot given as a single or list of <code>MvsH</code> objects.</p> required <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>segment</code> <code>Literal['', 'virgin', 'forward', 'reverse', 'loop']</code> <p>If a segment is given, only that segment will be plotted, by default \"\".</p> <code>\"\"</code> <code>colors</code> <code>str | list[str]</code> <p>A list of colors corresponding to the <code>MvsH</code> objects in <code>mvsh</code>, by default \"auto\". If \"auto\" and <code>mvsh</code> is a single <code>MvsH</code> object, the color will be black. If \"auto\" and <code>mvsh</code> is a list of <code>MvsH</code> objects with different temperatures, the colors will be a linear gradient from blue to red. If \"auto\" and <code>mvsh</code> is a list of <code>MvsH</code> objects with the same temperature, the colors will be the default <code>matplotlib</code> colors.</p> <code>'auto'</code> <code>labels</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>MvsH</code> objects in the axes legend, by default \"auto\". If \"auto\", the labels will be the <code>temperature</code> of the <code>MvsH</code> objects.</p> <code>'auto'</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def plot_mvsh(\nmvsh: MvsH | list[MvsH],\nnormalized: bool = False,\nsegment: Literal[\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"] = \"\",\ncolors: str | list[str] = \"auto\",\nlabels: str | list[str] | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots either a single M vs. H experiment or several on the same axes.\n    Parameters\n    ----------\n    mvsh : MvsH | list[MvsH]\n        The data to plot given as a single or list of `MvsH` objects.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n        If a segment is given, only that segment will be plotted, by default \"\".\n    colors : str | list[str], optional\n        A list of colors corresponding to the `MvsH` objects in `mvsh`, by default\n        \"auto\". If \"auto\" and `mvsh` is a single `MvsH` object, the color will be\n        black. If \"auto\" and `mvsh` is a list of `MvsH` objects with different\n        temperatures, the colors will be a linear gradient from blue to red. If\n        \"auto\" and `mvsh` is a list of `MvsH` objects with the same temperature, the\n        colors will be the default `matplotlib` colors.\n    labels : str | list[str] | None, optional\n        The labels to assign the `MvsH` objects in the axes legend, by default \"auto\".\n        If \"auto\", the labels will be the `temperature` of the `MvsH` objects.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\nif isinstance(mvsh, list) and len(mvsh) == 1:\nmvsh = mvsh[0]\nif isinstance(mvsh, MvsH):\nif isinstance(colors, list) or isinstance(labels, list):\nraise ValueError(\n\"If plotting a single MvsH, `colors` and `labels` must be a single value\"\n)\nreturn plot_single_mvsh(\nmvsh=mvsh,\nnormalized=normalized,\nsegment=segment,\ncolor=colors,\nlabel=labels,\ntitle=title,\n**kwargs,\n)\nif colors != \"auto\" and not isinstance(colors, list):\nraise ValueError(\n\"If plotting multiple MvsH, `colors` must be a list or 'auto'.\"\n)\nif labels is not None and labels != \"auto\" and not isinstance(labels, list):\nraise ValueError(\n\"If plotting multiple MvsH, `labels` must be a list or 'auto' or `None`.\"\n)\nreturn plot_multiple_mvsh(\nmvsh,\nnormalized=normalized,\nsegment=segment,\ncolors=colors,\nlabels=labels,\ntitle=title,\n**kwargs,\n)\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.plot_single_mvsh","title":"<code>magnetopy.experiments.mvsh.plot_single_mvsh(mvsh, normalized=False, segment='', color='black', label='auto', title='', **kwargs)</code>","text":"<p>Plots a single M vs. H experiment.</p> <p>Parameters:</p> Name Type Description Default <code>mvsh</code> <code>MvsH</code> <p>The data to plot given as a single <code>MvsH</code> object.</p> required <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>segment</code> <code>str</code> <p>If a segment is given, only that segment will be plotted, by default \"\".</p> <code>\"\"</code> <code>color</code> <code>str | list[str]</code> <p>The color of the plot, by default \"auto\". If \"auto\", the color will be black.</p> <code>'black'</code> <code>label</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>MvsH</code> object in the axes legend, by default \"auto\". If \"auto\", the label will be the <code>temperature</code> of the <code>MvsH</code> object.</p> <code>'auto'</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def plot_single_mvsh(\nmvsh: MvsH,\nnormalized: bool = False,\nsegment: str = \"\",\ncolor: str = \"black\",\nlabel: str | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots a single M vs. H experiment.\n    Parameters\n    ----------\n    mvsh : MvsH\n        The data to plot given as a single `MvsH` object.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n        If a segment is given, only that segment will be plotted, by default \"\".\n    color : str | list[str], optional\n        The color of the plot, by default \"auto\". If \"auto\", the color will be black.\n    label : str | list[str] | None, optional\n        The labels to assign the `MvsH` object in the axes legend, by default \"auto\".\n        If \"auto\", the label will be the `temperature` of the `MvsH` object.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\noptions = handle_kwargs(**kwargs)\ncolor = \"black\" if color == \"auto\" else color\nfig, ax = plt.subplots()\nx = mvsh.simplified_data(segment)[\"field\"] / 10000\ny = mvsh.simplified_data(segment)[\"moment\"]\ny = y / y.max() if normalized else y\nif label is None:\nax.plot(x, y, c=color)\nelse:\nif label == \"auto\":\nlabel = f\"{mvsh.temperature} K\"\nax.plot(x, y, c=color, label=label)\nax.set_xlabel(\"Field (T)\")\nif normalized:\nax.set_ylabel(\"Normalized Magnetization\")\nelse:\nylabel = get_ylabel(\"moment\", mvsh.scaling)\nax.set_ylabel(ylabel)\nhandle_options(ax, label, title, options)\nforce_aspect(ax)\nif options[\"save\"]:\nplt.savefig(\noptions[\"save\"], dpi=300, bbox_inches=\"tight\", facecolor=\"w\", edgecolor=\"w\"\n)\nreturn fig, ax\n</code></pre>"},{"location":"api/mvsh/#magnetopy.experiments.mvsh.plot_multiple_mvsh","title":"<code>magnetopy.experiments.mvsh.plot_multiple_mvsh(mvsh, normalized=False, segment='', colors='auto', labels=None, title='', **kwargs)</code>","text":"<p>Plots several M vs. H experiment on the same axes.</p> <p>Parameters:</p> Name Type Description Default <code>mvsh</code> <code>MvsH | list[MvsH]</code> <p>The data to plot given as a list of <code>MvsH</code> objects.</p> required <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>segment</code> <code>str</code> <p>If a segment is given, only that segment will be plotted, by default \"\".</p> <code>\"\"</code> <code>colors</code> <code>str | list[str]</code> <p>A list of colors corresponding to the <code>MvsH</code> objects in <code>mvsh</code>, by default \"auto\". If \"auto\" and <code>mvsh</code> is a list of <code>MvsH</code> objects with different temperatures, the colors will be a linear gradient from blue to red. If \"auto\" and <code>mvsh</code> is a list of <code>MvsH</code> objects with the same temperature, the colors will be the default <code>matplotlib</code> colors.</p> <code>'auto'</code> <code>labels</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>MvsH</code> objects in the axes legend, by default \"auto\". If \"auto\", the labels will be the <code>temperature</code> of the <code>MvsH</code> objects.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\mvsh.py</code> <pre><code>def plot_multiple_mvsh(\nmvsh: list[MvsH],\nnormalized: bool = False,\nsegment: str = \"\",\ncolors: list[str] | Literal[\"auto\"] = \"auto\",\nlabels: list[str] | None = None,\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots several M vs. H experiment on the same axes.\n    Parameters\n    ----------\n    mvsh : MvsH | list[MvsH]\n        The data to plot given as a list of `MvsH` objects.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    segment : {\"\", \"virgin\", \"forward\", \"reverse\", \"loop\"}, optional\n        If a segment is given, only that segment will be plotted, by default \"\".\n    colors : str | list[str], optional\n        A list of colors corresponding to the `MvsH` objects in `mvsh`, by default\n        \"auto\". If \"auto\" and `mvsh` is a list of `MvsH` objects with different\n        temperatures, the colors will be a linear gradient from blue to red. If\n        \"auto\" and `mvsh` is a list of `MvsH` objects with the same temperature, the\n        colors will be the default `matplotlib` colors.\n    labels : str | list[str] | None, optional\n        The labels to assign the `MvsH` objects in the axes legend, by default \"auto\".\n        If \"auto\", the labels will be the `temperature` of the `MvsH` objects.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\noptions = handle_kwargs(**kwargs)\nif colors == \"auto\":\ncolors = default_colors(len(mvsh))\nif _check_if_variable_temperature(mvsh):\nmvsh.sort(key=lambda x: x.temperature)\ncolors = linear_color_gradient(\"blue\", \"red\", len(mvsh))\nif labels == \"auto\":\nlabels = [f\"{x.temperature} K\" for x in mvsh]\nif labels is None:\nlabels: list[None] = [None] * len(mvsh)\nfig, ax = plt.subplots()\nfor m, color, label in zip(mvsh, colors, labels):\nx = m.simplified_data(segment)[\"field\"] / 10000\ny = m.simplified_data(segment)[\"moment\"]\ny = y / y.max() if normalized else y\nif label:\nax.plot(x, y, c=color, label=label)\nelse:\nax.plot(x, y, c=color)\nax.set_xlabel(\"Field (T)\")\nif normalized:\nax.set_ylabel(\"Normalized Magnetization\")\nelse:\nylabel = get_ylabel(\"moment\", mvsh[0].scaling)\nax.set_ylabel(ylabel)\nhandle_options(ax, labels[0], title, options)\nforce_aspect(ax)\nif options[\"save\"]:\nplt.savefig(\noptions[\"save\"], dpi=300, bbox_inches=\"tight\", facecolor=\"w\", edgecolor=\"w\"\n)\nreturn fig, ax\n</code></pre>"},{"location":"api/parsing_utils/","title":"Parsing","text":"<p>These functions are used within the various data file and experiment classes and it's unlikely you'll need them while performing data analysis using <code>magnetopy</code>. Future development of new classes for new types of data files or new experiments may find these useful, though.</p>"},{"location":"api/parsing_utils/#magnetopy.parsing_utils.label_clusters","title":"<code>magnetopy.parsing_utils.label_clusters(vals, eps=0.001, min_samples=10)</code>","text":"<p>For determining the nominal values of data in a series containing one or more nominal values with some fluctuations. The data is first normalized using <code>sklearn.preprocessing.StandardScaler()</code>, then clustered using <code>sklearn.cluster.DBSCAN()</code>.</p> <p>It is assumed that all data belongs to a cluster (i.e. there are no outliers). If this is not the case, <code>eps</code> is increased by a factor of 10 and the clustering is tried again.</p> <p>Parameters:</p> Name Type Description Default <code>vals</code> <code>pd.Series</code> <p>A series of data containing one or more nominal values with some fluctuations.</p> required <code>eps</code> <code>float</code> <p>Passed to <code>sklearn.cluster.DBSCAN()</code>. The maximum distance between two samples for one to be considered as in the neighborhood of the other, by default 0.001.</p> <code>0.001</code> <code>min_samples</code> <code>int</code> <p>Passed to <code>sklearn.cluster.DBSCAN()</code>. The number of samples in a neighborhood for a point to be considered as a core point, by default 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>An array of the same size as <code>vals</code> which contains the cluster labels for each element in <code>vals</code>.</p> Source code in <code>magnetopy\\parsing_utils.py</code> <pre><code>def label_clusters(\nvals: pd.Series, eps: float = 0.001, min_samples: int = 10\n) -&gt; np.ndarray:\n\"\"\"For determining the nominal values of data in a series containing one or more\n    nominal values with some fluctuations. The data is first normalized using\n    `sklearn.preprocessing.StandardScaler()`, then clustered using\n    `sklearn.cluster.DBSCAN()`.\n    It is assumed that all data belongs to a cluster (i.e. there are no outliers). If\n    this is not the case, `eps` is increased by a factor of 10 and the clustering is\n    tried again.\n    Parameters\n    ----------\n    vals : pd.Series\n        A series of data containing one or more nominal values with some fluctuations.\n    eps : float, optional\n        Passed to `sklearn.cluster.DBSCAN()`. The maximum distance between two samples\n        for one to be considered as in the neighborhood of the other, by default 0.001.\n    min_samples : int, optional\n        Passed to `sklearn.cluster.DBSCAN()`. The number of samples in a neighborhood\n        for a point to be considered as a core point, by default 10.\n    Returns\n    -------\n    np.ndarray\n        An array of the same size as `vals` which contains the cluster labels for each\n        element in `vals`.\n    \"\"\"\nreshaped_vals = vals.values.reshape(-1, 1)\nscaler = StandardScaler()\nreshaped_normalized_vals = scaler.fit_transform(reshaped_vals)\n# adjust eps based on the range of the normalized data\neps_scaled = np.ptp(reshaped_normalized_vals) * eps\ndbscan = DBSCAN(eps=eps_scaled, min_samples=min_samples)\ncluster_labels = dbscan.fit_predict(reshaped_normalized_vals)\n# all values should be assigned to a cluster\n# if not, increase eps and try again\nif -1 in cluster_labels:\ncluster_labels = label_clusters(vals, eps=eps * 10, min_samples=min_samples)\nreturn cluster_labels\n</code></pre>"},{"location":"api/parsing_utils/#magnetopy.parsing_utils.unique_values","title":"<code>magnetopy.parsing_utils.unique_values(x, eps=0.001, min_samples=10, ndigits=0)</code>","text":"<p>Given a series of data containing one or more nominal values with some noise, returns a list of the nominal values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>pd.Series</code> <p>A series of data containing one or more nominal values with some noise.</p> required <code>eps</code> <code>float</code> <p>Passed to <code>label_clusters()</code>. The maximum distance between two samples for one to be considered as in the neighborhood of the other, by default 0.001.</p> <code>0.001</code> <code>min_samples</code> <code>int</code> <p>Passed to <code>label_clusters()</code>. The number of samples in a neighborhood for a point to be considered as a core point, by default 10.</p> <code>10</code> <code>ndigits</code> <code>int</code> <p>The number of digits after the decimal point to round the nominal values to, by default 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>The nominal values in <code>x</code> with the noise removed.</p> Source code in <code>magnetopy\\parsing_utils.py</code> <pre><code>def unique_values(\nx: pd.Series, eps: float = 0.001, min_samples: int = 10, ndigits: int = 0\n) -&gt; list[int | float]:\n\"\"\"Given a series of data containing one or more nominal values with some noise,\n    returns a list of the nominal values.\n    Parameters\n    ----------\n    x : pd.Series\n        A series of data containing one or more nominal values with some noise.\n    eps : float, optional\n        Passed to `label_clusters()`. The maximum distance between two samples for one\n        to be considered as in the neighborhood of the other, by default 0.001.\n    min_samples : int, optional\n        Passed to `label_clusters()`. The number of samples in a neighborhood for a\n        point to be considered as a core point, by default 10.\n    ndigits : int, optional\n        The number of digits after the decimal point to round the nominal values to,\n        by default 0.\n    Returns\n    -------\n    list[float]\n        The nominal values in `x` with the noise removed.\n    \"\"\"\ncluster_labels = label_clusters(x, eps=eps, min_samples=min_samples)\nunique_vals = []\nfor i in np.unique(cluster_labels):\n# average the values in each cluster\nunique_val = np.mean(x[cluster_labels == i])\nunique_val = round(unique_val, ndigits)\nif ndigits == 0:\nunique_val = int(unique_val)\nunique_vals.append(unique_val)\nreturn unique_vals\n</code></pre>"},{"location":"api/parsing_utils/#magnetopy.parsing_utils.find_outlier_indices","title":"<code>magnetopy.parsing_utils.find_outlier_indices(x, threshold=3)</code>","text":"<p>Finds the indices of outliers in a series of data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>pd.Series</code> <p>A series of data.</p> required <code>threshold</code> <code>float</code> <p>The number of standard deviations from the mean to consider a value an outlier, by default 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>The indices of the outliers in <code>x</code>.</p> Source code in <code>magnetopy\\parsing_utils.py</code> <pre><code>def find_outlier_indices(x: pd.Series, threshold: float = 3) -&gt; list[int]:\n\"\"\"Finds the indices of outliers in a series of data.\n    Parameters\n    ----------\n    x : pd.Series\n        A series of data.\n    threshold : float, optional\n        The number of standard deviations from the mean to consider a value an outlier,\n        by default 3.\n    Returns\n    -------\n    list[int]\n        The indices of the outliers in `x`.\n    \"\"\"\nz_scores = (x - x.mean()) / x.std()\noutliers = z_scores.abs() &gt; threshold\nreturn list(outliers[outliers].index)\n</code></pre>"},{"location":"api/parsing_utils/#magnetopy.parsing_utils.find_temp_turnaround_point","title":"<code>magnetopy.parsing_utils.find_temp_turnaround_point(df, num_endpoints_ignored=20)</code>","text":"<p>Finds the index of the temperature turnaround point in a dataframe of a ZFCFC experiment which includes a column \"Temperature (K)\". Can handle two cases in which a single dataframe contains first a ZFC experiment, then a FC experiment: - Case 1: ZFC temperature monotonically increases, then FC temperature monotonically decreases. - Case 2: ZFC temperature monotonically increases, the temperature is reset to a lower value, then FC temperature monotonically increases.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>A dataframe of a ZFCFC experiment which includes a column \"Temperature (K)\".</p> required <code>num_endpoints_ignored</code> <code>int</code> <p>The number of endpoints to ignore when finding the turnaround point, by default 20. This is useful when dealing with data collecting by scanning temperature, as there are often 20 or so points at the end of the scane where the temperature is very slowly settling.</p> <code>20</code> <p>Returns:</p> Type Description <code>int</code> <p>The index of the temperature turnaround point.</p> Source code in <code>magnetopy\\parsing_utils.py</code> <pre><code>def find_temp_turnaround_point(\ndf: pd.DataFrame, num_endpoints_ignored: int = 20\n) -&gt; int:\n\"\"\"Finds the index of the temperature turnaround point in a dataframe of\n    a ZFCFC experiment which includes a column \"Temperature (K)\". Can handle two cases\n    in which a single dataframe contains first a ZFC experiment, then a FC experiment:\n    - Case 1: ZFC temperature monotonically increases, then FC temperature\n    monotonically decreases.\n    - Case 2: ZFC temperature monotonically increases, the temperature is reset to a\n    lower value, then FC temperature monotonically increases.\n    Parameters\n    ----------\n    df : pd.DataFrame\n        A dataframe of a ZFCFC experiment which includes a column \"Temperature (K)\".\n    num_endpoints_ignored : int, optional\n        The number of endpoints to ignore when finding the turnaround point, by default\n        20. This is useful when dealing with data collecting by scanning temperature,\n        as there are often 20 or so points at the end of the scane where the\n        temperature is very slowly settling.\n    Returns\n    -------\n    int\n        The index of the temperature turnaround point.\n    \"\"\"\noutlier_indices = find_outlier_indices(df[\"Temperature (K)\"].diff())\nif len(outlier_indices) == 0:\n# Case 1: zfc temp increases, fc temp decreases\nzero_point = abs(\ndf[\"Temperature (K)\"]\n.iloc[num_endpoints_ignored:-num_endpoints_ignored]\n.diff()\n).idxmin()\nreturn zero_point\nelse:\n# Case 2: zfc temp increases, reset temp, fc temp increases\nreturn outlier_indices[0]\n</code></pre>"},{"location":"api/parsing_utils/#magnetopy.parsing_utils.find_sequence_starts","title":"<code>magnetopy.parsing_utils.find_sequence_starts(x, flucuation_tolerance=0)</code>","text":"<p>Find the indices of the start of each sequence in a series of data, where a sequences is defined as a series of numbers that constantly increase or decrease. Changes below <code>fluctuation_tolerance</code> are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>pd.Series</code> <p>A series of data.</p> required <code>flucuation_tolerance</code> <code>float</code> <p>Changes below this value are ignored, by default 0.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt;x = pd.Series([0, 1, 2, 3, 4, 3, 2, 1])\n&gt;&gt;&gt;_find_sequence_starts(x)\n[0, 5]\n</code></pre> <pre><code>&gt;&gt;&gt;y = pd.Series([0, 1, 2, 3, 0, 1, 2, 3])\n&gt;&gt;&gt;_find_sequence_starts(y)\n[0, 4]\n</code></pre> Source code in <code>magnetopy\\parsing_utils.py</code> <pre><code>def find_sequence_starts(\nx: pd.Series,\nflucuation_tolerance: float = 0,\n) -&gt; list[int]:\n\"\"\"Find the indices of the start of each sequence in a series of data,\n    where a sequences is defined as a series of numbers that constantly increase or decrease.\n    Changes below `fluctuation_tolerance` are ignored.\n    Parameters\n    ----------\n    x : pd.Series\n        A series of data.\n    flucuation_tolerance : float, optional\n        Changes below this value are ignored, by default 0.\n    Examples\n    --------\n    &gt;&gt;&gt;x = pd.Series([0, 1, 2, 3, 4, 3, 2, 1])\n    &gt;&gt;&gt;_find_sequence_starts(x)\n    [0, 5]\n    &gt;&gt;&gt;y = pd.Series([0, 1, 2, 3, 0, 1, 2, 3])\n    &gt;&gt;&gt;_find_sequence_starts(y)\n    [0, 4]\n    \"\"\"\nif flucuation_tolerance &lt; 0:\nraise ValueError(\"fluctuation_tolerance must be non-negative\")\ndf = pd.DataFrame({\"x\": x, \"diff\": x.diff()})\ndf[\"direction\"] = np.where(df[\"diff\"] &gt; 0, 1, -1)\nstart: int = df.index.start  # type: ignore\ndf.at[start, \"direction\"] = df.at[\nstart + 1, \"direction\"\n]  # since the first value of diff is NaN\n# if there's a really small diff value with the opposite sign of diff values around it, it's probably a mistake\nsequence_starts = [0]\nfor i in df[start + 2 :].index:\nlast2_dir = df.at[i - 2, \"direction\"]  # type: ignore\nlast1_dir = df.at[i - 1, \"direction\"]  # type: ignore\ncurrent_dir = df.at[i, \"direction\"]\ntry:\nnext1_dir = df.at[i + 1, \"direction\"]  # type: ignore\nnext2_dir = df.at[i + 2, \"direction\"]  # type: ignore\nnext3_dir = df.at[i + 3, \"direction\"]  # type: ignore\nexcept KeyError:\n# reached end of dataframe\nbreak\n# below handles, for example, zfc from 5 to 300 K, drop temp to 5 K, fc from 5 to 300 K\nif (current_dir != last1_dir) and (current_dir != next1_dir):\nif abs(df.at[i, \"diff\"]) &lt; flucuation_tolerance:\n# this is a fluctuation and should be ignored\ndf.at[i, \"direction\"] = last1_dir\ncurrent_dir = last1_dir\nelse:\nsequence_starts.append(i)  # type: ignore\n# below handles, for example, zfc from 5 to 300 K, fc from 300 to 5 K\n# assumes there won't be any fluctuations at the beginning of a sequence\nif (\n(last2_dir == last1_dir)\nand (current_dir != last1_dir)\nand (current_dir == next1_dir == next2_dir == next3_dir)\n):\nsequence_starts.append(i)  # type: ignore\nreturn sequence_starts\n</code></pre>"},{"location":"api/plot_utils/","title":"Plotting","text":"<p>The plotting functions within <code>magnetopy</code> handle many basic use cases but are unlikely to provide exactly what's needed for specific project needs, and the user may still need to be able to make their own plots. Some of the utility functions herein may be helpful in that regard.</p>"},{"location":"api/plot_utils/#magnetopy.plot_utils.linear_color_gradient","title":"<code>magnetopy.plot_utils.linear_color_gradient(start_color, finish_color='white', n=10)</code>","text":"<p>Return a list of colors forming linear gradients between two colors.</p> <p>Parameters:</p> Name Type Description Default <code>start_color</code> <code>HexColorCode | basic_colors</code> <p>The starting color as either a hex code (e.g. \"#FFFFFF\") or a basic color name.</p> required <code>finish_color</code> <code>HexColorCode | basic_colors</code> <p>The ending color as either a hex code (e.g. \"#FFFFFF\") or a basic color name, by default \"white\"</p> <code>'white'</code> <code>n</code> <code>int | Sized</code> <p>The number of colors to return, by default 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>list[HexColorCode]</code> <p>A list of hex color codes forming a linear gradient between the start and finish colors.</p>"},{"location":"api/plot_utils/#magnetopy.plot_utils.linear_color_gradient--notes","title":"Notes","text":"<p>Supported basic colors includes: \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\", \"black\", and \"white\".</p>"},{"location":"api/plot_utils/#magnetopy.plot_utils.linear_color_gradient--references","title":"References","text":"<p>Color Gradients with Python</p> Source code in <code>magnetopy\\plot_utils.py</code> <pre><code>def linear_color_gradient(\nstart_color: HexColorCode | BasicColors,\nfinish_color: HexColorCode | BasicColors = \"white\",\nn: int | Sized = 10,\n) -&gt; list[HexColorCode]:\n\"\"\"Return a list of colors forming linear gradients between two colors.\n    Parameters\n    ----------\n    start_color : HexColorCode | basic_colors\n        The starting color as either a hex code (e.g. \"#FFFFFF\") or a basic color\n        name.\n    finish_color : HexColorCode | basic_colors, optional\n        The ending color as either a hex code (e.g. \"#FFFFFF\") or a basic color\n        name, by default \"white\"\n    n : int | Sized, optional\n        The number of colors to return, by default 10.\n    Returns\n    -------\n    list[HexColorCode]\n        A list of hex color codes forming a linear gradient between the start and\n        finish colors.\n    Notes\n    -----\n    Supported basic colors includes: \"red\", \"orange\", \"yellow\", \"green\", \"blue\",\n    \"purple\", \"black\", and \"white\".\n    References\n    ----------\n    [Color Gradients with Python](\n        https://bsouthga.dev/posts/color-gradients-with-python)\n    \"\"\"\ndef hex_to_rgb(hex_color: str) -&gt; list:\n# Pass 16 to the integer function for change of base\nreturn [int(hex_color[i : i + 2], 16) for i in range(1, 6, 2)]\ndef rgb_to_hex(rgb: str) -&gt; str:\n# Components need to be integers for hex to make sense\nrgb = [int(x) for x in rgb]\nreturn \"#\" + \"\".join(\n[\"0{0:x}\".format(v) if v &lt; 16 else \"{0:x}\".format(v) for v in rgb]\n)\n_basic_colors = {\n\"red\": \"#FF0000\",\n\"orange\": \"#E36D12\",\n\"yellow\": \"#FFFF00\",\n\"green\": \"#0F7823\",\n\"blue\": \"#0000FF\",\n\"purple\": \"#6E12E6\",\n\"black\": \"#000000\",\n\"white\": \"#FFFFFF\",\n}\nstart_color = _basic_colors.get(start_color, start_color)\nfinish_color = _basic_colors.get(finish_color, finish_color)\nstart = hex_to_rgb(start_color)\nfinish = hex_to_rgb(finish_color)\n# Initilize a list of the output colors with the starting color\nrgb_list = [start]\n# Calcuate a color at each evenly spaced value of t from 1 to n\nif isinstance(n, int):\nfor t in range(1, n):\n# Interpolate RGB vector for color at the current value of t\ncurr_vector = [\nint(start[j] + (float(t) / (n - 1)) * (finish[j] - start[j]))\nfor j in range(3)\n]\n# Add it to our list of output colors\nrgb_list.append(curr_vector)\nelif isinstance(n, pd.core.series.Series):\nfull_vector = [finish[i] - start[i] for i in range(3)]\nfull_vector_length = np.sqrt(\nfull_vector[0] ** 2 + full_vector[1] ** 2 + full_vector[2] ** 2\n)\nunit_vector = [full_vector[i] / full_vector_length for i in range(3)]\nindex_range = n.max() - n.min()\nprevious_color = start\nn = n.to_list()\nprevious_index = n[0]\nfor current_index in n[1:]:\nstep_size = (\nfull_vector_length * (current_index - previous_index) / index_range\n)\n# Make step of size step_size in direction of full_vector\ncurr_vector = [\nprevious_color[i] + unit_vector[i] * step_size for i in range(3)\n]\nprevious_index = current_index\nprevious_color = curr_vector\nrgb_list.append(curr_vector)\nhex_list = []\nfor rgb in rgb_list:\nhex_list.append(rgb_to_hex(rgb))\nreturn hex_list\n</code></pre>"},{"location":"api/plot_utils/#magnetopy.plot_utils.default_colors","title":"<code>magnetopy.plot_utils.default_colors(n)</code>","text":"<p>Return a list of colors for plotting. The default colors are the first 10 colors from the Matplotlib default color cycle. If more than 10 colors are requested, the default colors are cycled.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | Sized</code> <p>The number of colors to return or a list-like object of the same length as the number of colors to return.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of colors for plotting.</p> Source code in <code>magnetopy\\plot_utils.py</code> <pre><code>def default_colors(n: int | Sized) -&gt; list[str]:\n\"\"\"Return a list of colors for plotting. The default colors are the first 10\n    colors from the Matplotlib default color cycle. If more than 10 colors are\n    requested, the default colors are cycled.\n    Parameters\n    ----------\n    n : int | Sized\n        The number of colors to return or a list-like object of the same length as\n        the number of colors to return.\n    Returns\n    -------\n    list[str]\n        A list of colors for plotting.\n    \"\"\"\nif not isinstance(n, int):\nn = len(n)\ndefault = cycle(\n[\n\"#1f77b4\",\n\"#ff7f0e\",\n\"#2ca02c\",\n\"#d62728\",\n\"#9467bd\",\n\"#8c564b\",\n\"#e377c2\",\n\"#7f7f7f\",\n\"#bcbd22\",\n\"#17becf\",\n]\n)\nreturn [next(default) for _ in range(n)]\n</code></pre>"},{"location":"api/plot_utils/#magnetopy.plot_utils.force_aspect","title":"<code>magnetopy.plot_utils.force_aspect(ax, aspect=1)</code>","text":"<p>Force the aspect ratio of a plot to be a certain value. Uses the axes's current x and y limits to calculate the aspect ratio. Works for both linear and log scales.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>plt.Axes</code> <p>The axes to force the aspect ratio of.</p> required <code>aspect</code> <code>int</code> <p>The desired aspect ratio, by default 1.</p> <code>1</code> Source code in <code>magnetopy\\plot_utils.py</code> <pre><code>def force_aspect(ax: plt.Axes, aspect=1) -&gt; None:\n\"\"\"Force the aspect ratio of a plot to be a certain value. Uses the axes's current\n    x and y limits to calculate the aspect ratio. Works for both linear and log scales.\n    Parameters\n    ----------\n    ax : plt.Axes\n        The axes to force the aspect ratio of.\n    aspect : int, optional\n        The desired aspect ratio, by default 1.\n    \"\"\"\n# aspect is width/height\nxscale_str = ax.get_xaxis().get_scale()\nyscale_str = ax.get_yaxis().get_scale()\nxmin, xmax = ax.get_xlim()\nymin, ymax = ax.get_ylim()\nif xscale_str == \"linear\" and yscale_str == \"linear\":\nasp = abs((xmax - xmin) / (ymax - ymin)) / aspect\nelif xscale_str == \"log\" and yscale_str == \"linear\":\nasp = abs((np.log10(xmax) - np.log10(xmin)) / (ymax - ymin)) / aspect\nelif xscale_str == \"log\" and yscale_str == \"log\":\nasp = (\nabs((np.log10(xmax) - np.log10(xmin)) / (np.log10(ymax) - np.log10(ymin)))\n/ aspect\n)\nelif xscale_str == \"linear\" and yscale_str == \"log\":\nasp = abs((xmax - xmin) / (np.log10(ymax) - np.log10(ymin))) / aspect\nax.set_aspect(asp)\n</code></pre>"},{"location":"api/simple_mvsh_analysis/","title":"SimpleMvsHAnalysis","text":""},{"location":"api/simple_mvsh_analysis/#magnetopy.analyses.simple_mvsh.SimpleMvsHAnalysis","title":"<code>magnetopy.analyses.simple_mvsh.SimpleMvsHAnalysis</code>","text":"<p>An analysis of an M vs. H experiment that determines basic information about the hysteresis loop (i.e., saturation magnetization, coercive field, remnant field).</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Magnetometry</code> <p>The <code>Magnetometry</code> object which contains the <code>MvsH</code> object to be analyzed.</p> required <code>parsing_args</code> <code>SimpleMvsHAnalysisParsingArgs</code> <p>Arguments needed to parse the <code>Magnetometry</code> object to obtain the <code>MvsH</code> object to be analyzed.</p> required <p>Attributes:</p> Name Type Description <code>parsing_args</code> <code>SimpleMvsHAnalysisParsingArgs</code> <p>Arguments needed to parse the <code>Magnetometry</code> object to obtain the <code>MvsH</code> object to be analyzed.</p> <code>mvsh</code> <code>MvsH</code> <p>The analyzed <code>MvsH</code> object.</p> <code>results</code> <code>SimpleMvsHAnalysisResults</code> <p>The results of the analysis.</p> Source code in <code>magnetopy\\analyses\\simple_mvsh.py</code> <pre><code>class SimpleMvsHAnalysis:\n\"\"\"An analysis of an M vs. H experiment that determines basic information about the\n    hysteresis loop (i.e., saturation magnetization, coercive field, remnant field).\n    Parameters\n    ----------\n    dataset : Magnetometry\n        The `Magnetometry` object which contains the `MvsH` object to be analyzed.\n    parsing_args : SimpleMvsHAnalysisParsingArgs\n        Arguments needed to parse the `Magnetometry` object to obtain the `MvsH` object\n        to be analyzed.\n    Attributes\n    ----------\n    parsing_args : SimpleMvsHAnalysisParsingArgs\n        Arguments needed to parse the `Magnetometry` object to obtain the `MvsH` object\n        to be analyzed.\n    mvsh : MvsH\n        The analyzed `MvsH` object.\n    results : SimpleMvsHAnalysisResults\n        The results of the analysis.\n    \"\"\"\ndef __init__(\nself,\ndataset: Magnetometry,\nparsing_args: SimpleMvsHAnalysisParsingArgs,\n) -&gt; None:\nself.parsing_args = parsing_args\nself.mvsh = dataset.get_mvsh(self.parsing_args.temperature)\nsegments = self._get_segments()\nm_s = self._determine_m_s(segments)\nh_c = self._determine_h_c(segments)\nm_r = self._determine_m_r(segments)\nmoment_units = self._determine_moment_units()\nfield_units = \"Oe\"\nself.results = SimpleMvsHAnalysisResults(\nm_s, h_c, m_r, moment_units, field_units, list(segments.keys())\n)\ndef _get_segments(self) -&gt; dict[str, pd.DataFrame]:\nsegments: dict[str : pd.DataFrame] = {}\nif self.parsing_args.segments == \"auto\":\ntry:\nsegments[\"forward\"] = self.mvsh.simplified_data(\"forward\")\nexcept MvsH.SegmentError:\npass\ntry:\nsegments[\"reverse\"] = self.mvsh.simplified_data(\"reverse\")\nexcept MvsH.SegmentError:\npass\nelse:\nif self.parsing_args.segments in [\"loop\", \"forward\"]:\nsegments[\"forward\"] = self.mvsh.simplified_data(\"forward\")\nif self.parsing_args.segments in [\"loop\", \"reverse\"]:\nsegments[\"reverse\"] = self.mvsh.simplified_data(\"reverse\")\nreturn segments\ndef _determine_m_s(self, segments: dict[str, pd.DataFrame]) -&gt; float:\nm_s = 0\nfor segment in segments.values():\nm_s += (segment[\"moment\"].max() + abs(segment[\"moment\"].min())) / 2\nreturn m_s / len(segments)\ndef _determine_h_c(self, segments: dict[str, pd.DataFrame]) -&gt; float:\nh_c = 0\nfor segment in segments.values():\nh_c += abs(segment[\"field\"].iloc[segment[\"moment\"].abs().idxmin()])\nreturn h_c / len(segments)\ndef _determine_m_r(self, segments: dict[str, pd.DataFrame]) -&gt; float:\nm_r = 0\nfor segment in segments.values():\nm_r += abs(segment[\"moment\"].iloc[segment[\"field\"].abs().idxmin()])\nreturn m_r / len(segments)\ndef _determine_moment_units(self) -&gt; str:\nscaling = self.mvsh.scaling\nif not scaling:\nreturn \"emu\"\nelif \"mass\" in scaling:\nreturn \"emu/g\"\nelif \"molar\" in scaling:\nreturn \"bohr magnetons/mol\"\ndef as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Return a dictionary representation of the analysis.\n        Returns\n        -------\n        dict[str, Any]\n            Keys are `\"mvsh\"`, `\"parsing_args\"`, and `\"results\"`.\n        \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"mvsh\": self.mvsh,\n\"parsing_args\": self.parsing_args,\n\"results\": self.results,\n}\n</code></pre>"},{"location":"api/simple_mvsh_analysis/#magnetopy.analyses.simple_mvsh.SimpleMvsHAnalysis.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dictionary representation of the analysis.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Keys are <code>\"mvsh\"</code>, <code>\"parsing_args\"</code>, and <code>\"results\"</code>.</p> Source code in <code>magnetopy\\analyses\\simple_mvsh.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Return a dictionary representation of the analysis.\n    Returns\n    -------\n    dict[str, Any]\n        Keys are `\"mvsh\"`, `\"parsing_args\"`, and `\"results\"`.\n    \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"mvsh\": self.mvsh,\n\"parsing_args\": self.parsing_args,\n\"results\": self.results,\n}\n</code></pre>"},{"location":"api/simple_mvsh_analysis/#magnetopy.analyses.simple_mvsh.SimpleMvsHAnalysisParsingArgs","title":"<code>magnetopy.analyses.simple_mvsh.SimpleMvsHAnalysisParsingArgs</code>  <code>dataclass</code>","text":"<p>Arguments needed to parse a <code>Magnetometry</code> object during the course of an analysis performed by <code>SimpleMvsHAnalysis</code>.</p> <p>Attributes:</p> Name Type Description <code>temperature</code> <code>float</code> <p>The temperature in Kelvin of the measurement to be analyzed.</p> <code>segments</code> <code>(Literal['auto', 'loop', 'forward', 'reverse'], optional)</code> <p>The segments of the measurement to be analyzed. If <code>\"auto\"</code>, the forward and reverse segments will be analyzed if they exist and will be ignored if they don't. If <code>\"loop\"</code>, the forward and reverse segments will be analyzed if they exist and an error will be raised if they don't. If <code>\"forward\"</code> or <code>\"reverse\"</code>, only the forward or reverse segment will be analyzed, respectively.</p> Source code in <code>magnetopy\\analyses\\simple_mvsh.py</code> <pre><code>@dataclass\nclass SimpleMvsHAnalysisParsingArgs:\n\"\"\"Arguments needed to parse a `Magnetometry` object during the course of an\n    analysis performed by `SimpleMvsHAnalysis`.\n    Attributes\n    ----------\n    temperature : float\n        The temperature in Kelvin of the measurement to be analyzed.\n    segments : Literal[\"auto\", \"loop\", \"forward\", \"reverse\"], optional\n        The segments of the measurement to be analyzed. If `\"auto\"`, the forward and\n        reverse segments will be analyzed if they exist and will be ignored if they\n        don't. If `\"loop\"`, the forward and reverse segments will be analyzed if they\n        exist and an error will be raised if they don't. If `\"forward\"` or `\"reverse\"`,\n        only the forward or reverse segment will be analyzed, respectively.\n    \"\"\"\ntemperature: float\nsegments: Literal[\"auto\", \"loop\", \"forward\", \"reverse\"] = \"auto\"\ndef as_dict(self) -&gt; dict[str, Any]:\noutput = asdict(self)\noutput[\"_class_\"] = self.__class__.__name__\nreturn output\n</code></pre>"},{"location":"api/simple_mvsh_analysis/#magnetopy.analyses.simple_mvsh.SimpleMvsHAnalysisResults","title":"<code>magnetopy.analyses.simple_mvsh.SimpleMvsHAnalysisResults</code>  <code>dataclass</code>","text":"<p>The results of an analysis performed by <code>SimpleMvsHAnalysis</code>.</p> <p>Attributes:</p> Name Type Description <code>m_s</code> <code>float</code> <p>The saturation magnetization of the sample in units of <code>moment_units</code>.</p> <code>h_c</code> <code>float</code> <p>The coercive field of the sample in units of <code>field_units</code>.</p> <code>m_r</code> <code>float</code> <p>The remanent magnetization of the sample in units of <code>moment_units</code>.</p> <code>moment_units</code> <code>str</code> <p>The units of the saturation magnetization and remanent magnetization.</p> <code>field_units</code> <code>str</code> <p>The units of the coercive field.</p> <code>segments</code> <code>list[{forward, reverse}]</code> <p>The segments of the measurement that were analyzed.</p> Source code in <code>magnetopy\\analyses\\simple_mvsh.py</code> <pre><code>@dataclass\nclass SimpleMvsHAnalysisResults:\n\"\"\"The results of an analysis performed by `SimpleMvsHAnalysis`.\n    Attributes\n    ----------\n    m_s : float\n        The saturation magnetization of the sample in units of `moment_units`.\n    h_c : float\n        The coercive field of the sample in units of `field_units`.\n    m_r : float\n        The remanent magnetization of the sample in units of `moment_units`.\n    moment_units : str\n        The units of the saturation magnetization and remanent magnetization.\n    field_units : str\n        The units of the coercive field.\n    segments : list[{\"forward\", \"reverse\"}]\n        The segments of the measurement that were analyzed.\n    \"\"\"\nm_s: float\nh_c: float\nm_r: float\nmoment_units: str\nfield_units: str\nsegments: Literal[\"forward\", \"reverse\"]\ndef as_dict(self) -&gt; dict[str, Any]:\noutput = asdict(self)\noutput[\"_class_\"] = self.__class__.__name__\nreturn output\n</code></pre>"},{"location":"api/zfcfc/","title":"ZFC, FC, ZFCFC","text":""},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFCFC","title":"<code>magnetopy.experiments.zfcfc.ZFCFC</code>","text":"<p>A single ZFCFC experiment at a given field. Unlikely to be called directly, instead use <code>ZFC</code> or <code>FC</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dat_file</code> <code>str, Path, or DatFile</code> <p>The .dat file containing the data for the experiment.</p> required <code>experiment</code> <code>Literal['zfc', 'fc']</code> <p>The type of experiment. Either \"zfc\" or \"fc\".</p> <code>\"zfc\"</code> <code>field</code> <code>int or float</code> <p>The magnetic field of the experiment in Oe. Requied if the .dat file contains multiple uncommented experiments at different fields. If <code>None</code> and the .dat file contains a single experiment, the field will be automatically detected. Defaults to <code>None</code>.</p> <code>None</code> <code>parse_raw</code> <code>bool</code> <p>If <code>True</code> and there is a corresponding .rw.dat file, the raw data will be parsed and added to the <code>data</code> attribute. Defaults to <code>False</code>.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments used for algorithmic separation of data at the requested field. - n_digits : int, optional - suppress_warnings : bool, optional</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>origin_file</code> <code>str</code> <p>The name of the .dat file from which the data was parsed.</p> <code>field</code> <code>float</code> <p>The field of the experiment in Oe.</p> <code>data</code> <code>pandas.DataFrame</code> <p>The data from the experiment. Columns are taken directly from the .dat file.</p> <code>scaling</code> <code>list of str</code> <p>The scaling applied to the data. If no scaling has been applied, this will be an empty list. Possible values are: <code>\"mass\"</code>, <code>\"molar\"</code>, <code>\"eicosane\"</code>, and <code>\"diamagnetic_correction\"</code>.</p> <code>temperature_range</code> <code>tuple of float</code> <p>The minimum and maximum temperature values in the data.</p> <p>Raises:</p> Type Description <code>NonMatchingFieldError</code> <p>Raised if the requested field is not in the data.</p> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>class ZFCFC:\n\"\"\"A single ZFCFC experiment at a given field. Unlikely to be called directly,\n    instead use `ZFC` or `FC`.\n    Parameters\n    ----------\n    dat_file : str, Path, or DatFile\n        The .dat file containing the data for the experiment.\n    experiment : {\"zfc\", \"fc\"}\n        The type of experiment. Either \"zfc\" or \"fc\".\n    field : int or float, optional\n        The magnetic field of the experiment in Oe. Requied if the .dat file contains\n        multiple uncommented experiments at different fields. If `None` and the .dat\n        file contains a single experiment, the field will be automatically detected.\n        Defaults to `None`.\n    parse_raw : bool, optional\n        If `True` and there is a corresponding .rw.dat file, the raw data will be\n        parsed and added to the `data` attribute. Defaults to `False`.\n    **kwargs : dict, optional\n        Keyword arguments used for algorithmic separation of data at the requested\n        field.\n        - n_digits : int, optional\n        - suppress_warnings : bool, optional\n    Attributes\n    ----------\n    origin_file : str\n        The name of the .dat file from which the data was parsed.\n    field : float\n        The field of the experiment in Oe.\n    data : pandas.DataFrame\n        The data from the experiment. Columns are taken directly from the .dat file.\n    scaling : list of str\n        The scaling applied to the data. If no scaling has been applied, this will be\n        an empty list. Possible values are: `\"mass\"`, `\"molar\"`, `\"eicosane\"`,\n        and `\"diamagnetic_correction\"`.\n    temperature_range : tuple of float\n        The minimum and maximum temperature values in the data.\n    Raises\n    ------\n    NonMatchingFieldError\n        Raised if the requested field is not in the data.\n    \"\"\"\nclass NonMatchingFieldError(Exception):\npass\ndef __init__(\nself,\ndat_file: str | Path | DatFile,\nexperiment: Literal[\"zfc\", \"fc\"],\nfield: int | float | None = None,\nparse_raw: bool = False,\n**kwargs,\n) -&gt; None:\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(Path(dat_file), parse_raw)\nself.origin_file = dat_file.local_path.name\nn_digits = num_digits_after_decimal(field) if field else 0\noptions = {\"n_digits\": n_digits, \"suppress_warnings\": False}\noptions.update(kwargs)\nfound_filename_label = filename_label(\ndat_file.local_path.name, experiment, options[\"suppress_warnings\"]\n)\nif field is None:\nfield = _auto_detect_field(dat_file, experiment, options[\"n_digits\"])\nself.field = field\nif dat_file.comments:\nself.data = self._set_data_from_comments(dat_file, experiment)\nelse:\nif found_filename_label in [\"zfcfc\", \"unknown\"]:\nself.data = self._set_data_auto(dat_file, experiment)\nelse:\nself.data = self._set_single_sequence_data(\ndat_file, experiment, options[\"n_digits\"]\n)\nadd_uncorrected_moment_columns(self)\nself.scaling = []\nself.temperature_range = self._determine_temperature_range()\ndef __str__(self) -&gt; str:\nreturn f\"{self.__class__.__name__} at {self.field} Oe\"\ndef __repr__(self) -&gt; str:\nreturn f\"{self.__class__.__name__} at {self.field} Oe\"\ndef _set_data_from_comments(\nself, dat_file: DatFile, experiment: str\n) -&gt; pd.DataFrame:\nstart_idx: int | None = None\nend_idx: int | None = None\nfor comment_idx, (data_idx, comment_list) in enumerate(\ndat_file.comments.items()\n):\n# ignore other experiments\nif experiment not in map(str.lower, comment_list):\ncontinue\n# one of the comments should be a number denoting the field\n# may also include a unit, e.g. \"1000 Oe\"\nfor comment in comment_list:\nif match := re.search(r\"\\d+\", comment):\nfound_field = float(match.group())\n# check to see if the unit is T otherwise assume Oe\nif \"T\" in comment:\nfound_field = found_field * 1e4\nif found_field == self.field:\nstart_idx = (\ndata_idx + 1\n)  # +1 to skip the line containing the comment\nend_idx = (\nlist(dat_file.comments.keys())[comment_idx + 1]\nif comment_idx + 1 &lt; len(dat_file.comments)\nelse (len(dat_file.data))\n)\nbreak\nif start_idx is not None:\nbreak\nelse:\nraise self.NonMatchingFieldError(\nf\"Temperature {self.field} not in data in {dat_file}. \"\n\"Or the comments are not formatted correctly.\"\n)\ndf = dat_file.data.iloc[start_idx:end_idx].reset_index(drop=True)\nreturn df\ndef _set_data_auto(self, dat_file: DatFile, experiment: str) -&gt; pd.DataFrame:\nturnaround = find_temp_turnaround_point(dat_file.data)\n# assume zfc, then fc\nif experiment == \"zfc\":\ndf = dat_file.data.iloc[:turnaround].reset_index(drop=True)\nelse:\ndf = dat_file.data.iloc[turnaround:].reset_index(drop=True)\nreturn df\ndef _set_single_sequence_data(\nself, dat_file: DatFile, experiment: str, n_digits: int\n) -&gt; pd.DataFrame:\n\"\"\"\n        Used for when the file contains a single sequence of data, e.g. a single ZFC or FC\n        at a single field.\"\"\"\ndf = dat_file.data.copy()\nfound_fields = np.unique(df[\"Magnetic Field (Oe)\"])\nif len(found_fields) != 1:\nraise ZFCFC.NonMatchingFieldError(\nf\"Attempting to read in {experiment} data from {dat_file}, \"\nf\"but found data from multiple fields ({found_fields}). \"\n\"This method currently only supports files containing data from a single \"\n\"field.\"\n)\nif round(found_fields[0], n_digits) != self.field:\nraise ZFCFC.NonMatchingFieldError(\nf\"Attempting to read in {experiment} data from {dat_file}, \"\nf\"but found data from a different field ({found_fields[0]}) \"\nf\"than the one specified ({self.field}).\"\n)\nreturn df\ndef scale_moment(\nself,\nmass: float = 0,\neicosane_mass: float = 0,\nmolecular_weight: float = 0,\ndiamagnetic_correction: float = 0,\n) -&gt; None:\n\"\"\"Adds the following columns to the `DataFrame` in the `data` attribute:\n        `\"moment\"`, `\"moment_err\"`, `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and\n        `\"chi_t_err\"`. A record of what scaling was applied is added to the\n        `scaling` attribute.\n        See `magnetopy.experiments.utils.scale_dc_data` for more information.\n        Parameters\n        ----------\n        mass : float, optional\n            mg of sample, by default 0.\n        eicosane_mass : float, optional\n            mg of eicosane, by default 0.\n        molecular_weight : float, optional\n            Molecular weight of the material in g/mol, by default 0.\n        diamagnetic_correction : float, optional\n            Diamagnetic correction of the material in cm^3/mol, by default 0.\n        \"\"\"\nscale_dc_data(\nself,\nmass,\neicosane_mass,\nmolecular_weight,\ndiamagnetic_correction,\n)\ndef simplified_data(self) -&gt; pd.DataFrame:\n\"\"\"Returns a simplified version of the data, removing unnecessary columns\n        and renaming the remaining columns to more convenient names.\n        Returns\n        -------\n        pd.DataFrame\n            The simplified data. Contains the columns:\n            - `\"time\"` in seconds\n            - `\"temperature\"` in Kelvin\n            - `\"field\"` in Oe\n            - `\"moment\"`\n            - `\"moment_err\"`\n            - `\"chi\"`\n            - `\"chi_err\"`\n            - `\"chi_t\"`\n            - `\"chi_t_err\"`\n            Where units are not specified, they are determined by the scaling applied to the\n            data (see `scaling` attribute).\n        \"\"\"\nfull_df = self.data.copy()\ndf = pd.DataFrame()\ndf[\"time\"] = full_df[\"Time Stamp (sec)\"]\ndf[\"temperature\"] = full_df[\"Temperature (K)\"]\ndf[\"field\"] = full_df[\"Magnetic Field (Oe)\"]\nif self.scaling:\ndf[\"moment\"] = full_df[\"moment\"]\ndf[\"moment_err\"] = full_df[\"moment_err\"]\ndf[\"chi\"] = full_df[\"chi\"]\ndf[\"chi_err\"] = full_df[\"chi_err\"]\ndf[\"chi_t\"] = full_df[\"chi_t\"]\ndf[\"chi_t_err\"] = full_df[\"chi_t_err\"]\nelse:\ndf[\"moment\"] = full_df[\"uncorrected_moment\"]\ndf[\"moment_err\"] = full_df[\"uncorrected_moment_err\"]\ndf[\"chi\"] = df[\"moment\"] / df[\"field\"]\ndf[\"chi_err\"] = df[\"moment_err\"] / df[\"field\"]\ndf[\"chi_t\"] = df[\"chi\"] * df[\"temperature\"]\ndf[\"chi_t_err\"] = df[\"chi_err\"] * df[\"temperature\"]\nreturn df\ndef _determine_temperature_range(self) -&gt; tuple[float, float]:\nsimplified_data = self.simplified_data()\nreturn (\nsimplified_data[\"temperature\"].min(),\nsimplified_data[\"temperature\"].max(),\n)\ndef plot_raw(\nself,\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"processed\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"blue\", \"red\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the raw voltage data from the experiment. Ensures that the data is\n        ordered from low to high temperature so that the default color gradient (blue\n        to red) is appropriate.\n        Parameters\n        ----------\n        scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"procssed\"], optional\n            Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n            scans (which have been adjusted for drift and shifted to center the waveform\n            around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the\n            raw voltages as the come straight off the SQUID, and `\"processed\"` will\n            plot the processed data (which is the result of fitting the up and down\n            scans). `\"up\"` by default.\n        center : Literal[\"free\", \"fixed\"], optional\n            Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n            Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n        colors : tuple[str, str], optional\n            The (start, end) colors for the color gradient. `\"blue\"` and `\"red\"` by\n            default.\n        label : bool, optional\n            Default `True`. Whether to put labels on the plot for the initial and final\n            scans.\n        title : str, optional\n            The title of the plot. `\"\"` by default.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n        \"\"\"\ndf = self.data.copy()\ndf = df.sort_values(\"Temperature (K)\")\nreturn plot_raw(df, None, scan, center, colors, label, title)\ndef plot_raw_residual(\nself,\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"processed\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"blue\", \"red\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the residual of the raw voltage data from the experiment. Ensures that\n        the data is ordered from low to high temperature so that the default color\n        gradient (blue to red) is appropriate.\n        Parameters\n        ----------\n        scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"procssed\"], optional\n            Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n            scans (which have been adjusted for drift and shifted to center the waveform\n            around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the\n            raw voltages as the come straight off the SQUID, and `\"processed\"` will\n            plot the processed data (which is the result of fitting the up and down\n            scans). `\"up\"` by default.\n        center : Literal[\"free\", \"fixed\"], optional\n            Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n            Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n        colors : tuple[str, str], optional\n            The (start, end) colors for the color gradient. `\"blue\"` and `\"red\"` by\n            default.\n        label : bool, optional\n            Default `True`. Whether to put labels on the plot for the initial and final\n            scans.\n        title : str, optional\n            The title of the plot. `\"\"` by default.\n        Returns\n        -------\n        tuple[plt.Figure, plt.Axes]\n        \"\"\"\ndf = self.data.copy()\ndf = df.sort_values(\"Temperature (K)\")\nreturn plot_raw_residual(df, None, scan, center, colors, label, title)\ndef as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Returns a dictionary representation of the `MvsH` object.\n        Returns\n        -------\n        dict[str, Any]\n            Keys are: `\"origin_file\"`, `\"field\"`, `\"temperature_range\"`,\n            and `\"scaling\"`.\n        \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"origin_file\": self.origin_file,\n\"field\": self.field,\n\"temperature_range\": self.temperature_range,\n\"scaling\": self.scaling,\n}\n@classmethod\ndef get_all_zfcfc_in_file(\ncls,\ndat_file: str | Path | DatFile,\nexperiment: str,\nn_digits: int = 0,\nparse_raw: bool = False,\n) -&gt; list[ZFCFC]:\n\"\"\"Given a .dat file that contains one or more ZFC or FC experiments, returns a\n        list of `ZFC` or `FC` objects, one for each experiment.\n        Parameters\n        ----------\n        dat_file : str | Path | DatFile\n            The .dat file containing the data for the experiment.\n        experiment : {\"zfc\", \"fc\"}\n            The type of experiment. Either \"zfc\" or \"fc\".\n        n_digits : int, optional\n            The number of digits after the decimal point to round the field to. Defaults\n            to `0`.\n        parse_raw : bool, optional\n            If `True` and there is a corresponding .rw.dat file, the raw data will be\n            parsed and added to the `data` attribute. Defaults to `False`.\n        Returns\n        -------\n        list[ZFC] | list[FC]\n            A list of `ZFC` or `FC` objects, one for each experiment in the .dat file,\n            sorted by increasing field.\n        \"\"\"\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(Path(dat_file), parse_raw)\nif dat_file.comments:\nzfcfc_objs = cls._get_all_zfcfc_in_commented_file(dat_file, experiment)\nelse:\nzfcfc_objs = cls._get_all_zfcfc_in_uncommented_file(\ndat_file, experiment, n_digits\n)\nzfcfc_objs.sort(key=lambda x: x.field)\nreturn zfcfc_objs\n@classmethod\ndef _get_all_zfcfc_in_commented_file(\ncls,\ndat_file: DatFile,\nexperiment: str,\n) -&gt; list[ZFCFC]:\nzfcfc_objs = []\nfor comment_list in dat_file.comments.values():\n# ignore other experiments\nif experiment not in map(str.lower, comment_list):\ncontinue\n# one of the comments should be a number denoting the field\n# may also include a unit, e.g. \"1000 Oe\"\nfor comment in comment_list:\nif match := re.search(r\"\\d+\", comment):\nfield = float(match.group())\n# check to see if the unit is T otherwise assume Oe\nif \"T\" in comment:\nfield = field * 1e4\n# the following type guard allows for the `get_all` method to be\n# called from the parent (ZFCFC) or child classes (ZFC, FC)\nif cls.__base__ == ZFCFC:\n# we're calling from ZFC or FC\nzfcfc_objs.append(cls(dat_file, field))\nelse:\n# we're calling from ZFCFC\nzfcfc_objs.append(cls(dat_file, experiment, field))\nreturn zfcfc_objs\n@classmethod\ndef _get_all_zfcfc_in_uncommented_file(\ncls,\ndat_file: DatFile,\nexperiment: str,\nn_digits: int,\n) -&gt; list[ZFCFC]:\n\"\"\"This method currently only supports an uncommented file with a single experiment\"\"\"\n# the following type guard allows for the `get_all` method to be\n# called from the parent (ZFCFC) or child classes (ZFC, FC)\nzfcfc_objs = []\nif cls.__base__ == ZFCFC:\n# we're calling from ZFC or FC\nzfcfc_objs.append(\ncls(  # pylint: disable=E1120\ndat_file,\nn_digits=n_digits,\n)\n)\nelse:\n# we're calling from ZFCFC\nzfcfc_objs.append(cls(dat_file, experiment, n_digits=n_digits))\nreturn zfcfc_objs\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFCFC.scale_moment","title":"<code>scale_moment(mass=0, eicosane_mass=0, molecular_weight=0, diamagnetic_correction=0)</code>","text":"<p>Adds the following columns to the <code>DataFrame</code> in the <code>data</code> attribute: <code>\"moment\"</code>, <code>\"moment_err\"</code>, <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, and <code>\"chi_t_err\"</code>. A record of what scaling was applied is added to the <code>scaling</code> attribute.</p> <p>See <code>magnetopy.experiments.utils.scale_dc_data</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>mass</code> <code>float</code> <p>mg of sample, by default 0.</p> <code>0</code> <code>eicosane_mass</code> <code>float</code> <p>mg of eicosane, by default 0.</p> <code>0</code> <code>molecular_weight</code> <code>float</code> <p>Molecular weight of the material in g/mol, by default 0.</p> <code>0</code> <code>diamagnetic_correction</code> <code>float</code> <p>Diamagnetic correction of the material in cm^3/mol, by default 0.</p> <code>0</code> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def scale_moment(\nself,\nmass: float = 0,\neicosane_mass: float = 0,\nmolecular_weight: float = 0,\ndiamagnetic_correction: float = 0,\n) -&gt; None:\n\"\"\"Adds the following columns to the `DataFrame` in the `data` attribute:\n    `\"moment\"`, `\"moment_err\"`, `\"chi\"`, `\"chi_err\"`, `\"chi_t\"`, and\n    `\"chi_t_err\"`. A record of what scaling was applied is added to the\n    `scaling` attribute.\n    See `magnetopy.experiments.utils.scale_dc_data` for more information.\n    Parameters\n    ----------\n    mass : float, optional\n        mg of sample, by default 0.\n    eicosane_mass : float, optional\n        mg of eicosane, by default 0.\n    molecular_weight : float, optional\n        Molecular weight of the material in g/mol, by default 0.\n    diamagnetic_correction : float, optional\n        Diamagnetic correction of the material in cm^3/mol, by default 0.\n    \"\"\"\nscale_dc_data(\nself,\nmass,\neicosane_mass,\nmolecular_weight,\ndiamagnetic_correction,\n)\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFCFC.simplified_data","title":"<code>simplified_data()</code>","text":"<p>Returns a simplified version of the data, removing unnecessary columns and renaming the remaining columns to more convenient names.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>The simplified data. Contains the columns: - <code>\"time\"</code> in seconds - <code>\"temperature\"</code> in Kelvin - <code>\"field\"</code> in Oe - <code>\"moment\"</code> - <code>\"moment_err\"</code> - <code>\"chi\"</code> - <code>\"chi_err\"</code> - <code>\"chi_t\"</code> - <code>\"chi_t_err\"</code></p> <p>Where units are not specified, they are determined by the scaling applied to the data (see <code>scaling</code> attribute).</p> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def simplified_data(self) -&gt; pd.DataFrame:\n\"\"\"Returns a simplified version of the data, removing unnecessary columns\n    and renaming the remaining columns to more convenient names.\n    Returns\n    -------\n    pd.DataFrame\n        The simplified data. Contains the columns:\n        - `\"time\"` in seconds\n        - `\"temperature\"` in Kelvin\n        - `\"field\"` in Oe\n        - `\"moment\"`\n        - `\"moment_err\"`\n        - `\"chi\"`\n        - `\"chi_err\"`\n        - `\"chi_t\"`\n        - `\"chi_t_err\"`\n        Where units are not specified, they are determined by the scaling applied to the\n        data (see `scaling` attribute).\n    \"\"\"\nfull_df = self.data.copy()\ndf = pd.DataFrame()\ndf[\"time\"] = full_df[\"Time Stamp (sec)\"]\ndf[\"temperature\"] = full_df[\"Temperature (K)\"]\ndf[\"field\"] = full_df[\"Magnetic Field (Oe)\"]\nif self.scaling:\ndf[\"moment\"] = full_df[\"moment\"]\ndf[\"moment_err\"] = full_df[\"moment_err\"]\ndf[\"chi\"] = full_df[\"chi\"]\ndf[\"chi_err\"] = full_df[\"chi_err\"]\ndf[\"chi_t\"] = full_df[\"chi_t\"]\ndf[\"chi_t_err\"] = full_df[\"chi_t_err\"]\nelse:\ndf[\"moment\"] = full_df[\"uncorrected_moment\"]\ndf[\"moment_err\"] = full_df[\"uncorrected_moment_err\"]\ndf[\"chi\"] = df[\"moment\"] / df[\"field\"]\ndf[\"chi_err\"] = df[\"moment_err\"] / df[\"field\"]\ndf[\"chi_t\"] = df[\"chi\"] * df[\"temperature\"]\ndf[\"chi_t_err\"] = df[\"chi_err\"] * df[\"temperature\"]\nreturn df\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFCFC.plot_raw","title":"<code>plot_raw(scan='up', center='free', colors=('blue', 'red'), label=True, title='')</code>","text":"<p>Plots the raw voltage data from the experiment. Ensures that the data is ordered from low to high temperature so that the default color gradient (blue to red) is appropriate.</p> <p>Parameters:</p> Name Type Description Default <code>scan</code> <code>Literal['up', 'up_raw', 'down', 'down_raw', 'procssed']</code> <p>Which data to plot. <code>\"up\"</code> and <code>\"down\"</code> will plot the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit), <code>\"up_raw\"</code> and <code>\"down_raw\"</code> will plot the raw voltages as the come straight off the SQUID, and <code>\"processed\"</code> will plot the processed data (which is the result of fitting the up and down scans). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Only used if <code>scan</code> is <code>\"processed\"</code>; determines whether to plot the \"Free C Fitted\" or \"Fixed C Fitted\" data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"blue\"</code> and <code>\"red\"</code> by default.</p> <code>('blue', 'red')</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def plot_raw(\nself,\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"processed\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"blue\", \"red\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the raw voltage data from the experiment. Ensures that the data is\n    ordered from low to high temperature so that the default color gradient (blue\n    to red) is appropriate.\n    Parameters\n    ----------\n    scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"procssed\"], optional\n        Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n        scans (which have been adjusted for drift and shifted to center the waveform\n        around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the\n        raw voltages as the come straight off the SQUID, and `\"processed\"` will\n        plot the processed data (which is the result of fitting the up and down\n        scans). `\"up\"` by default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n        Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"blue\"` and `\"red\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\ndf = self.data.copy()\ndf = df.sort_values(\"Temperature (K)\")\nreturn plot_raw(df, None, scan, center, colors, label, title)\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFCFC.plot_raw_residual","title":"<code>plot_raw_residual(scan='up', center='free', colors=('blue', 'red'), label=True, title='')</code>","text":"<p>Plots the residual of the raw voltage data from the experiment. Ensures that the data is ordered from low to high temperature so that the default color gradient (blue to red) is appropriate.</p> <p>Parameters:</p> Name Type Description Default <code>scan</code> <code>Literal['up', 'up_raw', 'down', 'down_raw', 'procssed']</code> <p>Which data to plot. <code>\"up\"</code> and <code>\"down\"</code> will plot the processed directional scans (which have been adjusted for drift and shifted to center the waveform around 0, but have not been fit), <code>\"up_raw\"</code> and <code>\"down_raw\"</code> will plot the raw voltages as the come straight off the SQUID, and <code>\"processed\"</code> will plot the processed data (which is the result of fitting the up and down scans). <code>\"up\"</code> by default.</p> <code>'up'</code> <code>center</code> <code>Literal['free', 'fixed']</code> <p>Only used if <code>scan</code> is <code>\"processed\"</code>; determines whether to plot the \"Free C Fitted\" or \"Fixed C Fitted\" data. <code>\"free\"</code> by default.</p> <code>'free'</code> <code>colors</code> <code>tuple[str, str]</code> <p>The (start, end) colors for the color gradient. <code>\"blue\"</code> and <code>\"red\"</code> by default.</p> <code>('blue', 'red')</code> <code>label</code> <code>bool</code> <p>Default <code>True</code>. Whether to put labels on the plot for the initial and final scans.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the plot. <code>\"\"</code> by default.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def plot_raw_residual(\nself,\nscan: Literal[\n\"up\",\n\"up_raw\",\n\"down\",\n\"down_raw\",\n\"processed\",\n] = \"up\",\ncenter: Literal[\n\"free\",\n\"fixed\",\n] = \"free\",\ncolors: tuple[str, str] = (\"blue\", \"red\"),\nlabel: bool = True,\ntitle: str = \"\",\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots the residual of the raw voltage data from the experiment. Ensures that\n    the data is ordered from low to high temperature so that the default color\n    gradient (blue to red) is appropriate.\n    Parameters\n    ----------\n    scan : Literal[\"up\", \"up_raw\", \"down\", \"down_raw\", \"procssed\"], optional\n        Which data to plot. `\"up\"` and `\"down\"` will plot the processed directional\n        scans (which have been adjusted for drift and shifted to center the waveform\n        around 0, but have not been fit), `\"up_raw\"` and `\"down_raw\"` will plot the\n        raw voltages as the come straight off the SQUID, and `\"processed\"` will\n        plot the processed data (which is the result of fitting the up and down\n        scans). `\"up\"` by default.\n    center : Literal[\"free\", \"fixed\"], optional\n        Only used if `scan` is `\"processed\"`; determines whether to plot the \"Free C\n        Fitted\" or \"Fixed C Fitted\" data. `\"free\"` by default.\n    colors : tuple[str, str], optional\n        The (start, end) colors for the color gradient. `\"blue\"` and `\"red\"` by\n        default.\n    label : bool, optional\n        Default `True`. Whether to put labels on the plot for the initial and final\n        scans.\n    title : str, optional\n        The title of the plot. `\"\"` by default.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\ndf = self.data.copy()\ndf = df.sort_values(\"Temperature (K)\")\nreturn plot_raw_residual(df, None, scan, center, colors, label, title)\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFCFC.as_dict","title":"<code>as_dict()</code>","text":"<p>Returns a dictionary representation of the <code>MvsH</code> object.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Keys are: <code>\"origin_file\"</code>, <code>\"field\"</code>, <code>\"temperature_range\"</code>, and <code>\"scaling\"</code>.</p> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Returns a dictionary representation of the `MvsH` object.\n    Returns\n    -------\n    dict[str, Any]\n        Keys are: `\"origin_file\"`, `\"field\"`, `\"temperature_range\"`,\n        and `\"scaling\"`.\n    \"\"\"\nreturn {\n\"_class_\": self.__class__.__name__,\n\"origin_file\": self.origin_file,\n\"field\": self.field,\n\"temperature_range\": self.temperature_range,\n\"scaling\": self.scaling,\n}\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFCFC.get_all_zfcfc_in_file","title":"<code>get_all_zfcfc_in_file(dat_file, experiment, n_digits=0, parse_raw=False)</code>  <code>classmethod</code>","text":"<p>Given a .dat file that contains one or more ZFC or FC experiments, returns a list of <code>ZFC</code> or <code>FC</code> objects, one for each experiment.</p> <p>Parameters:</p> Name Type Description Default <code>dat_file</code> <code>str | Path | DatFile</code> <p>The .dat file containing the data for the experiment.</p> required <code>experiment</code> <code>str</code> <p>The type of experiment. Either \"zfc\" or \"fc\".</p> <code>\"zfc\"</code> <code>n_digits</code> <code>int</code> <p>The number of digits after the decimal point to round the field to. Defaults to <code>0</code>.</p> <code>0</code> <code>parse_raw</code> <code>bool</code> <p>If <code>True</code> and there is a corresponding .rw.dat file, the raw data will be parsed and added to the <code>data</code> attribute. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[ZFC] | list[FC]</code> <p>A list of <code>ZFC</code> or <code>FC</code> objects, one for each experiment in the .dat file, sorted by increasing field.</p> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>@classmethod\ndef get_all_zfcfc_in_file(\ncls,\ndat_file: str | Path | DatFile,\nexperiment: str,\nn_digits: int = 0,\nparse_raw: bool = False,\n) -&gt; list[ZFCFC]:\n\"\"\"Given a .dat file that contains one or more ZFC or FC experiments, returns a\n    list of `ZFC` or `FC` objects, one for each experiment.\n    Parameters\n    ----------\n    dat_file : str | Path | DatFile\n        The .dat file containing the data for the experiment.\n    experiment : {\"zfc\", \"fc\"}\n        The type of experiment. Either \"zfc\" or \"fc\".\n    n_digits : int, optional\n        The number of digits after the decimal point to round the field to. Defaults\n        to `0`.\n    parse_raw : bool, optional\n        If `True` and there is a corresponding .rw.dat file, the raw data will be\n        parsed and added to the `data` attribute. Defaults to `False`.\n    Returns\n    -------\n    list[ZFC] | list[FC]\n        A list of `ZFC` or `FC` objects, one for each experiment in the .dat file,\n        sorted by increasing field.\n    \"\"\"\nif not isinstance(dat_file, DatFile):\ndat_file = DatFile(Path(dat_file), parse_raw)\nif dat_file.comments:\nzfcfc_objs = cls._get_all_zfcfc_in_commented_file(dat_file, experiment)\nelse:\nzfcfc_objs = cls._get_all_zfcfc_in_uncommented_file(\ndat_file, experiment, n_digits\n)\nzfcfc_objs.sort(key=lambda x: x.field)\nreturn zfcfc_objs\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.ZFC","title":"<code>magnetopy.experiments.zfcfc.ZFC</code>","text":"<p>             Bases: <code>ZFCFC</code></p> <p>A single ZFC experiment at a given field.</p> <p>Parameters:</p> Name Type Description Default <code>dat_file</code> <code>str, Path, or DatFile</code> <p>The .dat file containing the data for the experiment.</p> required <code>field</code> <code>int or float</code> <p>The magnetic field of the experiment in Oe. Requied if the .dat file contains multiple uncommented experiments at different fields. If <code>None</code> and the .dat file contains a single experiment, the field will be automatically detected. Defaults to <code>None</code>.</p> <code>None</code> <code>parse_raw</code> <code>bool</code> <p>If <code>True</code> and there is a corresponding .rw.dat file, the raw data will be parsed and added to the <code>data</code> attribute. Defaults to <code>False</code>.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments used for algorithmic separation of data at the requested field. - n_digits : int, optional - suppress_warnings : bool, optional</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>origin_file</code> <code>str</code> <p>The name of the .dat file from which the data was parsed.</p> <code>field</code> <code>float</code> <p>The field of the experiment in Oe.</p> <code>data</code> <code>pandas.DataFrame</code> <p>The data from the experiment. Columns are taken directly from the .dat file.</p> <code>scaling</code> <code>list of str</code> <p>The scaling applied to the data. If no scaling has been applied, this will be an empty list. Possible values are: <code>\"mass\"</code>, <code>\"molar\"</code>, <code>\"eicosane\"</code>, and <code>\"diamagnetic_correction\"</code>.</p> <code>temperature_range</code> <code>tuple of float</code> <p>The minimum and maximum temperature values in the data.</p> <p>Raises:</p> Type Description <code>NonMatchingFieldError</code> <p>Raised if the requested field is not in the data.</p> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>class ZFC(ZFCFC):\n\"\"\"A single ZFC experiment at a given field.\n    Parameters\n    ----------\n    dat_file : str, Path, or DatFile\n        The .dat file containing the data for the experiment.\n    field : int or float, optional\n        The magnetic field of the experiment in Oe. Requied if the .dat file contains\n        multiple uncommented experiments at different fields. If `None` and the .dat\n        file contains a single experiment, the field will be automatically detected.\n        Defaults to `None`.\n    parse_raw : bool, optional\n        If `True` and there is a corresponding .rw.dat file, the raw data will be\n        parsed and added to the `data` attribute. Defaults to `False`.\n    **kwargs : dict, optional\n        Keyword arguments used for algorithmic separation of data at the requested\n        field.\n        - n_digits : int, optional\n        - suppress_warnings : bool, optional\n    Attributes\n    ----------\n    origin_file : str\n        The name of the .dat file from which the data was parsed.\n    field : float\n        The field of the experiment in Oe.\n    data : pandas.DataFrame\n        The data from the experiment. Columns are taken directly from the .dat file.\n    scaling : list of str\n        The scaling applied to the data. If no scaling has been applied, this will be\n        an empty list. Possible values are: `\"mass\"`, `\"molar\"`, `\"eicosane\"`,\n        and `\"diamagnetic_correction\"`.\n    temperature_range : tuple of float\n        The minimum and maximum temperature values in the data.\n    Raises\n    ------\n    NonMatchingFieldError\n        Raised if the requested field is not in the data.\n    \"\"\"\ndef __init__(\nself,\ndat_file: str | Path | DatFile,\nfield: int | float | None = None,\nparse_raw: bool = False,\n**kwargs,\n) -&gt; None:\nsuper().__init__(dat_file, \"zfc\", field, parse_raw, **kwargs)\n@classmethod\ndef get_all_in_file(\ncls,\ndat_file: str | Path | DatFile,\nn_digits: int = 0,\nparse_raw: bool = False,\n) -&gt; list[ZFC]:\nreturn super().get_all_zfcfc_in_file(dat_file, \"zfc\", n_digits, parse_raw)\ndef __str__(self):\nreturn f\"ZFC at {self.field} Oe\"\ndef __repr__(self):\nreturn f\"ZFC at {self.field} Oe\"\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.FC","title":"<code>magnetopy.experiments.zfcfc.FC</code>","text":"<p>             Bases: <code>ZFCFC</code></p> <p>A single FC experiment at a given field.</p> <p>Parameters:</p> Name Type Description Default <code>dat_file</code> <code>str, Path, or DatFile</code> <p>The .dat file containing the data for the experiment.</p> required <code>field</code> <code>int or float</code> <p>The magnetic field of the experiment in Oe. Requied if the .dat file contains multiple uncommented experiments at different fields. If <code>None</code> and the .dat file contains a single experiment, the field will be automatically detected. Defaults to <code>None</code>.</p> <code>None</code> <code>parse_raw</code> <code>bool</code> <p>If <code>True</code> and there is a corresponding .rw.dat file, the raw data will be parsed and added to the <code>data</code> attribute. Defaults to <code>False</code>.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments used for algorithmic separation of data at the requested field. - n_digits : int, optional - suppress_warnings : bool, optional</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>origin_file</code> <code>str</code> <p>The name of the .dat file from which the data was parsed.</p> <code>field</code> <code>float</code> <p>The field of the experiment in Oe.</p> <code>data</code> <code>pandas.DataFrame</code> <p>The data from the experiment. Columns are taken directly from the .dat file.</p> <code>scaling</code> <code>list of str</code> <p>The scaling applied to the data. If no scaling has been applied, this will be an empty list. Possible values are: <code>\"mass\"</code>, <code>\"molar\"</code>, <code>\"eicosane\"</code>, and <code>\"diamagnetic_correction\"</code>.</p> <code>temperature_range</code> <code>tuple of float</code> <p>The minimum and maximum temperature values in the data.</p> <p>Raises:</p> Type Description <code>NonMatchingFieldError</code> <p>Raised if the requested field is not in the data.</p> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>class FC(ZFCFC):\n\"\"\"A single FC experiment at a given field.\n    Parameters\n    ----------\n    dat_file : str, Path, or DatFile\n        The .dat file containing the data for the experiment.\n    field : int or float, optional\n        The magnetic field of the experiment in Oe. Requied if the .dat file contains\n        multiple uncommented experiments at different fields. If `None` and the .dat\n        file contains a single experiment, the field will be automatically detected.\n        Defaults to `None`.\n    parse_raw : bool, optional\n        If `True` and there is a corresponding .rw.dat file, the raw data will be\n        parsed and added to the `data` attribute. Defaults to `False`.\n    **kwargs : dict, optional\n        Keyword arguments used for algorithmic separation of data at the requested\n        field.\n        - n_digits : int, optional\n        - suppress_warnings : bool, optional\n    Attributes\n    ----------\n    origin_file : str\n        The name of the .dat file from which the data was parsed.\n    field : float\n        The field of the experiment in Oe.\n    data : pandas.DataFrame\n        The data from the experiment. Columns are taken directly from the .dat file.\n    scaling : list of str\n        The scaling applied to the data. If no scaling has been applied, this will be\n        an empty list. Possible values are: `\"mass\"`, `\"molar\"`, `\"eicosane\"`,\n        and `\"diamagnetic_correction\"`.\n    temperature_range : tuple of float\n        The minimum and maximum temperature values in the data.\n    Raises\n    ------\n    NonMatchingFieldError\n        Raised if the requested field is not in the data.\n    \"\"\"\ndef __init__(\nself,\ndat_file: str | Path | DatFile,\nfield: int | float | None = None,\nparse_raw: bool = False,\n**kwargs,\n) -&gt; None:\nsuper().__init__(dat_file, \"fc\", field, parse_raw, **kwargs)\n@classmethod\ndef get_all_in_file(\ncls,\ndat_file: str | Path | DatFile,\nn_digits: int = 0,\nparse_raw: bool = False,\n) -&gt; list[FC]:\nreturn super().get_all_zfcfc_in_file(dat_file, \"fc\", n_digits, parse_raw)\ndef __str__(self):\nreturn f\"FC at {self.field} Oe\"\ndef __repr__(self):\nreturn f\"FC at {self.field} Oe\"\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.plot_zfcfc","title":"<code>magnetopy.experiments.zfcfc.plot_zfcfc(zfc, fc, y_val='moment', normalized=False, colors='auto', labels='auto', title='', **kwargs)</code>","text":"<p>Plots either a single <code>ZFC</code>/<code>FC</code> pair or several on the same axes.</p> <p>Parameters:</p> Name Type Description Default <code>zfc</code> <code>ZFC | list[ZFC]</code> <p>The ZFC data to plot. Must be the same length as <code>fc</code>.</p> required <code>fc</code> <code>FC | list[FC]</code> <p>The FC data to plot. Must be the same length as <code>zfc</code>.</p> required <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>colors</code> <code>str | list[str]</code> <p>A list of colors corresponding to the <code>ZFC</code>/<code>FC</code> pairs, by default \"auto\". If \"auto\" and there is a single pair, the color will be black. If \"auto\" and there is a list of pairs with different fields, the colors will be a linear gradient from purple to green. If \"auto\" and the list of pairs is at the same field, the colors will be the default <code>matplotlib</code> colors.</p> <code>'auto'</code> <code>labels</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>ZFC</code>/<code>FC</code> pairs in the axes legend, by default \"auto\". If \"auto\", the labels will be the <code>field</code> of the <code>ZFC</code>/<code>FC</code> objects.</p> <code>'auto'</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def plot_zfcfc(\nzfc: ZFC | list[ZFC],\nfc: FC | list[FC],\ny_val: Literal[\"moment\", \"chi\", \"chi_t\"] = \"moment\",\nnormalized: bool = False,\ncolors: str | list[str] = \"auto\",\nlabels: str | list[str] | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots either a single `ZFC`/`FC` pair or several on the same axes.\n    Parameters\n    ----------\n    zfc : ZFC | list[ZFC]\n        The ZFC data to plot. Must be the same length as `fc`.\n    fc : FC | list[FC]\n        The FC data to plot. Must be the same length as `zfc`.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    colors : str | list[str], optional\n        A list of colors corresponding to the `ZFC`/`FC` pairs, by default \"auto\". If\n        \"auto\" and there is a single pair, the color will be black. If \"auto\" and\n        there is a list of pairs with different fields, the colors will be a linear\n        gradient from purple to green. If \"auto\" and the list of pairs is at the same\n        field, the colors will be the default `matplotlib` colors.\n    labels : str | list[str] | None, optional\n        The labels to assign the `ZFC`/`FC` pairs in the axes legend, by default \"auto\".\n        If \"auto\", the labels will be the `field` of the `ZFC`/`FC` objects.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\nif isinstance(zfc, list) and len(zfc) == 1:\nzfc = zfc[0]\nif isinstance(fc, list) and len(fc) == 1:\nfc = fc[0]\nif isinstance(zfc, ZFC) and isinstance(fc, FC):\nif isinstance(colors, list) or isinstance(labels, list):\nraise ValueError(\n\"If plotting a single ZFCFC, `colors` and `labels` must be a single value\"\n)\nreturn plot_single_zfcfc(\nzfc=zfc,\nfc=fc,\ny_val=y_val,\nnormalized=normalized,\ncolor=\"black\" if colors == \"auto\" else colors,\nlabel=labels,\ntitle=title,\n**kwargs,\n)\nif not isinstance(zfc, list) or not isinstance(fc, list) or (len(zfc) != len(fc)):\nraise ValueError(\"ZFC and FC must be the same length\")\nif colors != \"auto\" and not isinstance(colors, list):\nraise ValueError(\n\"If plotting multiple ZFCFC, `colors` must be a list or 'auto'.\"\n)\nif labels is not None and labels != \"auto\" and not isinstance(labels, list):\nraise ValueError(\n\"If plotting multiple ZFCFC, `labels` must be a list or 'auto' or `None`.\"\n)\nzfc.sort(key=lambda x: x.field)\nfc.sort(key=lambda x: x.field)\nfor zfc_i, fc_i in zip(zfc, fc):\nif zfc_i.field != fc_i.field:\nraise ValueError(\"ZFC and FC must have the same fields\")\nreturn plot_multiple_zfcfc(\nzfc,\nfc,\ny_val=y_val,\nnormalized=normalized,\ncolors=colors,\nlabels=labels,\ntitle=title,\n**kwargs,\n)\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.plot_single_zfcfc","title":"<code>magnetopy.experiments.zfcfc.plot_single_zfcfc(zfc, fc, y_val='moment', normalized=False, color='black', label='auto', title='', **kwargs)</code>","text":"<p>Plots a single <code>ZFC</code>/<code>FC</code> pair.</p> <p>Parameters:</p> Name Type Description Default <code>zfc</code> <code>ZFC</code> <p>The ZFC data to plot.</p> required <code>fc</code> <code>FC</code> <p>The FC data to plot.</p> required <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>color</code> <code>str | list[str]</code> <p>A list of colors corresponding to the <code>ZFC</code>/<code>FC</code> pairs, by default \"auto\". If \"auto\" and there is a single pair, the color will be black. If \"auto\" and there is a list of pairs with different fields, the colors will be a linear gradient from purple to green. If \"auto\" and the list of pairs is at the same field, the colors will be the default <code>matplotlib</code> colors.</p> <code>'black'</code> <code>label</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>ZFC/</code>FC<code>pair in the axes legend, by default \"auto\". If \"auto\", the label will be the</code>field<code>of the</code>MvsH` object.</p> <code>'auto'</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def plot_single_zfcfc(\nzfc: ZFC,\nfc: FC,\ny_val: Literal[\"moment\", \"chi\", \"chi_t\"] = \"moment\",\nnormalized: bool = False,\ncolor: str = \"black\",\nlabel: str | None = \"auto\",\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots a single `ZFC`/`FC` pair.\n    Parameters\n    ----------\n    zfc : ZFC\n        The ZFC data to plot.\n    fc : FC\n        The FC data to plot.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    color : str | list[str], optional\n        A list of colors corresponding to the `ZFC`/`FC` pairs, by default \"auto\". If\n        \"auto\" and there is a single pair, the color will be black. If \"auto\" and\n        there is a list of pairs with different fields, the colors will be a linear\n        gradient from purple to green. If \"auto\" and the list of pairs is at the same\n        field, the colors will be the default `matplotlib` colors.\n    label : str | list[str] | None, optional\n        The labels to assign the `ZFC/`FC` pair in the axes legend, by default \"auto\".\n        If \"auto\", the label will be the `field` of the `MvsH` object.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\noptions = handle_kwargs(**kwargs)\nfig, ax = plt.subplots()\nx_zfc = zfc.simplified_data()[\"temperature\"]\ny_zfc = zfc.simplified_data()[y_val]\ny_zfc = y_zfc / y_zfc.max() if normalized else y_zfc\nx_fc = fc.simplified_data()[\"temperature\"]\ny_fc = fc.simplified_data()[y_val]\ny_fc = y_fc / y_fc.max() if normalized else y_fc\nif label is None:\nax.plot(x_zfc, y_zfc, c=color, ls=\"--\")\nax.plot(x_fc, y_fc, c=color)\nelse:\nif label == \"auto\":\nif zfc.field &gt; 10000:\nlabel = f\"{(zfc.field / 10000):.0f} T\"\nelse:\nlabel = f\"{zfc.field:.0f} Oe\"\nax.plot(x_zfc, y_zfc, c=color, ls=\"--\", label=label)\nax.plot(x_fc, y_fc, c=color, label=\"\")\nax.set_xlabel(\"Temperature (K)\")\nif normalized:\nif y_val == \"moment\":\nnormalized_ylabel = \"Normalized Magnetization\"\nelif y_val == \"chi\":\nnormalized_ylabel = r\"Normalized $\\chi$\"\nelse:\nnormalized_ylabel = r\"Normalized $\\chi\\cdot$T\"\nax.set_ylabel(normalized_ylabel)\nelse:\nylabel = get_ylabel(y_val, zfc.scaling)\nax.set_ylabel(ylabel)\nhandle_options(ax, label, title, options)\nforce_aspect(ax)\nif options[\"save\"]:\nplt.savefig(\noptions[\"save\"], dpi=300, bbox_inches=\"tight\", facecolor=\"w\", edgecolor=\"w\"\n)\nreturn fig, ax\n</code></pre>"},{"location":"api/zfcfc/#magnetopy.experiments.zfcfc.plot_multiple_zfcfc","title":"<code>magnetopy.experiments.zfcfc.plot_multiple_zfcfc(zfc, fc, y_val='moment', normalized=False, colors='auto', labels=None, title='', **kwargs)</code>","text":"<p>Plots several <code>ZFC</code>/<code>FC</code> pairs on the same axes.</p> <p>Parameters:</p> Name Type Description Default <code>zfc</code> <code>list[ZFC]</code> <p>The ZFC data to plot. Must be the same length as <code>fc</code>.</p> required <code>fc</code> <code>list[FC]</code> <p>The FC data to plot. Must be the same length as <code>zfc</code>.</p> required <code>normalized</code> <code>bool</code> <p>If <code>True</code>, the magnetization will be normalized to the maximum value, by default False.</p> <code>False</code> <code>colors</code> <code>str | list[str]</code> <p>A list of colors corresponding to the <code>ZFC</code>/<code>FC</code> pairs, by default \"auto\". If \"auto\" and there is a list of pairs with different fields, the colors will be a linear gradient from purple to green. If \"auto\" and the list of pairs is at the same field, the colors will be the default <code>matplotlib</code> colors.</p> <code>'auto'</code> <code>labels</code> <code>str | list[str] | None</code> <p>The labels to assign the <code>ZFC</code>/<code>FC</code> pairs in the axes legend, by default \"auto\". If \"auto\", the labels will be the <code>field</code> of the <code>ZFC</code>/<code>FC</code> objects.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot, by default \"\".</p> <code>''</code> <code>**kwargs</code> <p>Keyword arguments mostly meant to affect the plot style. See <code>magnetopy.experiments.plot_utils.handle_options</code> for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[plt.Figure, plt.Axes]</code> Source code in <code>magnetopy\\experiments\\zfcfc.py</code> <pre><code>def plot_multiple_zfcfc(\nzfc: list[ZFC],\nfc: list[FC],\ny_val: Literal[\"moment\", \"chi\", \"chi_t\"] = \"moment\",\nnormalized: bool = False,\ncolors: list[str] | Literal[\"auto\"] = \"auto\",\nlabels: list[str] | None = None,\ntitle: str = \"\",\n**kwargs,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n\"\"\"Plots several `ZFC`/`FC` pairs on the same axes.\n    Parameters\n    ----------\n    zfc : list[ZFC]\n        The ZFC data to plot. Must be the same length as `fc`.\n    fc : list[FC]\n        The FC data to plot. Must be the same length as `zfc`.\n    normalized : bool, optional\n        If `True`, the magnetization will be normalized to the maximum value, by\n        default False.\n    colors : str | list[str], optional\n        A list of colors corresponding to the `ZFC`/`FC` pairs, by default \"auto\".\n        If \"auto\" and there is a list of pairs with different fields, the colors will\n        be a linear gradient from purple to green. If \"auto\" and the list of pairs is\n        at the same field, the colors will be the default `matplotlib` colors.\n    labels : str | list[str] | None, optional\n        The labels to assign the `ZFC`/`FC` pairs in the axes legend, by default \"auto\".\n        If \"auto\", the labels will be the `field` of the `ZFC`/`FC` objects.\n    title : str, optional\n        The title of the plot, by default \"\".\n    **kwargs\n        Keyword arguments mostly meant to affect the plot style. See\n        `magnetopy.experiments.plot_utils.handle_options` for details.\n    Returns\n    -------\n    tuple[plt.Figure, plt.Axes]\n    \"\"\"\noptions = handle_kwargs(**kwargs)\nif colors == \"auto\":\ncolors = default_colors(len(zfc))\nif _check_if_variable_field(zfc):\nzfc.sort(key=lambda x: x.field)\ncolors = linear_color_gradient(\"purple\", \"green\", len(zfc))\nif labels == \"auto\":\nlabels = [f\"{x.field:.0f} Oe\" for x in zfc]\nif labels is None:\nlabels: list[None] = [None] * len(zfc)\nfig, ax = plt.subplots()\nfor zfc_i, fc_i, color, label in zip(zfc, fc, colors, labels):\nx_zfc = zfc_i.simplified_data()[\"temperature\"]\ny_zfc = zfc_i.simplified_data()[y_val]\ny_zfc = y_zfc / y_zfc.max() if normalized else y_zfc\nx_fc = fc_i.simplified_data()[\"temperature\"]\ny_fc = fc_i.simplified_data()[y_val]\ny_fc = y_fc / y_fc.max() if normalized else y_fc\nif label:\nax.plot(x_zfc, y_zfc, c=color, ls=\"--\", label=label)\nax.plot(x_fc, y_fc, c=color, label=\"\")\nelse:\nax.plot(x_zfc, y_zfc, c=color, ls=\"--\")\nax.plot(x_fc, y_fc, c=color)\nax.set_xlabel(\"Temperature (K)\")\nif normalized:\nif y_val == \"moment\":\nnormalized_ylabel = \"Normalized Magnetization\"\nelif y_val == \"chi\":\nnormalized_ylabel = r\"Normalized $\\chi$\"\nelse:\nnormalized_ylabel = r\"Normalized $\\chi\\cdot$T\"\nax.set_ylabel(normalized_ylabel)\nelse:\nylabel = get_ylabel(y_val, zfc[0].scaling)\nax.set_ylabel(ylabel)\nhandle_options(ax, labels[0], title, options)\nforce_aspect(ax)\nif options[\"save\"]:\nplt.savefig(\noptions[\"save\"], dpi=300, bbox_inches=\"tight\", facecolor=\"w\", edgecolor=\"w\"\n)\nreturn fig, ax\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>The following examples are ordered to provide a ground-up understanding of MagnetoPy, starting with how data files are read and parsed, and ending with how to work with magnetometry datasets and perform analyses on them. Descriptions of the data files used in these examples can be found here and the files themselves are found in the tests/data directory of MagnetoPy.</p> <p>Data:</p> <ul> <li>Reading a .dat file</li> <li>Raw Data and the .rw.dat File</li> </ul> <p>Experiments:</p> <ul> <li>The <code>MvsH</code> Experiment Class</li> <li>Datasets in MagnetoPy: The <code>Magnetometry</code> Class</li> </ul> <p>Datasets:</p> <ul> <li>The MagnetoPy Dataset Class: <code>Magnetometry</code></li> </ul> <p>Analyses:</p> <ul> <li>A Simple M vs. H Analysis</li> </ul>"},{"location":"examples/file_descriptions/","title":"File descriptions","text":""},{"location":"examples/file_descriptions/#dc-measurements","title":"DC Measurements","text":""},{"location":"examples/file_descriptions/#mvsh","title":"MvsH","text":"File Measurement Nominal Fields (Oe) Nominal Temperatures (K) Comments? Description mvsh1.dat VSM -70000 - 70000 (scan) 2, 4, 6, 8, 10, 12, 300 No all temperatures contain full loops (no virgin) except 300 K, which only contains a reverse scan mvsh2.dat DC -70000 - 70000 (settle) 5, 300 No all temperatures contain full loops (no virgin) mvsh2a.dat DC -70000 - 70000 (settle) 5 No 5 K data from mvsh2.dat mvsh2b.dat DC -70000 - 70000 (settle) 300 No 300 K data from mvsh2.dat mvsh2c.dat DC -70000 - 70000 (settle) 5, 300 Yes Same as mvsh2.dat but with comments in the data section mvsh3.dat DC -70000 - 70000 (settle) 5 No full loop (no virgin); uncommon header length mvsh4.dat DC -70000 - 70000 (settle) 293 Yes full loop (no virgin) mvsh5.dat DC -70000 - 70000 (settle) 293 Yes full loop (no virgin) mvsh5.rw.dat n/a n/a n/a n/a Unprocessed data (voltage vs position) from mvsh5.dat mvsh6.dat DC -70000 - 70000 (settle) 300 No full loop (no virgin), field correction with Pd_std1.dat mvsh7.dat DC -70000 - 70000 (settle) 300 No full loop (no virgin) mvsh8.dat VSM -70000 - 70000 (scan) 2 No virgin, reverse, forward mvsh9.dat DC -70000 - 70000 (settle) 2 No virgin, reverse, forward mvsh10.dat DC -70000 - 70000 (settle) 5 No full loop (no virgin) mvsh11.dat VSM -70000 - 70000 (scan) 5 No virgin, reverse, forward Pd_std1.dat DC -70000 - 70000 (settle) 300 No full loop (no virgin)"},{"location":"examples/file_descriptions/#zfcfc","title":"ZFCFC","text":"File Measurement Nominal Fields (Oe) Nominal Temperatures (K) Comments? Description zfcfc1.dat DC 100 5 - 300 (scan) No ZFC 5 to 300 K, then temperature drop, then FC 5 to 300 K zfcfc2.dat DC 100 5 - 340 (scan) No ZFC 5 to 340 K, then temperature drop, then FC 5 to 340 K zfcfc3.dat DC 100 5 - 300 (scan) No ZFC 5 to 300 K, then FC 300 to 5 K zfc4a.dat VSM 100 5 - 310 (scan) Yes only ZFC at 100 Oe zfc4b.dat VSM 1000 5 - 310 (scan) Yes only ZFC at 1000 Oe fc4a.dat VSM 100 310 - 5 (scan) Yes only FC at 100 Oe fc4b.dat VSM 1000 310 - 5 (scan) Yes only FC at 1000 Oe zfcfc4.dat VSM 100, 1000 5 - 310 (scan) Yes combines zfc4a, fc4a, zfc4b, fc4b zfc5.dat DC 200 2 - 300 (settle) No only ZFC at 200 Oe zfc5.rw.dat n/a n/a n/a n/a Unprocessed data (voltage vs position) from zfc5.dat fc5.dat DC 200 2 - 300 (settle) No only FC at 200 Oe fc5.rw.dat n/a n/a n/a n/a Unprocessed data (voltage vs position) from fc5.dat"},{"location":"examples/file_descriptions/#mixed-files","title":"Mixed Files","text":"File Measurement Nominal Fields (Oe) Nominal Temperatures (K) Comments? Description dataset4.dat VSM, DC 100, 1000, -70k - 70k 5 - 310 (scan), 293 Yes combines zfc4a, fc4a, zfc4b, fc4b, mvsh4"},{"location":"examples/magnetometry/","title":"Datasets in MagnetoPy: The Magnetometry Class","text":"In\u00a0[1]: Copied! <pre>import json\nfrom pathlib import Path\n\nimport magnetopy as mp\n\nDATA_PATH = Path(\"../../tests/data\")\n</pre> import json from pathlib import Path  import magnetopy as mp  DATA_PATH = Path(\"../../tests/data\") In\u00a0[2]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\")\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\") <p>The default behavior sets the <code>sample_id</code> attribute to the name of the folder.</p> In\u00a0[3]: Copied! <pre>dset1.sample_id\n</pre> dset1.sample_id Out[3]: <pre>'dataset1'</pre> <p>A different <code>sample_id</code> can be passed during object construction:</p> In\u00a0[4]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\", sample_id=\"new_sample_id\")\ndset1.sample_id\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\", sample_id=\"new_sample_id\") dset1.sample_id Out[4]: <pre>'new_sample_id'</pre> <p>Since they can take a long time to process, raw data files (.rw.dat) files are ignored by default. If you need access to the raw data, pass <code>parse_raw=True</code> to the constructor.</p> In\u00a0[5]: Copied! <pre>dset2 = mp.Magnetometry(DATA_PATH / \"dataset2\")\ntry:\n    dset2.mvsh[0].plot_raw()\nexcept mp.data_files.NoRawDataError as e:\n    print(e)\n</pre> dset2 = mp.Magnetometry(DATA_PATH / \"dataset2\") try:     dset2.mvsh[0].plot_raw() except mp.data_files.NoRawDataError as e:     print(e) <pre>This DatFile object does not contain raw data.\n</pre> In\u00a0[6]: Copied! <pre>dset2 = mp.Magnetometry(DATA_PATH / \"dataset2\", parse_raw=True)\nfig, ax = dset2.mvsh[0].plot_raw()\n</pre> dset2 = mp.Magnetometry(DATA_PATH / \"dataset2\", parse_raw=True) fig, ax = dset2.mvsh[0].plot_raw() In\u00a0[7]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\")\ndset1.files\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\") dset1.files Out[7]: <pre>[DatFile(mvsh1.dat), DatFile(zfcfc1.dat)]</pre> In\u00a0[8]: Copied! <pre>dset1.mvsh\n</pre> dset1.mvsh Out[8]: <pre>[MvsH at 2 K,\n MvsH at 4 K,\n MvsH at 6 K,\n MvsH at 8 K,\n MvsH at 10 K,\n MvsH at 12 K,\n MvsH at 300 K]</pre> <p>Inspecting one of the <code>MvsH</code> objects shows which file it came from.</p> In\u00a0[9]: Copied! <pre>dset1.mvsh[0].as_dict()\n</pre> dset1.mvsh[0].as_dict() Out[9]: <pre>{'_class_': 'MvsH',\n 'origin_file': 'mvsh1.dat',\n 'temperature': 2,\n 'field_range': (-70000.35156, 70000.375),\n 'field_correction_file': '',\n 'scaling': ['molar', 'eicosane']}</pre> <p>The <code>zfc</code> and <code>fc</code> attributes are single-item lists, and we can see that the <code>ZFC</code> and <code>FC</code> objects are from the same file.</p> In\u00a0[10]: Copied! <pre>dset1.zfc[0].origin_file, dset1.fc[0].origin_file\n</pre> dset1.zfc[0].origin_file, dset1.fc[0].origin_file Out[10]: <pre>('zfcfc1.dat', 'zfcfc1.dat')</pre> In\u00a0[11]: Copied! <pre>mvsh_2k = dset1.get_mvsh(2)\nmvsh_2k.as_dict()\n</pre> mvsh_2k = dset1.get_mvsh(2) mvsh_2k.as_dict() Out[11]: <pre>{'_class_': 'MvsH',\n 'origin_file': 'mvsh1.dat',\n 'temperature': 2,\n 'field_range': (-70000.35156, 70000.375),\n 'field_correction_file': '',\n 'scaling': ['molar', 'eicosane']}</pre> In\u00a0[12]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\")\ndset1.sample_info.as_dict()\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\") dset1.sample_info.as_dict() Out[12]: <pre>{'material': '[Er(TiPS2COT)I(THF)]2',\n 'comment': 'salmon powder in eicosane',\n 'mass': 19.8,\n 'volume': None,\n 'molecular_weight': 1566.22,\n 'size': None,\n 'shape': None,\n 'holder': 'Straw',\n 'holder_detail': 'Standard',\n 'offset': 66.27,\n 'eicosane_mass': 32.4,\n 'diamagnetic_correction': 0.0,\n '_class_': 'SampleInfo'}</pre> <p>The data of the <code>MvsH</code>, <code>ZFC</code>, and <code>FC</code> objects within the dataset are automatically scaled during <code>Magnetometry</code> object creation based on 1) what information is found and placed in the <code>sample_info</code> attribute, and 2) value of the <code>magnetic_data_scaling</code> argument passed to the constructor. The default for this argument is <code>\"auto\"</code> which means that the data will be scaled based on the information found in the <code>sample_info</code> attribute. Other possible values are explained in the underlying utility function.</p> In\u00a0[13]: Copied! <pre>dset1.magnetic_data_scaling\n</pre> dset1.magnetic_data_scaling Out[13]: <pre>['auto']</pre> <p>The individual experiment objects have a <code>scaling</code> attribute to record what scaling operations were done to it.</p> In\u00a0[14]: Copied! <pre>dset1.mvsh[0].scaling\n</pre> dset1.mvsh[0].scaling Out[14]: <pre>['molar', 'eicosane']</pre> <p>We can force a dataset to have a particular scaling by passing the <code>magnetic_data_scaling</code> argument to the constructor.</p> In\u00a0[15]: Copied! <pre>dset1 = mp.Magnetometry(\n    DATA_PATH / \"dataset1\",\n    magnetic_data_scaling=\"mass\"\n)\ndset1.mvsh[0].scaling\n</pre> dset1 = mp.Magnetometry(     DATA_PATH / \"dataset1\",     magnetic_data_scaling=\"mass\" ) dset1.mvsh[0].scaling Out[15]: <pre>['mass']</pre> <p>Or we can change the scaling after <code>Magnetometry</code> object creation. For example, let's say the sample under investigation is a silica-shelled magnetite nanoparticle, and the <code>sample_info.mass</code> value represents the mass of the silica-shelled particles. We may want to use other experimental info, like TGA, to scale the data to the mass of the magnetite core. We can do this by changing the <code>sample_info.mass</code> value and then calling the <code>scale_data</code> method.</p> In\u00a0[16]: Copied! <pre>dset3 = mp.Magnetometry(DATA_PATH / \"dataset3\")\ndset3.mvsh[0].simplified_data()['moment'].max()\n</pre> dset3 = mp.Magnetometry(DATA_PATH / \"dataset3\") dset3.mvsh[0].simplified_data()['moment'].max() Out[16]: <pre>70.7594230969757</pre> In\u00a0[17]: Copied! <pre>dset3.mvsh[0].scaling\n</pre> dset3.mvsh[0].scaling Out[17]: <pre>['mass']</pre> <p>So the as-read saturation magnetization from that M vs. H experiment is 70.8 emu/g. Now we can scale the data to the mass of the magnetite core.</p> In\u00a0[18]: Copied! <pre>dset3.sample_info.mass = dset3.sample_info.mass * 0.75\ndset3.scale_dc_data()\ndset3.mvsh[0].simplified_data()['moment'].max()\n</pre> dset3.sample_info.mass = dset3.sample_info.mass * 0.75 dset3.scale_dc_data() dset3.mvsh[0].simplified_data()['moment'].max() Out[18]: <pre>94.34589746263427</pre> In\u00a0[19]: Copied! <pre>dset3_uncorrected = mp.Magnetometry(DATA_PATH / \"dataset3\")\ndset3_corrected = mp.Magnetometry(\n    DATA_PATH / \"dataset3\",\n    true_field_correction=\"sequence_1\"\n)\n\nfig, ax = mp.plot_mvsh(\n    [\n        dset3_uncorrected.mvsh[0],\n        dset3_corrected.mvsh[0],\n    ],\n    normalized=True,\n    labels=[\n        \"Uncorrected\",\n        \"Corrected\",\n    ],\n    xlim = (-0.025, 0.025),\n    ylim = (-0.5, 0.5),\n)\n</pre> dset3_uncorrected = mp.Magnetometry(DATA_PATH / \"dataset3\") dset3_corrected = mp.Magnetometry(     DATA_PATH / \"dataset3\",     true_field_correction=\"sequence_1\" )  fig, ax = mp.plot_mvsh(     [         dset3_uncorrected.mvsh[0],         dset3_corrected.mvsh[0],     ],     normalized=True,     labels=[         \"Uncorrected\",         \"Corrected\",     ],     xlim = (-0.025, 0.025),     ylim = (-0.5, 0.5), )  In\u00a0[20]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\")\nfig, ax = dset1.plot_mvsh()\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\") fig, ax = dset1.plot_mvsh() <p>Now removing the 300 K experiment from the plot:</p> In\u00a0[21]: Copied! <pre>fig, ax = dset1.plot_mvsh([2, 4, 6, 8, 10, 12])\n</pre> fig, ax = dset1.plot_mvsh([2, 4, 6, 8, 10, 12]) In\u00a0[22]: Copied! <pre>dset3 = mp.Magnetometry(DATA_PATH / \"dataset3\")\nfig, ax = dset3.plot_zfcfc()\n</pre> dset3 = mp.Magnetometry(DATA_PATH / \"dataset3\") fig, ax = dset3.plot_zfcfc() <p>The <code>fields</code> argument can be used to filter the experiments to be plotted based on their nominal field.</p> In\u00a0[23]: Copied! <pre>fig, ax = dset3.plot_zfcfc(fields=[100])\n</pre> fig, ax = dset3.plot_zfcfc(fields=[100]) <p>The <code>y_val</code> argument changes the units of the y-axis. The default is <code>\"moment\"</code>; <code>\"chi\"</code> and <code>\"chi_t\"</code> are also available.</p> In\u00a0[24]: Copied! <pre>dset4 = mp.Magnetometry(DATA_PATH / \"dataset4\")\nfig, ax = dset4.plot_zfcfc(y_val=\"chi_t\")\n</pre> dset4 = mp.Magnetometry(DATA_PATH / \"dataset4\") fig, ax = dset4.plot_zfcfc(y_val=\"chi_t\") In\u00a0[25]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\")\nfig, ax = dset1.plot_mvsh()\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\") fig, ax = dset1.plot_mvsh() <p>Now let's make a list of <code>SimpleMvsHAnalysis</code> objects for each of the <code>MvsH</code> experiments in the dataset.</p> In\u00a0[26]: Copied! <pre>analyses: list[mp.SimpleMvsHAnalysis] = []\nfor mvsh in dset1.mvsh:\n    temperature = mvsh.temperature\n    analysis = mp.SimpleMvsHAnalysis(\n        dataset = dset1,\n        parsing_args = mp.SimpleMvsHAnalysisParsingArgs(\n            temperature = temperature,\n            segments = \"auto\",\n        ),\n    )\n    analyses.append(analysis)\n</pre> analyses: list[mp.SimpleMvsHAnalysis] = [] for mvsh in dset1.mvsh:     temperature = mvsh.temperature     analysis = mp.SimpleMvsHAnalysis(         dataset = dset1,         parsing_args = mp.SimpleMvsHAnalysisParsingArgs(             temperature = temperature,             segments = \"auto\",         ),     )     analyses.append(analysis) <p>We can inspect the first <code>SimpleMvsHAnalysis</code> object to see what information it contains.</p> In\u00a0[27]: Copied! <pre>analyses[0].as_dict()\n</pre> analyses[0].as_dict() Out[27]: <pre>{'_class_': 'SimpleMvsHAnalysis',\n 'mvsh': MvsH at 2 K,\n 'parsing_args': SimpleMvsHAnalysisParsingArgs(temperature=2, segments='auto'),\n 'results': SimpleMvsHAnalysisResults(m_s=10.467101768993821, h_c=4501.3806155, m_r=8.573807168964388, moment_units='bohr magnetons/mol', field_units='Oe', segments=['forward', 'reverse'])}</pre> <p>Note how the <code>MvsH</code> object appears when converted to json. Someone reading a file containing the json representation of the <code>SimpleMvsHAnalysis</code> object would have access to:</p> <ul> <li>the input data: the name of the file from which the data was read, the temperature of the experiment, the scaling applied to the data (in this case a molar scaling with a correction for the eicosane matrix)</li> <li>the parsing arguments: in this case the temperature used to select the proper <code>MvsH</code> object from the dataset and the method in which segments of the M vs. H experiment were selected for analysis (in this case <code>\"auto\"</code>, meaning that the analysis will use forward and/or reverse scans depending on availability)</li> <li>the results of the the analysis: this include the actual values along with units and a list of analyzed segments</li> </ul> In\u00a0[28]: Copied! <pre>print(json.dumps(analyses[0].as_dict(), indent=4, default=(lambda x: x.as_dict())))\n</pre> print(json.dumps(analyses[0].as_dict(), indent=4, default=(lambda x: x.as_dict()))) <pre>{\n    \"_class_\": \"SimpleMvsHAnalysis\",\n    \"mvsh\": {\n        \"_class_\": \"MvsH\",\n        \"origin_file\": \"mvsh1.dat\",\n        \"temperature\": 2,\n        \"field_range\": [\n            -70000.35156,\n            70000.375\n        ],\n        \"field_correction_file\": \"\",\n        \"scaling\": [\n            \"molar\",\n            \"eicosane\"\n        ]\n    },\n    \"parsing_args\": {\n        \"temperature\": 2,\n        \"segments\": \"auto\",\n        \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n    },\n    \"results\": {\n        \"m_s\": 10.467101768993821,\n        \"h_c\": 4501.3806155,\n        \"m_r\": 8.573807168964388,\n        \"moment_units\": \"bohr magnetons/mol\",\n        \"field_units\": \"Oe\",\n        \"segments\": [\n            \"forward\",\n            \"reverse\"\n        ],\n        \"_class_\": \"SimpleMvsHAnalysisResults\"\n    }\n}\n</pre> <p>All of the analyses can be added to the <code>Magnetometry</code> object using the <code>add_analysis()</code> method.</p> In\u00a0[29]: Copied! <pre>dset1.add_analysis(analyses)\n</pre> dset1.add_analysis(analyses) <p>When we're finished working on this dataset, we can serialize the <code>Magnetometry</code> object to a json file using the <code>create_report()</code> method. The report can be viewed here (it may help to install a json viewer extension for your browser, like this one for Chrome).</p> In\u00a0[30]: Copied! <pre>dset1.create_report(\".\")\n</pre> dset1.create_report(\".\") <pre>Report written to dataset1.json\n</pre> <p>Alternatively, here is the json representation of the <code>Magnetometry</code> object as printed in the notebook:</p> In\u00a0[31]: Copied! <pre>print(dset1.as_json(indent=4))\n</pre> print(dset1.as_json(indent=4)) <pre>{\n    \"_class_\": \"Magnetometry\",\n    \"sample_id\": \"dataset1\",\n    \"files\": [\n        {\n            \"_class_\": \"DatFile\",\n            \"experiment_type\": \"magnetometry\",\n            \"local_path\": \"..\\\\..\\\\tests\\\\data\\\\dataset1\\\\mvsh1.dat\",\n            \"length\": 2612152,\n            \"date_created\": \"2020-07-11T11:07:00\",\n            \"sha512\": \"6fc436762a00b890eb3649eb50a885ced587781bf3b9738f04a49e768ad471f1671110f282e7be2ac2ed623a006abcc2da3914e09c165276b4bd63e06760b28f\",\n            \"experiments_in_file\": [\n                \"mvsh\"\n            ]\n        },\n        {\n            \"_class_\": \"DatFile\",\n            \"experiment_type\": \"magnetometry\",\n            \"local_path\": \"..\\\\..\\\\tests\\\\data\\\\dataset1\\\\zfcfc1.dat\",\n            \"length\": 261932,\n            \"date_created\": \"2021-09-18T19:46:00\",\n            \"sha512\": \"f7cd14ea7ca9f3245780a608808b497b484f744774dd456a54dab73ef507a8aa75bd2383bc446af89b6aa5b57393b5f8773f77227d2e5fa5b8953980899ea64e\",\n            \"experiments_in_file\": [\n                \"zfcfc\"\n            ]\n        }\n    ],\n    \"sample_info\": {\n        \"material\": \"[Er(TiPS2COT)I(THF)]2\",\n        \"comment\": \"salmon powder in eicosane\",\n        \"mass\": 19.8,\n        \"volume\": null,\n        \"molecular_weight\": 1566.22,\n        \"size\": null,\n        \"shape\": null,\n        \"holder\": \"Straw\",\n        \"holder_detail\": \"Standard\",\n        \"offset\": 66.27,\n        \"eicosane_mass\": 32.4,\n        \"diamagnetic_correction\": 0.0,\n        \"_class_\": \"SampleInfo\"\n    },\n    \"mvsh\": [\n        {\n            \"_class_\": \"MvsH\",\n            \"origin_file\": \"mvsh1.dat\",\n            \"temperature\": 2,\n            \"field_range\": [\n                -70000.35156,\n                70000.375\n            ],\n            \"field_correction_file\": \"\",\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        },\n        {\n            \"_class_\": \"MvsH\",\n            \"origin_file\": \"mvsh1.dat\",\n            \"temperature\": 4,\n            \"field_range\": [\n                -70000.28125,\n                70000.28906\n            ],\n            \"field_correction_file\": \"\",\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        },\n        {\n            \"_class_\": \"MvsH\",\n            \"origin_file\": \"mvsh1.dat\",\n            \"temperature\": 6,\n            \"field_range\": [\n                -70000.26563,\n                70000.41406\n            ],\n            \"field_correction_file\": \"\",\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        },\n        {\n            \"_class_\": \"MvsH\",\n            \"origin_file\": \"mvsh1.dat\",\n            \"temperature\": 8,\n            \"field_range\": [\n                -70000.27344,\n                70000.375\n            ],\n            \"field_correction_file\": \"\",\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        },\n        {\n            \"_class_\": \"MvsH\",\n            \"origin_file\": \"mvsh1.dat\",\n            \"temperature\": 10,\n            \"field_range\": [\n                -70000.3125,\n                70000.46094\n            ],\n            \"field_correction_file\": \"\",\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        },\n        {\n            \"_class_\": \"MvsH\",\n            \"origin_file\": \"mvsh1.dat\",\n            \"temperature\": 12,\n            \"field_range\": [\n                -70000.38672,\n                70000.35156\n            ],\n            \"field_correction_file\": \"\",\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        },\n        {\n            \"_class_\": \"MvsH\",\n            \"origin_file\": \"mvsh1.dat\",\n            \"temperature\": 300,\n            \"field_range\": [\n                -70000.16406,\n                69999.8125\n            ],\n            \"field_correction_file\": \"\",\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        }\n    ],\n    \"zfc\": [\n        {\n            \"_class_\": \"ZFC\",\n            \"origin_file\": \"zfcfc1.dat\",\n            \"field\": 100,\n            \"temperature_range\": [\n                5.00255632400513,\n                299.939453125\n            ],\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        }\n    ],\n    \"fc\": [\n        {\n            \"_class_\": \"FC\",\n            \"origin_file\": \"zfcfc1.dat\",\n            \"field\": 100,\n            \"temperature_range\": [\n                5.00277781486511,\n                299.924865722656\n            ],\n            \"scaling\": [\n                \"molar\",\n                \"eicosane\"\n            ]\n        }\n    ],\n    \"analyses\": [\n        {\n            \"_class_\": \"SimpleMvsHAnalysis\",\n            \"mvsh\": {\n                \"_class_\": \"MvsH\",\n                \"origin_file\": \"mvsh1.dat\",\n                \"temperature\": 2,\n                \"field_range\": [\n                    -70000.35156,\n                    70000.375\n                ],\n                \"field_correction_file\": \"\",\n                \"scaling\": [\n                    \"molar\",\n                    \"eicosane\"\n                ]\n            },\n            \"parsing_args\": {\n                \"temperature\": 2,\n                \"segments\": \"auto\",\n                \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n            },\n            \"results\": {\n                \"m_s\": 10.467101768993821,\n                \"h_c\": 4501.3806155,\n                \"m_r\": 8.573807168964388,\n                \"moment_units\": \"bohr magnetons/mol\",\n                \"field_units\": \"Oe\",\n                \"segments\": [\n                    \"forward\",\n                    \"reverse\"\n                ],\n                \"_class_\": \"SimpleMvsHAnalysisResults\"\n            }\n        },\n        {\n            \"_class_\": \"SimpleMvsHAnalysis\",\n            \"mvsh\": {\n                \"_class_\": \"MvsH\",\n                \"origin_file\": \"mvsh1.dat\",\n                \"temperature\": 4,\n                \"field_range\": [\n                    -70000.28125,\n                    70000.28906\n                ],\n                \"field_correction_file\": \"\",\n                \"scaling\": [\n                    \"molar\",\n                    \"eicosane\"\n                ]\n            },\n            \"parsing_args\": {\n                \"temperature\": 4,\n                \"segments\": \"auto\",\n                \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n            },\n            \"results\": {\n                \"m_s\": 9.449626372913347,\n                \"h_c\": 3502.3714600000003,\n                \"m_r\": 4.485387018934844,\n                \"moment_units\": \"bohr magnetons/mol\",\n                \"field_units\": \"Oe\",\n                \"segments\": [\n                    \"forward\",\n                    \"reverse\"\n                ],\n                \"_class_\": \"SimpleMvsHAnalysisResults\"\n            }\n        },\n        {\n            \"_class_\": \"SimpleMvsHAnalysis\",\n            \"mvsh\": {\n                \"_class_\": \"MvsH\",\n                \"origin_file\": \"mvsh1.dat\",\n                \"temperature\": 6,\n                \"field_range\": [\n                    -70000.26563,\n                    70000.41406\n                ],\n                \"field_correction_file\": \"\",\n                \"scaling\": [\n                    \"molar\",\n                    \"eicosane\"\n                ]\n            },\n            \"parsing_args\": {\n                \"temperature\": 6,\n                \"segments\": \"auto\",\n                \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n            },\n            \"results\": {\n                \"m_s\": 9.318969635074463,\n                \"h_c\": 1502.0551759999998,\n                \"m_r\": 1.2358785164429205,\n                \"moment_units\": \"bohr magnetons/mol\",\n                \"field_units\": \"Oe\",\n                \"segments\": [\n                    \"forward\",\n                    \"reverse\"\n                ],\n                \"_class_\": \"SimpleMvsHAnalysisResults\"\n            }\n        },\n        {\n            \"_class_\": \"SimpleMvsHAnalysis\",\n            \"mvsh\": {\n                \"_class_\": \"MvsH\",\n                \"origin_file\": \"mvsh1.dat\",\n                \"temperature\": 8,\n                \"field_range\": [\n                    -70000.27344,\n                    70000.375\n                ],\n                \"field_correction_file\": \"\",\n                \"scaling\": [\n                    \"molar\",\n                    \"eicosane\"\n                ]\n            },\n            \"parsing_args\": {\n                \"temperature\": 8,\n                \"segments\": \"auto\",\n                \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n            },\n            \"results\": {\n                \"m_s\": 9.225003160337351,\n                \"h_c\": 355.58299255,\n                \"m_r\": 0.16487528361326864,\n                \"moment_units\": \"bohr magnetons/mol\",\n                \"field_units\": \"Oe\",\n                \"segments\": [\n                    \"forward\",\n                    \"reverse\"\n                ],\n                \"_class_\": \"SimpleMvsHAnalysisResults\"\n            }\n        },\n        {\n            \"_class_\": \"SimpleMvsHAnalysis\",\n            \"mvsh\": {\n                \"_class_\": \"MvsH\",\n                \"origin_file\": \"mvsh1.dat\",\n                \"temperature\": 10,\n                \"field_range\": [\n                    -70000.3125,\n                    70000.46094\n                ],\n                \"field_correction_file\": \"\",\n                \"scaling\": [\n                    \"molar\",\n                    \"eicosane\"\n                ]\n            },\n            \"parsing_args\": {\n                \"temperature\": 10,\n                \"segments\": \"auto\",\n                \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n            },\n            \"results\": {\n                \"m_s\": 9.006286086184483,\n                \"h_c\": 1.338294357,\n                \"m_r\": 0.0183848844463972,\n                \"moment_units\": \"bohr magnetons/mol\",\n                \"field_units\": \"Oe\",\n                \"segments\": [\n                    \"forward\",\n                    \"reverse\"\n                ],\n                \"_class_\": \"SimpleMvsHAnalysisResults\"\n            }\n        },\n        {\n            \"_class_\": \"SimpleMvsHAnalysis\",\n            \"mvsh\": {\n                \"_class_\": \"MvsH\",\n                \"origin_file\": \"mvsh1.dat\",\n                \"temperature\": 12,\n                \"field_range\": [\n                    -70000.38672,\n                    70000.35156\n                ],\n                \"field_correction_file\": \"\",\n                \"scaling\": [\n                    \"molar\",\n                    \"eicosane\"\n                ]\n            },\n            \"parsing_args\": {\n                \"temperature\": 12,\n                \"segments\": \"auto\",\n                \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n            },\n            \"results\": {\n                \"m_s\": 8.874340922463201,\n                \"h_c\": 7.7792181970000005,\n                \"m_r\": 0.0022978985335177027,\n                \"moment_units\": \"bohr magnetons/mol\",\n                \"field_units\": \"Oe\",\n                \"segments\": [\n                    \"forward\",\n                    \"reverse\"\n                ],\n                \"_class_\": \"SimpleMvsHAnalysisResults\"\n            }\n        },\n        {\n            \"_class_\": \"SimpleMvsHAnalysis\",\n            \"mvsh\": {\n                \"_class_\": \"MvsH\",\n                \"origin_file\": \"mvsh1.dat\",\n                \"temperature\": 300,\n                \"field_range\": [\n                    -70000.16406,\n                    69999.8125\n                ],\n                \"field_correction_file\": \"\",\n                \"scaling\": [\n                    \"molar\",\n                    \"eicosane\"\n                ]\n            },\n            \"parsing_args\": {\n                \"temperature\": 300,\n                \"segments\": \"auto\",\n                \"_class_\": \"SimpleMvsHAnalysisParsingArgs\"\n            },\n            \"results\": {\n                \"m_s\": 0.9941340745856104,\n                \"h_c\": 4.778749943,\n                \"m_r\": 0.0009569688499523988,\n                \"moment_units\": \"bohr magnetons/mol\",\n                \"field_units\": \"Oe\",\n                \"segments\": [\n                    \"reverse\"\n                ],\n                \"_class_\": \"SimpleMvsHAnalysisResults\"\n            }\n        }\n    ]\n}\n</pre>"},{"location":"examples/magnetometry/#datasets-in-magnetopy-the-magnetometry-class","title":"Datasets in MagnetoPy: The <code>Magnetometry</code> Class\u00b6","text":"<p>The <code>Magnetometry</code> class contains magnetometry data for a single sample along with methods for parsing, processing, and analyzing the data. Note that \"single sample\" means that in situations in which a single material is measured in multiple samples, each sample should be treated as a separate <code>Magnetometry</code> object.</p>"},{"location":"examples/magnetometry/#creating-a-magnetometry-object","title":"Creating a <code>Magnetometry</code> Object\u00b6","text":"<p>To create a <code>Magnetometry</code> object, simply pass the path of the folder which contains all of the data files for the sample.</p>"},{"location":"examples/magnetometry/#files-and-experiments","title":"Files and Experiments\u00b6","text":"<p>For now we'll focus on the attributes <code>files</code>, <code>mvsh</code>, <code>zfc</code>, and <code>fc</code>. <code>files</code> contains a list of the data files comprising the dataset. The latter three contain lists of the <code>MvsH</code>, <code>ZFC</code>, and <code>FC</code> objects, respectively, which were found within the dataset's files.</p> <p>For example, the following dataset, <code>dset1</code>, has several <code>MvsH</code> experiments found within one file, and a single \"zfcfc\" file which is separated into <code>ZFC</code> and <code>FC</code> experiments:</p>"},{"location":"examples/magnetometry/#experiment-getter-methods","title":"Experiment Getter Methods\u00b6","text":"<p>The <code>get_mvsh()</code>, <code>get_zfc()</code>, and <code>get_fc()</code> are convenience methods for accessing specific experiment objects based on nominal values of temperature or field. For example, <code>dset1</code> contains several <code>MvsH</code> experiments at various temperatures, and we can access the one at 2 K using the <code>get_mvsh()</code> method:</p>"},{"location":"examples/magnetometry/#sample-info-and-scaling-data","title":"Sample Info and Scaling Data\u00b6","text":"<p>The <code>sample_info</code> attribute of <code>Magnetometry</code> objects contains information about the sample stored as a <code>SampleInfo</code> object. It's assumed that all files within the dataset are for the same sample, so the <code>sample_info</code> data is extracted from the header of the first file in the dataset.</p>"},{"location":"examples/magnetometry/#correcting-the-field-in-mvsh-objects-for-flux-trapping","title":"Correcting the Field in <code>MvsH</code> Objects for Flux Trapping\u00b6","text":"<p>As discussed on the <code>MvsH</code> example page, the field in <code>MvsH</code> objects can be corrected for flux trapping by calling the <code>MvsH.correct_field()</code> method with the path to a file containing the Pd field calibration data. The <code>Magnetometry</code> class provides a convenience method for this, as it is likely that all <code>MvsH</code> objects within a dataset will be collected with the same sequence of field values.</p> <p>The field correction can be applied during object creation by passing the <code>true_field_correction</code> argument to the constructor -- as with <code>MvsH.correct_field()</code>, this argument can be the path of the standard file or, as shown below, the name of the sequence defined in the user's Standard Calibration Library.</p>"},{"location":"examples/magnetometry/#plotting","title":"Plotting\u00b6","text":"<p>The <code>Magnetometry</code> class has some convenience methods for plotting all of the <code>MvsH</code> and <code>ZFC</code>/<code>FC</code> pairs within the dataset.</p>"},{"location":"examples/magnetometry/#m-vs-h","title":"M vs. H\u00b6","text":"<p><code>Magnetometry.plot_mvsh()</code> works much the same as was described in the <code>MvsH</code> tutorial, but has an additional argument <code>temperatures</code> which filters the experiments to be plotted based on their nominal temperature.</p>"},{"location":"examples/magnetometry/#zfcfc","title":"ZFC/FC\u00b6","text":"<p><code>Magnetometry.plot_zfcfc()</code> plots all of the pairs of <code>ZFC</code> and <code>FC</code> experiments within the dataset.</p>"},{"location":"examples/magnetometry/#analyses-and-serialization","title":"Analyses and Serialization\u00b6","text":"<p>Perhaps the most important aspect of MagnetoPy is the modular nature in which analyses can be developed and the way in which the results of those analyses can be serialized and shared. When publishing the results of an analysis of any scientific data, it is important that future readers, reviewers, and researchers have all of the information necessary to reproduce the analysis, going from the raw data to the final values and figures presented in the paper.</p> <p>The next example notebook will explain how to create <code>Analysis</code> classes. For now, we will take a simple example class and use it to demonstrate how analyses can be performed on <code>Magnetometry</code> objects and how the results can be serialized and stored.</p> <p>The <code>SimpleMvsHAnalysis</code> class takes a <code>Magnetometry</code> object and a temperature and returns basic information about the <code>MvsH</code> experiment at that temperature (e.g., the saturation magnetization and coercivity).</p> <p>The following <code>Magnetometry</code> object has several <code>MvsH</code> experiments at various temperatures.</p>"},{"location":"examples/mvsh/","title":"The MvsH Experiment Class","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport matplotlib.pyplot as plt\n\nimport magnetopy as mp\n\nDATA_PATH = Path(\"../../tests/data\")\n</pre> from pathlib import Path  import matplotlib.pyplot as plt  import magnetopy as mp  DATA_PATH = Path(\"../../tests/data\") In\u00a0[2]: Copied! <pre>mvsh4 = mp.MvsH(DATA_PATH / \"mvsh4.dat\")\nmvsh4\n</pre> mvsh4 = mp.MvsH(DATA_PATH / \"mvsh4.dat\") mvsh4 Out[2]: <pre>MvsH at 293.0 K</pre> <p>The <code>as_dict()</code> method returns a dictionary of information about the experiment and any processing that has been performed on it. Note that these are all attributes of the <code>MvsH</code> object, and can be accessed directly as well.</p> <p>Since we just created this object and haven't done any processing, the <code>field_correction_file</code> and <code>scaling</code> attributes will be empty.</p> In\u00a0[3]: Copied! <pre>mvsh4.as_dict()\n</pre> mvsh4.as_dict() Out[3]: <pre>{'origin_file': 'mvsh4.dat',\n 'temperature': 293.0,\n 'field_range': (-70000.375, 70000.3359375),\n 'field_correction_file': '',\n 'scaling': []}</pre> <p>The data is stored in the <code>data</code> attribute. The columns of this <code>DataFrame</code> are created directly from the data file which, in this case, is a .dat file from a Quantum Design MPMS3. There are two additional columns at the end, <code>\"uncorrected_moment\"</code> and <code>\"uncorrected_moment_err\"</code>. The .dat file contains the magnetization data in one of two columns, depending on whether the measurements were done in DC or VSM mode. The <code>MvsH</code> class automatically determines which column contains the data, and stores it in the <code>\"uncorrected_moment\"</code> and <code>\"uncorrected_moment_err\"</code> columns, which are used for subsequent processing.</p> In\u00a0[4]: Copied! <pre>mvsh4.data.head()\n</pre> mvsh4.data.head() Out[4]: Comment Time Stamp (sec) Temperature (K) Magnetic Field (Oe) Moment (emu) M. Std. Err. (emu) Transport Action Averaging Time (sec) Frequency (Hz) Peak Amplitude (mm) ... Map 09 Map 10 Map 11 Map 12 Map 13 Map 14 Map 15 Map 16 uncorrected_moment uncorrected_moment_err 0 NaN 3.860780e+09 293.223587 -70000.000000 NaN NaN 6.0 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN -0.004099 0.000208 1 NaN 3.860780e+09 293.209259 -65000.421875 NaN NaN 6.0 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN -0.004110 0.000209 2 NaN 3.860780e+09 293.174545 -60000.355469 NaN NaN 6.0 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN -0.004117 0.000208 3 NaN 3.860780e+09 293.203033 -55000.378906 NaN NaN 6.0 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN -0.004117 0.000208 4 NaN 3.860780e+09 293.191849 -50000.183594 NaN NaN 6.0 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN -0.004120 0.000208 <p>5 rows \u00d7 91 columns</p> In\u00a0[5]: Copied! <pre>try:\n    mvsh1 = mp.MvsH(DATA_PATH / \"mvsh1.dat\")\nexcept mp.experiments.mvsh.TemperatureDetectionError as e:\n    print(e)\n</pre> try:     mvsh1 = mp.MvsH(DATA_PATH / \"mvsh1.dat\") except mp.experiments.mvsh.TemperatureDetectionError as e:     print(e) <pre>Auto-parsing of MvsH objects from DatFile objects requires that there be only one temperature in the data. Found 7 temperatures.\n</pre> <p>In this case we'll need to pass the temperature of our desired experiment to the constructor:</p> In\u00a0[6]: Copied! <pre>mvsh1_2k = mp.MvsH(DATA_PATH / \"mvsh1.dat\", temperature=2)\nmvsh1_2k.as_dict()\n</pre> mvsh1_2k = mp.MvsH(DATA_PATH / \"mvsh1.dat\", temperature=2) mvsh1_2k.as_dict() Out[6]: <pre>{'origin_file': 'mvsh1.dat',\n 'temperature': 2,\n 'field_range': (-70000.35156, 70000.375),\n 'field_correction_file': '',\n 'scaling': []}</pre> In\u00a0[7]: Copied! <pre>mvsh1 = mp.MvsH.get_all_in_file(DATA_PATH / \"mvsh1.dat\")\nfor mvsh in mvsh1:\n    print(mvsh)\n</pre> mvsh1 = mp.MvsH.get_all_in_file(DATA_PATH / \"mvsh1.dat\") for mvsh in mvsh1:     print(mvsh) <pre>MvsH at 2 K\nMvsH at 4 K\nMvsH at 6 K\nMvsH at 8 K\nMvsH at 10 K\nMvsH at 12 K\nMvsH at 300 K\n</pre> <p>This also works for files containing a single experiment, you'll just get a list with a single <code>MvsH</code> object in it.</p> In\u00a0[8]: Copied! <pre>mvsh4_list = mp.MvsH.get_all_in_file(DATA_PATH / \"mvsh4.dat\")\nfor mvsh in mvsh4_list:\n    print(mvsh)\n</pre> mvsh4_list = mp.MvsH.get_all_in_file(DATA_PATH / \"mvsh4.dat\") for mvsh in mvsh4_list:     print(mvsh) <pre>MvsH at 293.0 K\n</pre> <p>The columns given from the data file are likely more than we'll need for 98% of what we typically do with the data. Additionally, when MagnetoPy supports other file types from other instruments, we'll still want a standard interface upon which we can build anlayses and visualization methods. The <code>simplified_data()</code> method returns a <code>DataFrame</code> with only the relevant columns for an <code>MvsH</code> experiment:</p> In\u00a0[9]: Copied! <pre>mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\")\nmvsh11.simplified_data().head()\n</pre> mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\") mvsh11.simplified_data().head() Out[9]: time temperature field moment moment_err chi chi_err chi_t chi_t_err 0 3.886899e+09 4.999953 0.085553 -0.000045 6.638709e-07 -5.310496e-04 7.759755e-06 -2.655223e-03 3.879841e-05 1 3.886899e+09 4.999861 0.109997 -0.000046 1.130964e-06 -4.146267e-04 1.028179e-05 -2.073076e-03 5.140751e-05 2 3.886899e+09 4.999944 108.469070 -0.000148 2.639004e-05 -1.364675e-06 2.432955e-07 -6.823298e-06 1.216464e-06 3 3.886899e+09 4.999876 204.471832 0.000009 9.156850e-06 4.402288e-08 4.478294e-08 2.201089e-07 2.239092e-07 4 3.886899e+09 4.999945 300.352386 0.000246 1.018018e-05 8.198379e-07 3.389411e-08 4.099144e-06 1.694687e-07 <p>In this case we haven't done any scaling or processing, so the values of the <code>\"moment\"</code> and <code>\"moment_err\"</code> columns are the same as the values in the previously mentioned <code>\"uncorrected_moment\"</code> and <code>\"uncorrected_moment_err\"</code> columns. We'll see how to scale the data in the next section.</p> <p>Looking at the values of magnetic fields in the data, we can see that this experiment consists of a virgin, forward, and reverse scans:</p> In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots()\nx = mvsh11.simplified_data()[\"field\"] / 10000\ny = mvsh11.simplified_data()[\"moment\"]\nax.plot(x, y)\nax.set_xlabel(\"Field (T)\")\nax.set_ylabel(\"Moment (emu)\")\nmp.force_aspect(ax) # a plot utility function in Magnetopy\nplt.show()\n</pre> fig, ax = plt.subplots() x = mvsh11.simplified_data()[\"field\"] / 10000 y = mvsh11.simplified_data()[\"moment\"] ax.plot(x, y) ax.set_xlabel(\"Field (T)\") ax.set_ylabel(\"Moment (emu)\") mp.force_aspect(ax) # a plot utility function in Magnetopy plt.show() <p>For some analyses and/or visualizations, we may only want to work with a single segment of the data. <code>simplified_data()</code> has an optional <code>segment</code> argument that can be used to return only a single segment of the data. Available segments are: <code>\"virgin\"</code>, <code>\"forward\"</code>, <code>\"reverse\"</code>, and <code>\"loop\"</code> (i.e., <code>\"forward\"</code> + <code>\"reverse\"</code>).</p> In\u00a0[11]: Copied! <pre>mvsh11.simplified_data(segment=\"reverse\").head()\n</pre> mvsh11.simplified_data(segment=\"reverse\").head() Out[11]: time temperature field moment moment_err chi chi_err chi_t chi_t_err 0 3.886900e+09 4.999997 70000.460938 0.408538 0.000393 0.000006 5.613738e-09 0.000029 2.806867e-08 1 3.886900e+09 5.000016 69999.851562 0.408824 0.000408 0.000006 5.821657e-09 0.000029 2.910838e-08 2 3.886900e+09 4.999962 69890.496094 0.408390 0.000389 0.000006 5.566526e-09 0.000029 2.783242e-08 3 3.886900e+09 5.000044 69798.500000 0.408776 0.000429 0.000006 6.151053e-09 0.000029 3.075553e-08 4 3.886900e+09 4.999870 69694.355469 0.408636 0.000383 0.000006 5.491631e-09 0.000029 2.745745e-08 In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots()\nx1 = mvsh11.simplified_data(segment=\"virgin\")[\"field\"] / 10000\ny1 = mvsh11.simplified_data(segment=\"virgin\")[\"moment\"]\nx2 = mvsh11.simplified_data(segment=\"reverse\")[\"field\"] / 10000\ny2 = mvsh11.simplified_data(segment=\"reverse\")[\"moment\"]\nx3 = mvsh11.simplified_data(segment=\"forward\")[\"field\"] / 10000\ny3 = mvsh11.simplified_data(segment=\"forward\")[\"moment\"]\nx4 = mvsh11.simplified_data(segment=\"loop\")[\"field\"] / 10000\ny4 = mvsh11.simplified_data(segment=\"loop\")[\"moment\"]\nax.plot(x1, y1, label=\"virgin\")\nax.plot(x2, y2, label=\"reverse\")\nax.plot(x3, y3, label=\"forward\")\nax.plot(x4, y4, label=\"loop\", linewidth=4, zorder=-1, c=\"black\")\nax.set_xlabel(\"Field (T)\")\nax.set_ylabel(\"Moment (emu)\")\nax.legend()\nmp.force_aspect(ax)\nplt.show()\n</pre> fig, ax = plt.subplots() x1 = mvsh11.simplified_data(segment=\"virgin\")[\"field\"] / 10000 y1 = mvsh11.simplified_data(segment=\"virgin\")[\"moment\"] x2 = mvsh11.simplified_data(segment=\"reverse\")[\"field\"] / 10000 y2 = mvsh11.simplified_data(segment=\"reverse\")[\"moment\"] x3 = mvsh11.simplified_data(segment=\"forward\")[\"field\"] / 10000 y3 = mvsh11.simplified_data(segment=\"forward\")[\"moment\"] x4 = mvsh11.simplified_data(segment=\"loop\")[\"field\"] / 10000 y4 = mvsh11.simplified_data(segment=\"loop\")[\"moment\"] ax.plot(x1, y1, label=\"virgin\") ax.plot(x2, y2, label=\"reverse\") ax.plot(x3, y3, label=\"forward\") ax.plot(x4, y4, label=\"loop\", linewidth=4, zorder=-1, c=\"black\") ax.set_xlabel(\"Field (T)\") ax.set_ylabel(\"Moment (emu)\") ax.legend() mp.force_aspect(ax) plt.show() In\u00a0[13]: Copied! <pre>sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\")\nprint(\n    f\"\"\"{sample_info.mass = }\n{sample_info.eicosane_mass = }\n{sample_info.molecular_weight = }\n{sample_info.diamagnetic_correction = }\"\"\"\n)\n</pre> sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\") print(     f\"\"\"{sample_info.mass = } {sample_info.eicosane_mass = } {sample_info.molecular_weight = } {sample_info.diamagnetic_correction = }\"\"\" ) <pre>sample_info.mass = 10.1\nsample_info.eicosane_mass = 17.3\nsample_info.molecular_weight = 704.95\nsample_info.diamagnetic_correction = 0.0\n</pre> <p>We'll pass all of these to the <code>scale_moment()</code> method, even though the <code>diamagnetic_correction</code> is 0.</p> In\u00a0[14]: Copied! <pre>mvsh11.scale_moment(\n    sample_info.mass,\n    sample_info.eicosane_mass,\n    sample_info.molecular_weight,\n    sample_info.diamagnetic_correction\n)\n</pre> mvsh11.scale_moment(     sample_info.mass,     sample_info.eicosane_mass,     sample_info.molecular_weight,     sample_info.diamagnetic_correction ) <p>The <code>scaling</code> attribute records the scaling that was applied as a list of manipulations. In this case, with a mass, molecular weight, and eicosane mass, the scaling is recorded as a <code>\"molar\"</code> scaling with an <code>\"eicosane\"</code> correction:</p> In\u00a0[15]: Copied! <pre>mvsh11.scaling\n</pre> mvsh11.scaling Out[15]: <pre>['molar', 'eicosane']</pre> <p>The <code>mvsh.plot()</code> method will be discussed later, but for now notice that the default behavior, given molar scaling, is to plot the magnetization data in units of $N_A \\mu_B$:</p> In\u00a0[16]: Copied! <pre>fig, ax = mvsh11.plot()\n</pre> fig, ax = mvsh11.plot() <p>The plotting behavior works because the underlying <code>plot_mvsh()</code> function accesses the <code>simplified_data()</code> method. <code>simplified_data()</code> always returns a <code>DataFrame</code> with the same columns, but the values and units of those columns are dependent on the scaling that has been applied.</p> <p>Compare the current <code>simplified_data()</code> to the one we saw earlier -- the moment at 7 T was 0.4 emu and with the scaling that we just applied it's now 5.1 $N_A \\mu_B$.</p> In\u00a0[17]: Copied! <pre>mvsh11.simplified_data(segment=\"reverse\").head()\n</pre> mvsh11.simplified_data(segment=\"reverse\").head() Out[17]: time temperature field moment moment_err chi chi_err chi_t chi_t_err 0 3.886900e+09 4.999997 70000.460938 5.118614 0.017930 0.408390 0.001431 2.041947 0.007153 1 3.886900e+09 5.000016 69999.851562 5.122193 0.018112 0.408679 0.001445 2.043400 0.007225 2 3.886900e+09 4.999962 69890.496094 5.116739 0.017861 0.408882 0.001427 2.044396 0.007136 3 3.886900e+09 5.000044 69798.500000 5.121548 0.018347 0.409806 0.001468 2.049048 0.007340 4 3.886900e+09 4.999870 69694.355469 5.119781 0.017745 0.410277 0.001422 2.051331 0.007110 In\u00a0[18]: Copied! <pre>mvsh6 = mp.MvsH(DATA_PATH / \"mvsh6.dat\")\n</pre> mvsh6 = mp.MvsH(DATA_PATH / \"mvsh6.dat\") <p>In the following plot, note that the forward segment has a negative coercivity and the reverse segment has a positive coercivity!</p> In\u00a0[19]: Copied! <pre>fig, ax = plt.subplots()\nmax_moment = mvsh6.simplified_data()[\"moment\"].max()\nx1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"]\ny1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment\nx2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"]\ny2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment\nax.plot(x1, y1, label=\"forward\")\nax.plot(x2, y2, label=\"reverse\")\nax.set_xlim(-1000, 1000)\nax.set_ylim(-1, 1)\nax.set_xlabel(\"Field (Oe)\")\nax.set_ylabel(\"Normalized Moment\")\nax.legend()\nmp.force_aspect(ax)\nplt.show()\n</pre> fig, ax = plt.subplots() max_moment = mvsh6.simplified_data()[\"moment\"].max() x1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"] y1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment x2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"] y2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment ax.plot(x1, y1, label=\"forward\") ax.plot(x2, y2, label=\"reverse\") ax.set_xlim(-1000, 1000) ax.set_ylim(-1, 1) ax.set_xlabel(\"Field (Oe)\") ax.set_ylabel(\"Normalized Moment\") ax.legend() mp.force_aspect(ax) plt.show() <p>The field correction can be applied by passing the path to the .dat file containing the same experiment (i.e., same field sequence) collected on a Pd standard to the <code>correct_field()</code> method:</p> In\u00a0[20]: Copied! <pre>mvsh6.correct_field(DATA_PATH / \"Pd_std1.dat\")\n</pre> mvsh6.correct_field(DATA_PATH / \"Pd_std1.dat\") <p>The corrected data removes the false coercivities:</p> In\u00a0[21]: Copied! <pre>fig, ax = plt.subplots()\nmax_moment = mvsh6.simplified_data()[\"moment\"].max()\nx1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"]\ny1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment\nx2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"]\ny2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment\nax.plot(x1, y1, label=\"forward\")\nax.plot(x2, y2, label=\"reverse\")\nax.set_xlim(-1000, 1000)\nax.set_ylim(-1, 1)\nax.set_xlabel(\"Field (Oe)\")\nax.set_ylabel(\"Normalized Moment\")\nax.legend()\nmp.force_aspect(ax)\nplt.show()\n</pre> fig, ax = plt.subplots() max_moment = mvsh6.simplified_data()[\"moment\"].max() x1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"] y1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment x2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"] y2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment ax.plot(x1, y1, label=\"forward\") ax.plot(x2, y2, label=\"reverse\") ax.set_xlim(-1000, 1000) ax.set_ylim(-1, 1) ax.set_xlabel(\"Field (Oe)\") ax.set_ylabel(\"Normalized Moment\") ax.legend() mp.force_aspect(ax) plt.show() <p>Zooming in further we can see that the forward and reverse segments are mostly coincident and never cross:</p> In\u00a0[22]: Copied! <pre>fig, ax = plt.subplots()\nmax_moment = mvsh6.simplified_data()[\"moment\"].max()\nx1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"]\ny1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment\nx2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"]\ny2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment\nax.plot(x1, y1, label=\"forward\")\nax.plot(x2, y2, label=\"reverse\")\nax.set_xlim(-100, 100)\nax.set_ylim(-0.1, 0.1)\nax.set_xlabel(\"Field (Oe)\")\nax.set_ylabel(\"Normalized Moment\")\nax.legend()\nmp.force_aspect(ax)\nplt.show()\n</pre> fig, ax = plt.subplots() max_moment = mvsh6.simplified_data()[\"moment\"].max() x1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"] y1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment x2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"] y2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment ax.plot(x1, y1, label=\"forward\") ax.plot(x2, y2, label=\"reverse\") ax.set_xlim(-100, 100) ax.set_ylim(-0.1, 0.1) ax.set_xlabel(\"Field (Oe)\") ax.set_ylabel(\"Normalized Moment\") ax.legend() mp.force_aspect(ax) plt.show() <p>The name of the file used for the correction is stored in the <code>field_correction_file</code> attribute:</p> In\u00a0[23]: Copied! <pre>mvsh6.field_correction_file\n</pre> mvsh6.field_correction_file Out[23]: <pre>'Pd_std1.dat'</pre> <p>The field correction can also be run by passing the name of a sequence within your standard calibration library. In our case, that's installed using the Rinehart group's MagnetoPyCalibration repository, and the desired sequence in this case is named <code>\"sequence_1\"</code>.</p> In\u00a0[24]: Copied! <pre>mvsh6 = mp.MvsH(DATA_PATH / \"mvsh6.dat\")\nmvsh6.correct_field(\"sequence_1\")\n\nfig, ax = plt.subplots()\nmax_moment = mvsh6.simplified_data()[\"moment\"].max()\nx1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"]\ny1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment\nx2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"]\ny2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment\nax.plot(x1, y1, label=\"forward\")\nax.plot(x2, y2, label=\"reverse\")\nax.set_xlim(-1000, 1000)\nax.set_ylim(-1, 1)\nax.set_xlabel(\"Field (Oe)\")\nax.set_ylabel(\"Normalized Moment\")\nax.legend()\nmp.force_aspect(ax)\nplt.show()\n</pre> mvsh6 = mp.MvsH(DATA_PATH / \"mvsh6.dat\") mvsh6.correct_field(\"sequence_1\")  fig, ax = plt.subplots() max_moment = mvsh6.simplified_data()[\"moment\"].max() x1 = mvsh6.simplified_data(segment=\"forward\")[\"field\"] y1 = mvsh6.simplified_data(segment=\"forward\")[\"moment\"] / max_moment x2 = mvsh6.simplified_data(segment=\"reverse\")[\"field\"] y2 = mvsh6.simplified_data(segment=\"reverse\")[\"moment\"] / max_moment ax.plot(x1, y1, label=\"forward\") ax.plot(x2, y2, label=\"reverse\") ax.set_xlim(-1000, 1000) ax.set_ylim(-1, 1) ax.set_xlabel(\"Field (Oe)\") ax.set_ylabel(\"Normalized Moment\") ax.legend() mp.force_aspect(ax) plt.show() <p>The field correction file takes the name of the file in the standard calibration library:</p> In\u00a0[25]: Copied! <pre>mvsh6.field_correction_file\n</pre> mvsh6.field_correction_file Out[25]: <pre>'mvsh_seq1.dat'</pre> In\u00a0[26]: Copied! <pre>mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\")\nfig, ax = mvsh11.plot()\n</pre> mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\") fig, ax = mvsh11.plot() In\u00a0[27]: Copied! <pre>mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\")\nmvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\")\nmvsh11.scale_moment(\n    mass = mvsh11_sample_info.mass,\n)\nfig, ax = mvsh11.plot()\n</pre> mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\") mvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\") mvsh11.scale_moment(     mass = mvsh11_sample_info.mass, ) fig, ax = mvsh11.plot() In\u00a0[28]: Copied! <pre>mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\")\nmvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\")\nmvsh11.scale_moment(\n    mass = mvsh11_sample_info.mass,\n    molecular_weight = mvsh11_sample_info.molecular_weight,\n)\nfig, ax = mvsh11.plot()\n</pre> mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\") mvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\") mvsh11.scale_moment(     mass = mvsh11_sample_info.mass,     molecular_weight = mvsh11_sample_info.molecular_weight, ) fig, ax = mvsh11.plot() <p>The <code>\"segment\"</code> argument can be used to plot only a single segment of the data (options are <code>\"virgin\"</code>, <code>\"forward\"</code>, <code>\"reverse\"</code>, and <code>\"loop\"</code>). By default all data will be plotted.</p> In\u00a0[29]: Copied! <pre>mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\")\nmvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\")\nmvsh11.scale_moment(\n    mass = mvsh11_sample_info.mass,\n    molecular_weight = mvsh11_sample_info.molecular_weight,\n)\nfig, ax = mvsh11.plot(segment=\"virgin\")\n</pre> mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\") mvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\") mvsh11.scale_moment(     mass = mvsh11_sample_info.mass,     molecular_weight = mvsh11_sample_info.molecular_weight, ) fig, ax = mvsh11.plot(segment=\"virgin\") In\u00a0[30]: Copied! <pre>mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\")\nmvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\")\nmvsh11.scale_moment(\n    mass = mvsh11_sample_info.mass,\n    molecular_weight = mvsh11_sample_info.molecular_weight,\n)\nfig, ax = mvsh11.plot(segment=\"loop\")\n</pre> mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\") mvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\") mvsh11.scale_moment(     mass = mvsh11_sample_info.mass,     molecular_weight = mvsh11_sample_info.molecular_weight, ) fig, ax = mvsh11.plot(segment=\"loop\") <p>You can also plot single experiments using <code>plot_mvsh()</code> by passing the experiment as an argument:</p> In\u00a0[31]: Copied! <pre>fig, ax = mp.plot_mvsh(mvsh11)\n</pre> fig, ax = mp.plot_mvsh(mvsh11) In\u00a0[32]: Copied! <pre>mvsh10 = mp.MvsH(DATA_PATH / \"mvsh10.dat\")\nmvsh10_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh10.dat\")\nmvsh10.scale_moment(\n    mass = mvsh10_sample_info.mass,\n    molecular_weight = mvsh10_sample_info.molecular_weight,\n)\n\nmvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\")\nmvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\")\nmvsh11.scale_moment(\n    mass = mvsh11_sample_info.mass,\n    molecular_weight = mvsh11_sample_info.molecular_weight,\n)\n\nfig, ax = mp.plot_mvsh([mvsh10, mvsh11], segment=\"loop\", labels=[\"mvsh10\", \"mvsh11\"])\n</pre> mvsh10 = mp.MvsH(DATA_PATH / \"mvsh10.dat\") mvsh10_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh10.dat\") mvsh10.scale_moment(     mass = mvsh10_sample_info.mass,     molecular_weight = mvsh10_sample_info.molecular_weight, )  mvsh11 = mp.MvsH(DATA_PATH / \"mvsh11.dat\") mvsh11_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"mvsh11.dat\") mvsh11.scale_moment(     mass = mvsh11_sample_info.mass,     molecular_weight = mvsh11_sample_info.molecular_weight, )  fig, ax = mp.plot_mvsh([mvsh10, mvsh11], segment=\"loop\", labels=[\"mvsh10\", \"mvsh11\"])  <p>If you want to plot multiple experiments which have different scaling, you'll need to take advantage of the <code>normalize</code> argument.</p> In\u00a0[33]: Copied! <pre>mvsh2_5 = mp.MvsH(DATA_PATH / \"mvsh2.dat\", temperature=5)\nfig, ax = mp.plot_mvsh(\n    [mvsh2_5, mvsh11],\n    normalized=True,\n    segment=\"loop\",\n    colors=[\"green\", \"purple\"],\n    labels=[\"mvsh2\", \"mvsh11\"],\n    title=\"5 K\"\n)\n</pre> mvsh2_5 = mp.MvsH(DATA_PATH / \"mvsh2.dat\", temperature=5) fig, ax = mp.plot_mvsh(     [mvsh2_5, mvsh11],     normalized=True,     segment=\"loop\",     colors=[\"green\", \"purple\"],     labels=[\"mvsh2\", \"mvsh11\"],     title=\"5 K\" ) In\u00a0[34]: Copied! <pre>mvsh5 = mp.MvsH(DATA_PATH / \"mvsh5.dat\", parse_raw = True)\nfig, ax = mvsh5.plot_raw(segment=\"forward\")\n</pre> mvsh5 = mp.MvsH(DATA_PATH / \"mvsh5.dat\", parse_raw = True) fig, ax = mvsh5.plot_raw(segment=\"forward\") In\u00a0[35]: Copied! <pre>fig, ax = mvsh5.plot_raw_residual(segment=\"forward\")\n</pre> fig, ax = mvsh5.plot_raw_residual(segment=\"forward\")"},{"location":"examples/mvsh/#the-mvsh-experiment-class","title":"The <code>MvsH</code> Experiment Class\u00b6","text":"<p>The <code>MvsH</code> class contains the data of a single magnetization vs. field (i.e., a hysteresis) experiment, along with a number of methods used for processing and working with the data.</p>"},{"location":"examples/mvsh/#creating-an-mvsh-object-from-files","title":"Creating an <code>MvsH</code> Object From Files\u00b6","text":""},{"location":"examples/mvsh/#files-with-a-single-experiment","title":"Files with a Single Experiment\u00b6","text":"<p>For files containing a single M vs. H experiment (i.e., data collected at a single temperature), the <code>MvsH</code> object can be created by simply passing the file path to the constructor:</p>"},{"location":"examples/mvsh/#files-with-multiple-experiments","title":"Files with Multiple Experiments\u00b6","text":"<p>Trying to create an <code>MvsH</code> object from a file containing multiple experiments will result in a <code>TemperatureDetectionError</code>:</p>"},{"location":"examples/mvsh/#creating-multiple-mvsh-objects-from-a-single-file","title":"Creating Multiple <code>MvsH</code> Objects From a Single File\u00b6","text":"<p>In cases where a single file contains multiple experiments, we can create a list of <code>MvsH</code> objects by passing the file path to the <code>MvsH.get_all_in_file()</code> method:</p>"},{"location":"examples/mvsh/#simplified-data-and-segments","title":"Simplified Data and Segments\u00b6","text":""},{"location":"examples/mvsh/#scaling-the-moment","title":"Scaling the Moment\u00b6","text":"<p>Scaling is something you'll likely do through the <code>Magnetometry</code> class, discussed in a later example notebook. However, the <code>Magnetometry</code> class uses methods within the <code>MvsH</code> class, and these methods can be used directly as well.</p> <p>Scaling can be done using the <code>scale_moment()</code> method. As is described in the underlying utility function, this method adds columns to the <code>data</code> attribute of the <code>MvsH</code> object that contain the magnetic moment, magnetic susceptibility, and magnetic susceptibility times temperature (and their errors). The columns added are <code>\"moment\"</code>, <code>\"moment_err\"</code>, <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, and <code>\"chi_t_err\"</code>. The units of these values depend on the values of the <code>mass</code>, <code>eicosane_mass</code>, <code>molecular_weight</code>, and <code>diamagnetic_correction</code> which are passed as arguments. A record of what scaling was applied is added to the <code>scaling</code> attribute of the <code>MvsH</code> object.</p> <p>Here are the currently supported scaling options:</p> <ul> <li>If <code>mass</code> is given but not <code>molecular_weight</code>, the only available scaling is a mass correction.</li> <li>If <code>mass</code> and <code>molecular</code> weight are given, a molar correction is applied. The molar correction can be further modified by giving <code>eicosane_mass</code> and/or <code>diamagnetic_correction</code>.</li> </ul> <p>We'll use the <code>SampleInfo</code> class to read the sample information from the header of the .dat file:</p>"},{"location":"examples/mvsh/#correcting-the-field-for-flux-trapping","title":"Correcting the Field for Flux Trapping\u00b6","text":"<p>As described in this Quantum Design application note, the magnetic field reported by the magnetometer is determined by current from the magnet power supply and not by direct measurement. Flux trapping in the magnet can cause the reported field to be different from the actual field. While always present, it is most obvious in hysteresis curves of soft, non-hysteretic materials. In some cases the forward and reverse scans can have negative and postive coercivities, respectively, which is not physically possible.</p> <p>The true field correction remedies this by using a Pd standard to determine the actual field applied to the sample. Assuming the calibration and sample sequences are the same, it is assumed that the flux trapping is the same for both sequences, and the calculated field from the measurement on the Pd standard is applied to the sample data.</p> <p>Here's an M vs. H experiment that needs correction:</p>"},{"location":"examples/mvsh/#plotting","title":"Plotting\u00b6","text":"<p>The MagnetoPy function <code>plot_mvsh()</code> provides basic plotting capabilities for <code>MvsH</code> objects. It can be used to plot a single experiment or multiple experiments. In the former case it calls <code>plot_single_mvsh()</code> and in the latter case it calls <code>plot_multiple_mvsh()</code>. It shouldn't be necessary, but these functions can be called directly if desired.</p> <p>There are also convenience functions in the <code>MvsH</code> and <code>Magnetometry</code> classes for plotting M vs. H experiments. In <code>MvsH</code>, it is the <code>plot()</code> method.</p>"},{"location":"examples/mvsh/#plot-a-single-mvsh-experiment","title":"Plot a Single <code>MvsH</code> Experiment\u00b6","text":"<p>As we have already seen, the <code>plot()</code> method of the <code>MvsH</code> class plots the data contained within the class. The units are determined by the scaling that has been applied.</p>"},{"location":"examples/mvsh/#plot-multiple-mvsh-experiments","title":"Plot Multiple <code>MvsH</code> Experiments\u00b6","text":"<p>The <code>plot_mvsh()</code> function can be used to plot multiple experiments. If you want to plot multiple experiments from the same sample, the <code>Magnetometry.plot_mvsh()</code> method will probably be more convenient.</p>"},{"location":"examples/mvsh/#plotting-raw-data","title":"Plotting Raw Data\u00b6","text":"<p>The <code>MvsH.plot_raw()</code> and <code>MvsH.plot_raw_residual()</code> methods provide a more convenient way to plot the raw data from the .dat file than using the related <code>DatFile</code> methods, as the <code>MvsH</code> methods allow you to easily specify the segment to plot.</p> <p>Note that when creating the <code>MvsH</code> object you'll need to pass the <code>parse_raw = True</code> argument to the constructor.</p>"},{"location":"examples/mvsh_analysis/","title":"A Simple M vs. H Analysis","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom dataclasses import dataclass, asdict\nfrom typing import Any, Literal\n\nimport pandas as pd\n\nimport magnetopy as mp\n\nDATA_PATH = Path(\"../../tests/data/\")\n</pre> from pathlib import Path from dataclasses import dataclass, asdict from typing import Any, Literal  import pandas as pd  import magnetopy as mp  DATA_PATH = Path(\"../../tests/data/\") In\u00a0[2]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\")\nfor mvsh in dset1.mvsh:\n    segments = []\n    for segment in [\"forward\", \"reverse\"]:\n        try:\n            _ = mvsh.select_segment(segment)\n            segments.append(segment)\n        except mp.MvsH.SegmentError:\n            pass\n    print(f\"{mvsh}:\\tavailable segments: {segments}\")\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\") for mvsh in dset1.mvsh:     segments = []     for segment in [\"forward\", \"reverse\"]:         try:             _ = mvsh.select_segment(segment)             segments.append(segment)         except mp.MvsH.SegmentError:             pass     print(f\"{mvsh}:\\tavailable segments: {segments}\") <pre>MvsH at 2 K:\tavailable segments: ['forward', 'reverse']\nMvsH at 4 K:\tavailable segments: ['forward', 'reverse']\nMvsH at 6 K:\tavailable segments: ['forward', 'reverse']\nMvsH at 8 K:\tavailable segments: ['forward', 'reverse']\nMvsH at 10 K:\tavailable segments: ['forward', 'reverse']\nMvsH at 12 K:\tavailable segments: ['forward', 'reverse']\nMvsH at 300 K:\tavailable segments: ['reverse']\n</pre> <p>The first step in our analysis will be to select a particular <code>MvsH</code> object based on a desired temperature.</p> In\u00a0[3]: Copied! <pre>mvsh = dset1.get_mvsh(2)\nmvsh\n</pre> mvsh = dset1.get_mvsh(2) mvsh Out[3]: <pre>MvsH at 2 K</pre> <p>To determine saturation magnetization, coercive field, and remnant magnetization, we'll need to inspect individual segments within the hysteresis loop. Better yet, we can average over all available segments to get a more robust estimate of these quantities. First we'll need to make a list of the available segments and the <code>DataFrame</code> containing the data for each segment.</p> <p>Note that we'll be analyzing a <code>DataFrame</code> from the <code>MvsH.simplified_data()</code> method. This ensures that no matter what the original data looks like or what scaling was applied, we'll be able to analyze it in a consistent manner.</p> In\u00a0[4]: Copied! <pre>segments: dict[str, pd.DataFrame] = {}\nfor segment in [\"forward\", \"reverse\"]:\n    try:\n        data = mvsh.simplified_data(segment)\n        segments[segment] = data\n    except mp.MvsH.SegmentError:\n        pass\nsegments[\"forward\"]\n</pre> segments: dict[str, pd.DataFrame] = {} for segment in [\"forward\", \"reverse\"]:     try:         data = mvsh.simplified_data(segment)         segments[segment] = data     except mp.MvsH.SegmentError:         pass segments[\"forward\"] Out[4]: time temperature field moment moment_err chi chi_err chi_t chi_t_err 0 3803630121 1.999938 -70000.35156 -10.448284 0.013823 0.833620 0.001103 1.667187 0.002206 1 3803630124 2.000082 -69999.64063 -10.464880 0.013818 0.834952 0.001103 1.669973 0.002205 2 3803630129 1.999687 -69746.61719 -10.460689 0.012272 0.837646 0.000983 1.675029 0.001965 3 3803630134 2.000118 -69498.96875 -10.465098 0.015537 0.840985 0.001249 1.682069 0.002497 4 3803630139 2.000298 -69246.27344 -10.456070 0.014218 0.843326 0.001147 1.686902 0.002294 ... ... ... ... ... ... ... ... ... ... 558 3803632902 1.999771 69002.42969 10.453863 0.040218 0.846127 0.003255 1.692060 0.006510 559 3803632907 2.000226 69253.85156 10.457121 0.040109 0.843318 0.003235 1.686827 0.006470 560 3803632912 1.999959 69500.30469 10.456319 0.041108 0.840263 0.003303 1.680491 0.006607 561 3803632917 1.999737 69751.79688 10.448923 0.043926 0.836641 0.003517 1.673063 0.007033 562 3803632925 2.000152 70000.31250 10.448547 0.043354 0.833641 0.003459 1.667409 0.006919 <p>563 rows \u00d7 9 columns</p> <p>The saturation magnetization for a given segment can be determined by averaging the maximum moment at positive fields and the absolute value of the minimum moment at negative fields. We can then average over all available segments.</p> In\u00a0[5]: Copied! <pre>m_s = 0\nfor segment in segments.values():\n    m_s += (segment[\"moment\"].max() + abs(segment[\"moment\"].min())) / 2\nm_s /= len(segments)\nm_s\n</pre> m_s = 0 for segment in segments.values():     m_s += (segment[\"moment\"].max() + abs(segment[\"moment\"].min())) / 2 m_s /= len(segments) m_s Out[5]: <pre>10.467101768993821</pre> <p>The coercive field can be determined by finding the field at which the moment is zero. We can then average over all available segments.</p> In\u00a0[6]: Copied! <pre>h_c = 0\nfor segment in segments.values():\n    h_c += abs(segment[\"field\"].iloc[segment[\"moment\"].abs().idxmin()])\nh_c /= len(segments)\nh_c\n</pre> h_c = 0 for segment in segments.values():     h_c += abs(segment[\"field\"].iloc[segment[\"moment\"].abs().idxmin()]) h_c /= len(segments) h_c Out[6]: <pre>4501.3806155</pre> <p>Finally, we can calculate the remnant magnetization by finding the moment at zero field. Again, we can average over all available segments.</p> In\u00a0[7]: Copied! <pre>m_r = 0\nfor segment in segments.values():\n    m_r += abs(segment[\"moment\"].iloc[segment[\"field\"].abs().idxmin()])\nm_r / len(segments)\nm_r\n</pre> m_r = 0 for segment in segments.values():     m_r += abs(segment[\"moment\"].iloc[segment[\"field\"].abs().idxmin()]) m_r / len(segments) m_r Out[7]: <pre>17.147614337928776</pre> <p>As described in the <code>MvsH.simplified_data()</code> documentation, the unit of the field data is Oe. The unit of magnetic moment is dependent on what scaling was applied to the data. So our last step will be to check the original <code>MvsH</code> object to see what scaling was applied to it.</p> In\u00a0[8]: Copied! <pre>if not mvsh.scaling:\n    scaling = \"emu\"\nelif \"mass\" in mvsh.scaling:\n    scaling = \"emu/g\"\nelif \"molar\" in mvsh.scaling:\n    scaling = \"bohr magnetons/mol\"\n\nscaling\n</pre> if not mvsh.scaling:     scaling = \"emu\" elif \"mass\" in mvsh.scaling:     scaling = \"emu/g\" elif \"molar\" in mvsh.scaling:     scaling = \"bohr magnetons/mol\"  scaling     Out[8]: <pre>'bohr magnetons/mol'</pre> <p>That's it. Here's the summary of the analysis:</p> In\u00a0[9]: Copied! <pre>print(f\"{mvsh} in {dset1.sample_id} has:\")\nprint(f\"\\tMs = {m_s:.2f} {scaling}\")\nprint(f\"\\tHc = {h_c:.2f} Oe\")\nprint(f\"\\tMr = {m_r:.2f} {scaling}\")\n</pre> print(f\"{mvsh} in {dset1.sample_id} has:\") print(f\"\\tMs = {m_s:.2f} {scaling}\") print(f\"\\tHc = {h_c:.2f} Oe\") print(f\"\\tMr = {m_r:.2f} {scaling}\") <pre>MvsH at 2 K in dataset1 has:\n\tMs = 10.47 bohr magnetons/mol\n\tHc = 4501.38 Oe\n\tMr = 17.15 bohr magnetons/mol\n</pre> In\u00a0[10]: Copied! <pre>@dataclass\nclass SimpleMvsHAnalysisParsingArgs:\n\"\"\"Arguments needed to parse a `Magnetometry` object during the course of an\n    analysis performed by `SimpleMvsHAnalysis`.\n\n    Attributes\n    ----------\n    temperature : float\n        The temperature in Kelvin of the measurement to be analyzed.\n    segments : Literal[\"auto\", \"loop\", \"forward\", \"reverse\"], optional\n        The segments of the measurement to be analyzed. If `\"auto\"`, the forward and\n        reverse segments will be analyzed if they exist and will be ignored if they\n        don't. If `\"loop\"`, the forward and reverse segments will be analyzed if they\n        exist and an error will be raised if they don't. If `\"forward\"` or `\"reverse\"`,\n        only the forward or reverse segment will be analyzed, respectively.\n    \"\"\"\n\n    temperature: float\n    segments: Literal[\"auto\", \"loop\", \"forward\", \"reverse\"] = \"auto\"\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        return asdict(self)\n\n\n@dataclass\nclass SimpleMvsHAnalysisResults:\n\"\"\"The results of an analysis performed by `SimpleMvsHAnalysis`.\n\n    Attributes\n    ----------\n    m_s : float\n        The saturation magnetization of the sample in units of `moment_units`.\n    h_c : float\n        The coercive field of the sample in units of `field_units`.\n    m_r : float\n        The remanent magnetization of the sample in units of `moment_units`.\n    moment_units : str\n        The units of the saturation magnetization and remanent magnetization.\n    field_units : str\n        The units of the coercive field.\n    segments : list[{\"forward\", \"reverse\"}]\n        The segments of the measurement that were analyzed.\n    \"\"\"\n\n    m_s: float\n    h_c: float\n    m_r: float\n    moment_units: str\n    field_units: str\n    segments: Literal[\"forward\", \"reverse\"]\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        return asdict(self)\n</pre> @dataclass class SimpleMvsHAnalysisParsingArgs:     \"\"\"Arguments needed to parse a `Magnetometry` object during the course of an     analysis performed by `SimpleMvsHAnalysis`.      Attributes     ----------     temperature : float         The temperature in Kelvin of the measurement to be analyzed.     segments : Literal[\"auto\", \"loop\", \"forward\", \"reverse\"], optional         The segments of the measurement to be analyzed. If `\"auto\"`, the forward and         reverse segments will be analyzed if they exist and will be ignored if they         don't. If `\"loop\"`, the forward and reverse segments will be analyzed if they         exist and an error will be raised if they don't. If `\"forward\"` or `\"reverse\"`,         only the forward or reverse segment will be analyzed, respectively.     \"\"\"      temperature: float     segments: Literal[\"auto\", \"loop\", \"forward\", \"reverse\"] = \"auto\"      def as_dict(self) -&gt; dict[str, Any]:         return asdict(self)   @dataclass class SimpleMvsHAnalysisResults:     \"\"\"The results of an analysis performed by `SimpleMvsHAnalysis`.      Attributes     ----------     m_s : float         The saturation magnetization of the sample in units of `moment_units`.     h_c : float         The coercive field of the sample in units of `field_units`.     m_r : float         The remanent magnetization of the sample in units of `moment_units`.     moment_units : str         The units of the saturation magnetization and remanent magnetization.     field_units : str         The units of the coercive field.     segments : list[{\"forward\", \"reverse\"}]         The segments of the measurement that were analyzed.     \"\"\"      m_s: float     h_c: float     m_r: float     moment_units: str     field_units: str     segments: Literal[\"forward\", \"reverse\"]      def as_dict(self) -&gt; dict[str, Any]:         return asdict(self) <p>Now we just need to move the analysis code we previously wrote into the <code>__init__</code> method and add a few lines to store the results in the <code>results</code> attribute. We'll also add some logic for handling requests for specific segments to be analyzed, as well as an <code>as_dict()</code> method for serializing the results (this is a required method of the <code>Analysis</code> protocol).</p> In\u00a0[11]: Copied! <pre>class SimpleMvsHAnalysis:\n\"\"\"An analysis of an M vs. H experiment that determines basic information about the\n    hysteresis loop (i.e., saturation magnetization, coercive field, remnant field).\n\n    Parameters\n    ----------\n    dataset : Magnetometry\n        The `Magnetometry` object which contains the `MvsH` object to be analyzed.\n    parsing_args : SimpleMvsHAnalysisParsingArgs\n        Arguments needed to parse the `Magnetometry` object to obtain the `MvsH` object\n        to be analyzed.\n\n    Attributes\n    ----------\n    parsing_args : SimpleMvsHAnalysisParsingArgs\n        Arguments needed to parse the `Magnetometry` object to obtain the `MvsH` object\n        to be analyzed.\n    mvsh : MvsH\n        The analyzed `MvsH` object.\n    results : SimpleMvsHAnalysisResults\n        The results of the analysis.\n    \"\"\"\n\n    def __init__(\n        self,\n        dataset: mp.Magnetometry,\n        parsing_args: SimpleMvsHAnalysisParsingArgs,\n    ) -&gt; None:\n        self.parsing_args = parsing_args\n        self.mvsh = dataset.get_mvsh(self.parsing_args.temperature)\n        segments = self._get_segments()\n        m_s = self._determine_m_s(segments)\n        h_c = self._determine_h_c(segments)\n        m_r = self._determine_m_r(segments)\n        moment_units = self._determine_moment_units()\n        field_units = \"Oe\"\n        self.results = SimpleMvsHAnalysisResults(\n            m_s, h_c, m_r, moment_units, field_units, list(segments.keys())\n        )\n\n    def _get_segments(self) -&gt; dict[str, pd.DataFrame]:\n        segments: dict[str : pd.DataFrame] = {}\n        if self.parsing_args.segments == \"auto\":\n            try:\n                segments[\"forward\"] = self.mvsh.simplified_data(\"forward\")\n            except mp.MvsH.SegmentError:\n                pass\n            try:\n                segments[\"reverse\"] = self.mvsh.simplified_data(\"reverse\")\n            except mp.MvsH.SegmentError:\n                pass\n        else:\n            if self.parsing_args.segments in [\"loop\", \"forward\"]:\n                segments[\"forward\"] = self.mvsh.simplified_data(\"forward\")\n            if self.parsing_args.segments in [\"loop\", \"reverse\"]:\n                segments[\"reverse\"] = self.mvsh.simplified_data(\"reverse\")\n        return segments\n\n    def _determine_m_s(self, segments: dict[str, pd.DataFrame]) -&gt; float:\n        m_s = 0\n        for segment in segments.values():\n            m_s += (segment[\"moment\"].max() + abs(segment[\"moment\"].min())) / 2\n        return m_s / len(segments)\n\n    def _determine_h_c(self, segments: dict[str, pd.DataFrame]) -&gt; float:\n        h_c = 0\n        for segment in segments.values():\n            h_c += abs(segment[\"field\"].iloc[segment[\"moment\"].abs().idxmin()])\n        return h_c / len(segments)\n\n    def _determine_m_r(self, segments: dict[str, pd.DataFrame]) -&gt; float:\n        m_r = 0\n        for segment in segments.values():\n            m_r += abs(segment[\"moment\"].iloc[segment[\"field\"].abs().idxmin()])\n        return m_r / len(segments)\n\n    def _determine_moment_units(self) -&gt; str:\n        scaling = self.mvsh.scaling\n        if not scaling:\n            return \"emu\"\n        elif \"mass\" in scaling:\n            return \"emu/g\"\n        elif \"molar\" in scaling:\n            return \"bohr magnetons/mol\"\n\n    def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Return a dictionary representation of the analysis.\n\n        Returns\n        -------\n        dict[str, Any]\n            Keys are `\"mvsh\"`, `\"parsing_args\"`, and `\"results\"`.\n        \"\"\"\n        return {\n            \"mvsh\": self.mvsh,\n            \"parsing_args\": self.parsing_args,\n            \"results\": self.results,\n        }\n</pre> class SimpleMvsHAnalysis:     \"\"\"An analysis of an M vs. H experiment that determines basic information about the     hysteresis loop (i.e., saturation magnetization, coercive field, remnant field).      Parameters     ----------     dataset : Magnetometry         The `Magnetometry` object which contains the `MvsH` object to be analyzed.     parsing_args : SimpleMvsHAnalysisParsingArgs         Arguments needed to parse the `Magnetometry` object to obtain the `MvsH` object         to be analyzed.      Attributes     ----------     parsing_args : SimpleMvsHAnalysisParsingArgs         Arguments needed to parse the `Magnetometry` object to obtain the `MvsH` object         to be analyzed.     mvsh : MvsH         The analyzed `MvsH` object.     results : SimpleMvsHAnalysisResults         The results of the analysis.     \"\"\"      def __init__(         self,         dataset: mp.Magnetometry,         parsing_args: SimpleMvsHAnalysisParsingArgs,     ) -&gt; None:         self.parsing_args = parsing_args         self.mvsh = dataset.get_mvsh(self.parsing_args.temperature)         segments = self._get_segments()         m_s = self._determine_m_s(segments)         h_c = self._determine_h_c(segments)         m_r = self._determine_m_r(segments)         moment_units = self._determine_moment_units()         field_units = \"Oe\"         self.results = SimpleMvsHAnalysisResults(             m_s, h_c, m_r, moment_units, field_units, list(segments.keys())         )      def _get_segments(self) -&gt; dict[str, pd.DataFrame]:         segments: dict[str : pd.DataFrame] = {}         if self.parsing_args.segments == \"auto\":             try:                 segments[\"forward\"] = self.mvsh.simplified_data(\"forward\")             except mp.MvsH.SegmentError:                 pass             try:                 segments[\"reverse\"] = self.mvsh.simplified_data(\"reverse\")             except mp.MvsH.SegmentError:                 pass         else:             if self.parsing_args.segments in [\"loop\", \"forward\"]:                 segments[\"forward\"] = self.mvsh.simplified_data(\"forward\")             if self.parsing_args.segments in [\"loop\", \"reverse\"]:                 segments[\"reverse\"] = self.mvsh.simplified_data(\"reverse\")         return segments      def _determine_m_s(self, segments: dict[str, pd.DataFrame]) -&gt; float:         m_s = 0         for segment in segments.values():             m_s += (segment[\"moment\"].max() + abs(segment[\"moment\"].min())) / 2         return m_s / len(segments)      def _determine_h_c(self, segments: dict[str, pd.DataFrame]) -&gt; float:         h_c = 0         for segment in segments.values():             h_c += abs(segment[\"field\"].iloc[segment[\"moment\"].abs().idxmin()])         return h_c / len(segments)      def _determine_m_r(self, segments: dict[str, pd.DataFrame]) -&gt; float:         m_r = 0         for segment in segments.values():             m_r += abs(segment[\"moment\"].iloc[segment[\"field\"].abs().idxmin()])         return m_r / len(segments)      def _determine_moment_units(self) -&gt; str:         scaling = self.mvsh.scaling         if not scaling:             return \"emu\"         elif \"mass\" in scaling:             return \"emu/g\"         elif \"molar\" in scaling:             return \"bohr magnetons/mol\"      def as_dict(self) -&gt; dict[str, Any]:         \"\"\"Return a dictionary representation of the analysis.          Returns         -------         dict[str, Any]             Keys are `\"mvsh\"`, `\"parsing_args\"`, and `\"results\"`.         \"\"\"         return {             \"mvsh\": self.mvsh,             \"parsing_args\": self.parsing_args,             \"results\": self.results,         } In\u00a0[12]: Copied! <pre>dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\")\ndset2 = mp.Magnetometry(DATA_PATH / \"dataset2\")\ndset3 = mp.Magnetometry(\n    DATA_PATH / \"dataset3\",\n    true_field_correction=\"sequence_1\"\n)\ndset4 = mp.Magnetometry(DATA_PATH / \"dataset4\")\nfor dset in [dset1, dset2, dset3, dset4]:\n    analyses = []\n    for mvsh in dset.mvsh:\n        analysis = SimpleMvsHAnalysis(\n            dset, SimpleMvsHAnalysisParsingArgs(mvsh.temperature)\n        )\n        analyses.append(analysis)\n    dset.add_analysis(analyses)\n</pre> dset1 = mp.Magnetometry(DATA_PATH / \"dataset1\") dset2 = mp.Magnetometry(DATA_PATH / \"dataset2\") dset3 = mp.Magnetometry(     DATA_PATH / \"dataset3\",     true_field_correction=\"sequence_1\" ) dset4 = mp.Magnetometry(DATA_PATH / \"dataset4\") for dset in [dset1, dset2, dset3, dset4]:     analyses = []     for mvsh in dset.mvsh:         analysis = SimpleMvsHAnalysis(             dset, SimpleMvsHAnalysisParsingArgs(mvsh.temperature)         )         analyses.append(analysis)     dset.add_analysis(analyses)  <p>If we were publishing this work we would likely take advantage of the <code>MvsH.create_report()</code> method. For now, we'll just print the results.</p> In\u00a0[13]: Copied! <pre>print(\"| Dataset | Temperature (K) | H_c (Oe) | M_s | M_r | M units |\")\nprint(\"| ------- | --------------- | -------- | --- | --- | ------- |\")\nfor dset in [dset1, dset2, dset3, dset4]:\n    for analysis in dset.analyses:\n        print(\n            f\"| {dset.sample_id} | {analysis.parsing_args.temperature} | \"\n            f\"{analysis.results.h_c:.2f} | {analysis.results.m_s:.2f} | \"\n            f\"{analysis.results.m_r:.2f} | {analysis.results.moment_units} |\")\n</pre> print(\"| Dataset | Temperature (K) | H_c (Oe) | M_s | M_r | M units |\") print(\"| ------- | --------------- | -------- | --- | --- | ------- |\") for dset in [dset1, dset2, dset3, dset4]:     for analysis in dset.analyses:         print(             f\"| {dset.sample_id} | {analysis.parsing_args.temperature} | \"             f\"{analysis.results.h_c:.2f} | {analysis.results.m_s:.2f} | \"             f\"{analysis.results.m_r:.2f} | {analysis.results.moment_units} |\") <pre>| Dataset | Temperature (K) | H_c (Oe) | M_s | M_r | M units |\n| ------- | --------------- | -------- | --- | --- | ------- |\n| dataset1 | 2 | 4501.38 | 10.47 | 8.57 | bohr magnetons/mol |\n| dataset1 | 4 | 3502.37 | 9.45 | 4.49 | bohr magnetons/mol |\n| dataset1 | 6 | 1502.06 | 9.32 | 1.24 | bohr magnetons/mol |\n| dataset1 | 8 | 355.58 | 9.23 | 0.16 | bohr magnetons/mol |\n| dataset1 | 10 | 1.34 | 9.01 | 0.02 | bohr magnetons/mol |\n| dataset1 | 12 | 7.78 | 8.87 | 0.00 | bohr magnetons/mol |\n| dataset1 | 300 | 4.78 | 0.99 | 0.00 | bohr magnetons/mol |\n| dataset2 | 293.0 | 0.11 | 0.77 | 0.05 | emu/g |\n| dataset3 | 300 | 4.92 | 51.64 | 0.49 | emu/g |\n| dataset4 | 2 | 0.12 | 8.50 | 0.06 | bohr magnetons/mol |\n</pre> <p>Here is the same data formatted in markdown:</p> Dataset Temperature (K) H_c (Oe) M_s M_r M units dataset1 2 4501.38 10.47 8.57 bohr magnetons/mol dataset1 4 3502.37 9.45 4.49 bohr magnetons/mol dataset1 6 1502.06 9.32 1.24 bohr magnetons/mol dataset1 8 355.58 9.23 0.16 bohr magnetons/mol dataset1 10 1.34 9.01 0.02 bohr magnetons/mol dataset1 12 7.78 8.87 0.00 bohr magnetons/mol dataset1 300 4.78 0.99 0.00 bohr magnetons/mol dataset2 293.0 0.11 0.77 0.05 emu/g dataset3 300 4.92 51.64 0.49 emu/g dataset4 2 0.12 8.50 0.06 bohr magnetons/mol"},{"location":"examples/mvsh_analysis/#a-simple-m-vs-h-analysis","title":"A Simple M vs. H Analysis\u00b6","text":"<p>Perhaps the most useful aspect of MagnetoPy is the ease of use when creating new analyses of magnetism data. One such analysis is included in the base MagnetoPy package and is handled by the <code>SimpleMvsHAnalysis</code> class. This class determines basic information about a hysteresis loop, i.e., saturation magnetization, coercive field, and remnant magnetization. In this example we'll build this class from scratch to explain how to use MagnetoPy to create new analyses.</p>"},{"location":"examples/mvsh_analysis/#exploratory-data-analysis","title":"Exploratory Data Analysis\u00b6","text":"<p>MagnetoPy will likely be used in a notebook environment (like this example notebook) to develop analyses interactively. For example, let's consider a dataset containing several M vs. H experiments at different temperatures. Note also that one of the experiments only contains a reverse field sweep.</p>"},{"location":"examples/mvsh_analysis/#creating-the-simplemvshanalysis-class","title":"Creating the <code>SimpleMvsHAnalysis</code> Class\u00b6","text":"<p>Having explored the data interactively, we can now create a class to perform the analysis. Using a class that implments MagnetoPy's <code>Analysis</code> protocol makes it easy to integrate the analysis into MagnetoPy and take advantage of its features, notably the serialization of datasets and analyses.</p> <p>The Notes section in the <code>Analysis</code> protocol documentation provides an outline of how a class implementing the <code>Analysis</code> protocol should be initialized. In summary, the <code>__init__</code> method should have the following arguments:</p> <ul> <li><code>dataset</code>: a <code>Magnetometry</code> object. Passing the entire <code>Magnetometry</code> object gives us access to all of the component experiments and sample information, as well as the methods used to process and access the data.</li> <li><code>parsing_args</code>: if we want to perform an analysis on, for example, a single <code>MvsH</code> experiment object within a dataset containing multiple <code>MvsH</code> objects, we'll need to pass some information in the <code>parsing_args</code> argument to tell the analysis class which experiment to use. In general, the values in the <code>parsing_args</code> argument should be used to work with the various methods within the <code>Magnetometry</code> and experiment classes. It is strongly recommended to use a <code>dataclass</code> to store the <code>parsing_args</code> values.</li> <li><code>fitting_args</code>: we may also need to pass some values to the analysis class specific to the model we are implementing. These will likely be starting values or limits for the fitting parameters. As with the <code>parsing_args</code> argument, it is strongly recommended to use a <code>dataclass</code> to store the <code>fitting_args</code> values.</li> </ul> <p>The only required attribute of the <code>Analysis</code> protocol is the <code>results</code> attribute, which should be a <code>dataclass</code> containing the results of the analysis. The <code>__init__</code> method should perform the analysis and store the results in <code>results</code>.</p> <p>We don't need any <code>fitting_args</code> for this analysis, so we'll just need to create some classes for <code>parsing_args</code> and <code>results</code>.</p>"},{"location":"examples/mvsh_analysis/#the-purpose-of-magnetopy","title":"The Purpose of MagnetoPy\u00b6","text":"<p>Now we can easily analyze M vs. H experiments in any dataset. Note that the processing done for each dataset is different -- these differences include: VSM vs DC measurements, settling vs scanning magnetic field, different scaling based on sample information, one dataset applies a field correction, etc. Despite all of these differences, MagnetoPy makes it easy to perform the same analysis on all of the datasets.</p>"},{"location":"examples/mvsh_analysis/#other-elements-in-analyses","title":"Other Elements in Analyses\u00b6","text":"<p>The <code>Analysis</code> protocol class just defines minimum requirements, and additional functionality may be desired in an analysis class. For example, for analyses which benefit from some sort of visualization, it may be useful to implement a <code>plot()</code> method. This could exist in the class itself or as a standalone method within the analysis module.</p>"},{"location":"examples/reading_dat_file/","title":"Reading a .dat File","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport magnetopy as mp\n</pre> from pathlib import Path  import magnetopy as mp In\u00a0[2]: Copied! <pre>DATA_PATH = Path(\"../../tests/data\")\n\nmvsh1 = mp.DatFile(DATA_PATH / \"mvsh1.dat\")\n</pre> DATA_PATH = Path(\"../../tests/data\")  mvsh1 = mp.DatFile(DATA_PATH / \"mvsh1.dat\") In\u00a0[3]: Copied! <pre>mvsh1.data\n</pre> mvsh1.data Out[3]: Comment Time Stamp (sec) Temperature (K) Magnetic Field (Oe) Moment (emu) M. Std. Err. (emu) Transport Action Averaging Time (sec) Frequency (Hz) Peak Amplitude (mm) ... Map 07 Map 08 Map 09 Map 10 Map 11 Map 12 Map 13 Map 14 Map 15 Map 16 0 NaN 3803627317 2.000165 70000.37500 0.736924 0.000996 1 1 13.006381 0.999015 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1 NaN 3803627320 2.000241 69995.39844 0.736522 0.001055 1 1 13.006381 0.999028 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 2 NaN 3803627325 1.999892 69746.85938 0.737400 0.001470 1 1 13.006381 0.999024 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 3 NaN 3803627334 2.000141 69286.15625 0.736039 0.000992 1 1 13.006381 0.999066 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 4 NaN 3803627335 1.999827 69246.48438 0.737444 0.001020 1 1 13.006381 0.999066 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 7300 NaN 3814233888 300.000000 -69003.28906 -0.067261 0.000070 1 1 13.006381 0.999186 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7301 NaN 3814233893 299.999634 -69254.71094 -0.067489 0.000071 1 1 13.006381 0.999208 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7302 NaN 3814233898 300.000000 -69508.75000 -0.067781 0.000076 1 1 13.006381 0.999197 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7303 NaN 3814233902 299.999451 -69750.06250 -0.067944 0.000072 1 1 13.006381 0.999192 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7304 NaN 3814233911 300.000183 -70000.16406 -0.068273 0.000078 1 1 13.006381 0.999175 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN <p>7305 rows \u00d7 89 columns</p> In\u00a0[4]: Copied! <pre>mvsh1.as_dict()\n</pre> mvsh1.as_dict() Out[4]: <pre>{'experiment_type': 'magnetometry',\n 'local_path': '../../tests/data/mvsh1.dat',\n 'length': 2604806,\n 'date_created': '2020-07-11T11:07:00',\n 'sha512': 'f9f8ac5d5b84cc00a57073d330c0f8b005e90201eadc588649388a35666f427bdc6beaa9c8ef5d58e70099a54ced7d9006f9800b8014639e790a2f0423acd6a5',\n 'experiments_in_file': ['mvsh']}</pre> In\u00a0[5]: Copied! <pre>mvsh1.experiments_in_file\n</pre> mvsh1.experiments_in_file Out[5]: <pre>['mvsh']</pre> <p>Let's look at some other files and see what's inside of them.</p> In\u00a0[6]: Copied! <pre>zfcfc1 = mp.DatFile(DATA_PATH / \"zfcfc1.dat\")\nzfcfc1.experiments_in_file\n</pre> zfcfc1 = mp.DatFile(DATA_PATH / \"zfcfc1.dat\") zfcfc1.experiments_in_file Out[6]: <pre>['zfcfc']</pre> In\u00a0[7]: Copied! <pre>zfc4 = mp.DatFile(DATA_PATH / 'zfc4a.dat')\nzfc4.experiments_in_file\n</pre> zfc4 = mp.DatFile(DATA_PATH / 'zfc4a.dat') zfc4.experiments_in_file Out[7]: <pre>['zfc']</pre> In\u00a0[8]: Copied! <pre>fc4 = mp.DatFile(DATA_PATH / \"fc4a.dat\")\nfc4.experiments_in_file\n</pre> fc4 = mp.DatFile(DATA_PATH / \"fc4a.dat\") fc4.experiments_in_file Out[8]: <pre>['fc']</pre> <p>In these cases MagnetoPy is getting information from the file names, but it can also determine the experiments from the file content. The following cell creates a copy of \"zfcfc1.dat\" named \"unlabeled_file.dat\" and determines the experiments from the actual data.</p> In\u00a0[9]: Copied! <pre>import shutil\nimport os\n\nshutil.copy(DATA_PATH / \"zfcfc1.dat\", DATA_PATH / \"unlabeled_file.dat\")\n\nunlabeled = mp.DatFile(DATA_PATH / \"unlabeled_file.dat\")\nos.remove(DATA_PATH / \"unlabeled_file.dat\")\n\nunlabeled.experiments_in_file\n</pre> import shutil import os  shutil.copy(DATA_PATH / \"zfcfc1.dat\", DATA_PATH / \"unlabeled_file.dat\")  unlabeled = mp.DatFile(DATA_PATH / \"unlabeled_file.dat\") os.remove(DATA_PATH / \"unlabeled_file.dat\")  unlabeled.experiments_in_file Out[9]: <pre>['zfcfc']</pre> <p>Here's a file with several experiments inside</p> In\u00a0[10]: Copied! <pre>dataset4 = mp.DatFile(DATA_PATH / \"dataset4.dat\")\ndataset4.experiments_in_file\n</pre> dataset4 = mp.DatFile(DATA_PATH / \"dataset4.dat\") dataset4.experiments_in_file Out[10]: <pre>['zfc', 'fc', 'zfc', 'fc', 'mvsh']</pre>"},{"location":"examples/reading_dat_file/#reading-a-dat-file","title":"Reading a .dat File\u00b6","text":"<p>The <code>DatFile</code> class reads and stores data from a .dat file from a Quantum Design MPMPS magnetometer. Create the <code>DatFile</code> object by passing the path to the .dat file to the constructor.</p>"},{"location":"examples/reading_dat_file/#the-data","title":"The <code>data</code>\u00b6","text":"<p><code>DatFile</code> creation executes some low-level parsing of the .dat file. For example, the file header and data sections are separated into <code>header</code> and <code>data</code> attributes. The <code>data</code> attribute is a Pandas <code>DataFrame</code> and gives access to the original data in a convenient form.</p>"},{"location":"examples/reading_dat_file/#serialization","title":"Serialization\u00b6","text":"<p>Serializing the <code>DatFile</code> object via the <code>as_dict()</code> method shows some of the other class attributes. Most of them are important solely for record keeping.</p>"},{"location":"examples/reading_dat_file/#determining-the-types-of-experiments-in-the-file","title":"Determining the Types of Experiments in the File\u00b6","text":"<p>The <code>experiments_in_file</code> attribute is useful for higher level classes (particularly the <code>Dataset</code> class) to determine how to further handle <code>DatFile</code> objects. In this case, <code>mvsh1.dat</code> contains the <code>mvsh</code> (aka M vs. H, variable field magnetization, or hysteresis) experiment. Actually it contains several <code>mvsh</code> experiments at different temperatures, but the separation of that data is dealt with by the <code>MvsH</code> class. For now it's just helpful to have a list of the types of experiments in the file.</p>"},{"location":"examples/reading_dat_file/#experiment-determination-method","title":"Experiment Determination Method\u00b6","text":"<p>The experiment determination is done by a class method <code>_get_experiments_in_file</code> shown here:</p> <pre>def _get_experiments_in_file(self) -&gt; list[str]:\n    experiments = []\n    if self.comments:\n        for comments in self.comments.values():\n            for comment in comments:\n                if comment.lower() in [\"mvsh\", \"zfc\", \"fc\", \"zfcfc\"]:\n                    experiments.append(comment.lower())\n    elif (filename := filename_label(self.local_path.name, \"\", True)) != \"unknown\":\n        experiments.append(filename)\n    else:\n        if len(self.data[\"Magnetic Field (Oe)\"].unique()) == 1:\n            experiments.append(\"zfcfc\")\n        else:\n            experiments.append(\"mvsh\")\n    return experiments\n</pre> <p>So the order of precedence is:</p> <ol> <li>Comments in the file. Note that these are comments in the \"[DATA]\" section of the file, which are inserted using the \"Add comment\" option in MultiVu used when creating the sequence. This allows for multiple experiments to be easily read from a single file, as was done in \"dataset4.dat\" in the example above.</li> <li>Filename. This is particularly useful for <code>\"fc\"</code> and <code>\"zfc\"</code> experiments in files without comments, as the method used in #3 below will not be able to distinguish between the two.</li> <li>Reading the data. With knowledge of what typical experiments and files look like, we can make some assumptions about the data. For example, distinguishing between a \"zfcfc\" file and an \"mvsh\" file relies on the fact that typically files containing \"zfcfc\" experiments will only have one unique magnetic field value.</li> </ol> <p>As is discussed in the File Formatting page, commented files are strongly encouraged, as it removes any ambiguity in the experiment determination.</p>"},{"location":"examples/rwdat_file/","title":"Raw Data and the .rw.dat File","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport magnetopy as mp\n\nDATA_PATH = Path(\"../../tests/data\")\nzfc5 = mp.DatFile(DATA_PATH / \"zfc5.dat\", parse_raw=True)\n</pre> from pathlib import Path  import magnetopy as mp  DATA_PATH = Path(\"../../tests/data\") zfc5 = mp.DatFile(DATA_PATH / \"zfc5.dat\", parse_raw=True) <p>The raw data is added as a column called <code>\"raw_scan\"</code> in the <code>data</code> attribute (you'll likely have to scroll to the right end of the following <code>DataFrame</code>).</p> In\u00a0[2]: Copied! <pre>zfc5.data.head()\n</pre> zfc5.data.head() Out[2]: Comment Time Stamp (sec) Temperature (K) Magnetic Field (Oe) Moment (emu) M. Std. Err. (emu) Transport Action Averaging Time (sec) Frequency (Hz) Peak Amplitude (mm) ... Map 08 Map 09 Map 10 Map 11 Map 12 Map 13 Map 14 Map 15 Map 16 raw_scan 0 NaN 3.876038e+09 2.001670 199.96196 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN DcMeasurement(199.96 Oe, 2.00 K) 1 NaN 3.876038e+09 2.201302 199.96196 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN DcMeasurement(199.96 Oe, 2.20 K) 2 NaN 3.876039e+09 2.401609 199.96196 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN DcMeasurement(199.96 Oe, 2.40 K) 3 NaN 3.876039e+09 2.601313 199.96196 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN DcMeasurement(199.96 Oe, 2.60 K) 4 NaN 3.876039e+09 2.800433 199.96196 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN DcMeasurement(199.96 Oe, 2.80 K) <p>5 rows \u00d7 90 columns</p> In\u00a0[3]: Copied! <pre>dc_measurement: mp.DcMeasurement = zfc5.data[\"raw_scan\"].iloc[0]\ndc_measurement\n</pre> dc_measurement: mp.DcMeasurement = zfc5.data[\"raw_scan\"].iloc[0] dc_measurement Out[3]: <pre>DcMeasurement(199.96 Oe, 2.00 K)</pre> In\u00a0[4]: Copied! <pre>dc_measurement.__dict__\n</pre> dc_measurement.__dict__ Out[4]: <pre>{'up': RawDcScan(up, 199.96 Oe, 2.00 K),\n 'down': RawDcScan(down, 199.96 Oe, 2.00 K),\n 'fit_scan': FitDcScan(3876038315.32042 sec)}</pre> <p>The <code>RawDcScan</code> class contains information stored in the individual scan headers as well as the actual raw voltage data. Here are the attributes containing the information stored in the scan header:</p> In\u00a0[5]: Copied! <pre>up_scan = dc_measurement.up\n{attribute: value for attribute, value in up_scan.__dict__.items() if attribute not in [\"text\", \"data\"]}\n</pre> up_scan = dc_measurement.up {attribute: value for attribute, value in up_scan.__dict__.items() if attribute not in [\"text\", \"data\"]}  Out[5]: <pre>{'direction': 'up',\n 'low_temp': 1.99824821949005,\n 'high_temp': 2.00186586380005,\n 'avg_temp': 2.00000633691487,\n 'low_field': 199.961959838867,\n 'high_field': 199.961959838867,\n 'drift': 0.00359456760634202,\n 'slope': 0.000410807726439089,\n 'squid_range': 10.0,\n 'given_center': 33.4032707214355,\n 'calculated_center': 33.3980560302734,\n 'amp_fixed': -1.51181256771088,\n 'amp_free': -1.51181125640869,\n 'start_time': 3876038306.03405}</pre> <p>and here is the data:</p> In\u00a0[6]: Copied! <pre>up_scan.data.head()\n</pre> up_scan.data.head() Out[6]: Time Stamp (sec) Raw Position (mm) Raw Voltage (V) Processed Voltage (V) 0 3.876038e+09 15.986061 0.036862 0.304230 1 3.876038e+09 16.160303 0.045246 0.312542 2 3.876038e+09 16.333939 0.054017 0.321242 3 3.876038e+09 16.508030 0.063230 0.330383 4 3.876038e+09 16.682274 0.072727 0.339809 <p>The <code>FitScan</code> object only contains the time stamp at which it was created and the data from the fit:</p> In\u00a0[7]: Copied! <pre>fit_scan = dc_measurement.fit_scan\nfit_scan.start_time\n</pre> fit_scan = dc_measurement.fit_scan fit_scan.start_time Out[7]: <pre>3876038315.32042</pre> In\u00a0[8]: Copied! <pre>fit_scan.data.head()\n</pre> fit_scan.data.head() Out[8]: Time Stamp (sec) Raw Position (mm) Fixed C Fitted (V) Free C Fitted (V) 0 3.876038e+09 15.903271 0.262449 0.327815 1 3.876038e+09 16.078270 0.269636 0.337026 2 3.876038e+09 16.253271 0.277069 0.346514 3 3.876038e+09 16.428270 0.284755 0.356277 4 3.876038e+09 16.603271 0.292696 0.366315 In\u00a0[9]: Copied! <pre>fig, ax = mp.plot_raw(zfc5.data, (0, 1))\n</pre> fig, ax = mp.plot_raw(zfc5.data, (0, 1)) <p>The same method exists on the <code>DatFile</code> object itself, so it's not necessary to pass in the data. We'll still need the <code>data_slice</code> argument in this case, though.</p> In\u00a0[10]: Copied! <pre>fig, ax = zfc5.plot_raw((0, 1))\n</pre> fig, ax = zfc5.plot_raw((0, 1)) <p>Note that the y-axis is <code>\"Scaled Voltage (V)\"</code>. This scaling is based on the <code>squid_range</code> (an attribute stored in both directional scan headers). Note that the scaling is only done during plotting, and the actual data is unchanged. This may be important for someone looking to implement in-depth analysis of the raw data (e.g., manual background subtractions, residual analysis, etc.).</p> <p>The default behavior of <code>plot_raw</code> is to plot the processed data from a single directional scan. The processed data is adjusted for drift and offset. We can also use <code>plot_raw</code> to plot the fit data -- i.e., the simulated data from the results of the fit performed by the Quantum Design software.</p> In\u00a0[11]: Copied! <pre>fig, ax = zfc5.plot_raw((0, 1), scan=\"fit\")\n</pre> fig, ax = zfc5.plot_raw((0, 1), scan=\"fit\") <p>Typically we'll be using <code>plot_raw</code> and related functions/methods to plot many scans. For example,</p> In\u00a0[12]: Copied! <pre>fig, ax = zfc5.plot_raw()\n</pre> fig, ax = zfc5.plot_raw() <p>Lastly, MagnetoPy provides plotting functionality for looking at the residual curves. The following plots illustrate the difference between having a free-floating or a fixed center when fitting the data.</p> <p>The default behavior of <code>plot_raw_residual</code> uses the free fit center.</p> In\u00a0[13]: Copied! <pre>fig, ax = zfc5.plot_raw_residual()\n</pre> fig, ax = zfc5.plot_raw_residual() <p>Here's what the residuals look like when the center is fixed:</p> In\u00a0[14]: Copied! <pre>fig, ax = zfc5.plot_raw_residual(center=\"fixed\")\n</pre> fig, ax = zfc5.plot_raw_residual(center=\"fixed\") <p>The example used in this notebook is a file containing a single ZFC measurement, so the <code>DatFile</code> method works well for visualizing the raw data. In situations where multiple experiments are in the same file or for M vs. H measurements, the raw data visualization at the <code>DatFile</code> level may become convoluted. For example, here's a file containing a single M vs. H measurement:</p> In\u00a0[15]: Copied! <pre>mvsh5 = mp.DatFile(DATA_PATH / \"mvsh5.dat\", parse_raw=True)\nfig, ax = mvsh5.plot_raw()\n</pre> mvsh5 = mp.DatFile(DATA_PATH / \"mvsh5.dat\", parse_raw=True) fig, ax = mvsh5.plot_raw() <p>The plot above shows the raw data from both forward and reverse scans. It'd be much more clear to plot the data from each scan separately. While this could be done by passing a <code>data_slice</code> argument to <code>plot_raw</code>, MagnetoPy provides <code>plot_raw</code> methods in experiment-specific classes. We'll see in the next tutorial how to use the <code>MvsH</code> class for this purpose.</p>"},{"location":"examples/rwdat_file/#raw-data-and-the-rwdat-file","title":"Raw Data and the .rw.dat File\u00b6","text":"<p>The raw data collected during a dc magnetic measurement is voltage vs. position data collected by moving the sample through the magnetometer's gradiometer. Quantum Design's MPMS3 stores this data in a .rw.dat file with the same name as the .dat file containing the processed data.</p> <p>MagnetoPy gives an easy way to access this raw data by associating the individual scans within the .rw.dat file with the corresponding data points in the .dat file.</p> <p>When creating the <code>DatFile</code> object add <code>parse_raw = True</code> to the arguments. If a .rw.dat file exists with the same name within the same directory, the <code>DatFile</code> object will automatically parse the raw data and associate it with the corresponding data points in the .dat file.</p>"},{"location":"examples/rwdat_file/#the-dcmeasurement-class","title":"The <code>DcMeasurement</code> Class\u00b6","text":"<p>Each element in the <code>\"raw_scan\"</code> column is a <code>DcMeasurement</code> object, which contains the raw voltage data from the directional scans (stored as <code>RawScan</code> objects), as well as the results of the fit performed by the MPMS software used to convert the voltage to a magnetic moment (stored as a <code>FitDcScan</code> object).</p>"},{"location":"examples/rwdat_file/#plotting-raw-data-and-residuals","title":"Plotting Raw Data and Residuals\u00b6","text":"<p>MagnetoPy has a method <code>plot_raw</code> that can be used for plotting the raw data. Typically it'd be used to plot a series of voltage curves, but by passing a <code>data_slice</code> argument selecting a single scan, we can plot the raw data from a single scan:</p>"},{"location":"examples/zfcfc/","title":"The ZFC and FC Experiment Classes","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport magnetopy as mp\n\nDATA_PATH = Path(\"../../tests/data\")\n</pre> from pathlib import Path  import magnetopy as mp  DATA_PATH = Path(\"../../tests/data\") In\u00a0[2]: Copied! <pre>zfc1 = mp.ZFC(DATA_PATH / \"zfcfc1.dat\")\nfc1 = mp.FC(DATA_PATH / \"zfcfc1.dat\")\nzfc1, fc1\n</pre> zfc1 = mp.ZFC(DATA_PATH / \"zfcfc1.dat\") fc1 = mp.FC(DATA_PATH / \"zfcfc1.dat\") zfc1, fc1 Out[2]: <pre>(ZFC at 100 Oe, FC at 100 Oe)</pre> <p>The <code>as_dict()</code> method returns a dictionary of information about the experiment and any processing that has been performed on it. Note that these are all attributes of the <code>ZFCFC</code> object, and can be accessed directly as well.</p> <p>Since we just created these objects and haven't done any processing the <code>scaling</code> attributes will be empty lists.</p> In\u00a0[3]: Copied! <pre>zfc1.as_dict()\n</pre> zfc1.as_dict() Out[3]: <pre>{'origin_file': 'zfcfc1.dat',\n 'field': 100,\n 'temperature_range': (5.00255632400513, 299.939453125),\n 'scaling': []}</pre> In\u00a0[4]: Copied! <pre>fc1.as_dict()\n</pre> fc1.as_dict() Out[4]: <pre>{'origin_file': 'zfcfc1.dat',\n 'field': 100,\n 'temperature_range': (5.00277781486511, 299.924865722656),\n 'scaling': []}</pre> <p>The data is stored in the <code>data</code> attribute. The columns of this <code>DataFrame</code> are created directly from the data file which, in this case, is a .dat file from a Quantum Design MPMS3. There are two additional columns at the end, <code>\"uncorrected_moment\"</code> and <code>\"uncorrected_moment_err\"</code>. The .dat file contains the magnetization data in one of two columns, depending on whether the measurements were done in DC or VSM mode. The <code>ZFCFC</code> class automatically determines which column contains the data, and stores it in the <code>\"uncorrected_moment\"</code> and <code>\"uncorrected_moment_err\"</code> columns, which are used for subsequent processing.</p> In\u00a0[5]: Copied! <pre>zfc1.data.head()\n</pre> zfc1.data.head() Out[5]: Comment Time Stamp (sec) Temperature (K) Magnetic Field (Oe) Moment (emu) M. Std. Err. (emu) Transport Action Averaging Time (sec) Frequency (Hz) Peak Amplitude (mm) ... Map 09 Map 10 Map 11 Map 12 Map 13 Map 14 Map 15 Map 16 uncorrected_moment uncorrected_moment_err 0 NaN 3.841157e+09 5.002556 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.004336 0.000216 1 NaN 3.841157e+09 5.530379 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.004346 0.000217 2 NaN 3.841157e+09 6.279785 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.004360 0.000217 3 NaN 3.841157e+09 7.018987 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.004381 0.000219 4 NaN 3.841157e+09 7.762416 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.004405 0.000220 <p>5 rows \u00d7 91 columns</p> In\u00a0[6]: Copied! <pre>fc1.data.head()\n</pre> fc1.data.head() Out[6]: Comment Time Stamp (sec) Temperature (K) Magnetic Field (Oe) Moment (emu) M. Std. Err. (emu) Transport Action Averaging Time (sec) Frequency (Hz) Peak Amplitude (mm) ... Map 09 Map 10 Map 11 Map 12 Map 13 Map 14 Map 15 Map 16 uncorrected_moment uncorrected_moment_err 0 NaN 3.841161e+09 5.002778 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.011784 0.000588 1 NaN 3.841161e+09 5.524109 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.011784 0.000588 2 NaN 3.841161e+09 6.282274 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.011783 0.000588 3 NaN 3.841162e+09 7.036755 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.011782 0.000588 4 NaN 3.841162e+09 7.772961 100.072647 NaN NaN 6 NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN 0.011782 0.000588 <p>5 rows \u00d7 91 columns</p> In\u00a0[7]: Copied! <pre>zfc4 = mp.ZFC(DATA_PATH / \"zfc4a.dat\")\nfc4 = mp.FC(DATA_PATH / \"fc4a.dat\")\nzfc4, fc4\n</pre> zfc4 = mp.ZFC(DATA_PATH / \"zfc4a.dat\") fc4 = mp.FC(DATA_PATH / \"fc4a.dat\") zfc4, fc4 Out[7]: <pre>(ZFC at 100 Oe, FC at 100 Oe)</pre> In\u00a0[8]: Copied! <pre>try:\n    zfc4 = mp.ZFC(DATA_PATH / \"fc4a.dat\", suppress_warnings=True)\nexcept mp.experiments.zfcfc.FieldDetectionError as e:\n    print(e)\n</pre> try:     zfc4 = mp.ZFC(DATA_PATH / \"fc4a.dat\", suppress_warnings=True) except mp.experiments.zfcfc.FieldDetectionError as e:     print(e) <pre>Could not autodetect field for zfc. When not specificying a field, the DatFile must contain exactly one field. Found 0 fields.\n</pre> In\u00a0[9]: Copied! <pre>zfc5 = mp.FC(DATA_PATH / \"zfc5.dat\")\nzfc5.as_dict()\n</pre> zfc5 = mp.FC(DATA_PATH / \"zfc5.dat\") zfc5.as_dict() <pre>C:\\Users\\pcb74\\Documents\\lab\\Python\\MagnetoPy\\magnetopy\\data_files.py:398: FileNameWarning: You have initialized a FC object but the file name zfc5.dat indicates that it is ZFC. You can suppress this warning by passing `suppress_warnings=True` to the constructor.\n  warnings.warn(\n</pre> Out[9]: <pre>{'origin_file': 'zfc5.dat',\n 'field': 200,\n 'temperature_range': (2.00167036056519, 299.911483764648),\n 'scaling': []}</pre> In\u00a0[10]: Copied! <pre>zfc5 = mp.FC(DATA_PATH / \"zfc5.dat\", suppress_warnings=True)\nzfc5.as_dict()\n</pre> zfc5 = mp.FC(DATA_PATH / \"zfc5.dat\", suppress_warnings=True) zfc5.as_dict() Out[10]: <pre>{'origin_file': 'zfc5.dat',\n 'field': 200,\n 'temperature_range': (2.00167036056519, 299.911483764648),\n 'scaling': []}</pre> In\u00a0[11]: Copied! <pre>try:\n    zfc4 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\")\nexcept mp.experiments.zfcfc.FieldDetectionError as e:\n    print(e)\n</pre> try:     zfc4 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\") except mp.experiments.zfcfc.FieldDetectionError as e:     print(e) <pre>Could not autodetect field for zfc. When not specificying a field, the DatFile must contain exactly one field. Found 2 fields.\n</pre> In\u00a0[12]: Copied! <pre>zfc4_100 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=100)\nzfc4_1000 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=1000)\nfc4_100 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=100)\nfc4_1000 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=1000)\nzfc4_100, zfc4_1000, fc4_100, fc4_1000\n</pre> zfc4_100 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=100) zfc4_1000 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=1000) fc4_100 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=100) fc4_1000 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=1000) zfc4_100, zfc4_1000, fc4_100, fc4_1000 Out[12]: <pre>(ZFC at 100 Oe, ZFC at 1000 Oe, FC at 100 Oe, FC at 1000 Oe)</pre> In\u00a0[13]: Copied! <pre>zfc = mp.ZFC.get_all_in_file(DATA_PATH / \"zfcfc4.dat\")\nzfc\n</pre> zfc = mp.ZFC.get_all_in_file(DATA_PATH / \"zfcfc4.dat\") zfc Out[13]: <pre>[ZFC at 100.0 Oe, ZFC at 1000.0 Oe]</pre> In\u00a0[14]: Copied! <pre>fc = mp.FC.get_all_in_file(DATA_PATH / \"zfcfc4.dat\")\nfc\n</pre> fc = mp.FC.get_all_in_file(DATA_PATH / \"zfcfc4.dat\") fc Out[14]: <pre>[FC at 100.0 Oe, FC at 1000.0 Oe]</pre> In\u00a0[15]: Copied! <pre>zfc = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=1000)\nzfc.simplified_data().head()\n</pre> zfc = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=1000) zfc.simplified_data().head() Out[15]: time temperature field moment moment_err chi chi_err chi_t chi_t_err 0 3860761286 4.999953 1000.262024 0.002310 2.710000e-07 0.000002 2.709290e-10 0.000012 1.354632e-09 1 3860761289 5.039120 1000.262024 0.002310 2.820000e-07 0.000002 2.819261e-10 0.000012 1.420660e-09 2 3860761290 5.159641 1000.262024 0.002310 2.790000e-07 0.000002 2.789269e-10 0.000012 1.439163e-09 3 3860761293 5.360177 1000.262024 0.002311 3.160000e-07 0.000002 3.159172e-10 0.000012 1.693372e-09 4 3860761295 5.510782 1000.262024 0.002312 3.110000e-07 0.000002 3.109185e-10 0.000013 1.713404e-09 <p>In this case we haven't done any scaling or processing, so the values of the <code>\"moment\"</code> and <code>\"moment_err\"</code> columns are the same as the values in the previously mentioned <code>\"uncorrected_moment\"</code> and <code>\"uncorrected_moment_err\"</code> columns. We'll see how to scale the data in the next section.</p> In\u00a0[16]: Copied! <pre>zfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\")\nprint(\n    f\"\"\"{zfc5_sample_info.mass = }\n{zfc5_sample_info.eicosane_mass = }\n{zfc5_sample_info.molecular_weight = }\n{zfc5_sample_info.diamagnetic_correction = }\"\"\"\n)\n</pre> zfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\") print(     f\"\"\"{zfc5_sample_info.mass = } {zfc5_sample_info.eicosane_mass = } {zfc5_sample_info.molecular_weight = } {zfc5_sample_info.diamagnetic_correction = }\"\"\" ) <pre>zfc5_sample_info.mass = 10.2\nzfc5_sample_info.eicosane_mass = 28.8\nzfc5_sample_info.molecular_weight = 1229.56\nzfc5_sample_info.diamagnetic_correction = -0.00056176\n</pre> In\u00a0[17]: Copied! <pre>zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\")\nzfc5.scale_moment(\n    mass = zfc5_sample_info.mass,\n    eicosane_mass = zfc5_sample_info.eicosane_mass,\n    molecular_weight = zfc5_sample_info.molecular_weight,\n    diamagnetic_correction = zfc5_sample_info.diamagnetic_correction,\n)\n</pre> zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\") zfc5.scale_moment(     mass = zfc5_sample_info.mass,     eicosane_mass = zfc5_sample_info.eicosane_mass,     molecular_weight = zfc5_sample_info.molecular_weight,     diamagnetic_correction = zfc5_sample_info.diamagnetic_correction, ) <p>The <code>scaling</code> attribute records the scaling that was applied as a list of manipulations. In this case, with a mass, molecular weight, and eicosane mass, the scaling is recorded as a <code>\"molar\"</code> scaling with <code>\"eicosane\"</code> and <code>\"diamagnetic_correction\"</code> corrections:</p> In\u00a0[18]: Copied! <pre>zfc5.scaling\n</pre> zfc5.scaling Out[18]: <pre>['molar', 'eicosane', 'diamagnetic_correction']</pre> In\u00a0[19]: Copied! <pre>zfc5.simplified_data().head()\n</pre> zfc5.simplified_data().head() Out[19]: time temperature field moment moment_err chi chi_err chi_t chi_t_err 0 3.876038e+09 2.001670 199.96196 0.099940 0.005089 2.791363 0.142138 5.587388 0.284513 1 3.876038e+09 2.201302 199.96196 0.160750 0.008121 4.489811 0.226826 9.883431 0.499313 2 3.876039e+09 2.401609 199.96196 0.186832 0.009422 5.218290 0.263168 12.532294 0.632026 3 3.876039e+09 2.601313 199.96196 0.201812 0.010170 5.636663 0.284041 14.662723 0.738880 4 3.876039e+09 2.800433 199.96196 0.212596 0.010708 5.937875 0.299070 16.628622 0.837524 In\u00a0[20]: Copied! <pre>zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\")\nfc5 = mp.FC(DATA_PATH / \"fc5.dat\")\nfig, ax = mp.plot_zfcfc(zfc5, fc5)\n</pre> zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\") fc5 = mp.FC(DATA_PATH / \"fc5.dat\") fig, ax = mp.plot_zfcfc(zfc5, fc5) In\u00a0[21]: Copied! <pre>zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\")\nfc5 = mp.FC(DATA_PATH / \"fc5.dat\")\nzfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\")\nfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"fc5.dat\")\nzfc5.scale_moment(\n    mass = zfc5_sample_info.mass,\n)\nfc5.scale_moment(\n    mass = fc5_sample_info.mass,\n)\nfig, ax = mp.plot_zfcfc(zfc5, fc5)\n</pre> zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\") fc5 = mp.FC(DATA_PATH / \"fc5.dat\") zfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\") fc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"fc5.dat\") zfc5.scale_moment(     mass = zfc5_sample_info.mass, ) fc5.scale_moment(     mass = fc5_sample_info.mass, ) fig, ax = mp.plot_zfcfc(zfc5, fc5) In\u00a0[22]: Copied! <pre>zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\")\nfc5 = mp.FC(DATA_PATH / \"fc5.dat\")\nzfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\")\nfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"fc5.dat\")\nzfc5.scale_moment(\n    mass = zfc5_sample_info.mass,\n    molecular_weight=zfc5_sample_info.molecular_weight,\n)\nfc5.scale_moment(\n    mass = fc5_sample_info.mass,\n    molecular_weight=fc5_sample_info.molecular_weight,\n)\nfig, ax = mp.plot_zfcfc(zfc5, fc5)\n</pre> zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\") fc5 = mp.FC(DATA_PATH / \"fc5.dat\") zfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\") fc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"fc5.dat\") zfc5.scale_moment(     mass = zfc5_sample_info.mass,     molecular_weight=zfc5_sample_info.molecular_weight, ) fc5.scale_moment(     mass = fc5_sample_info.mass,     molecular_weight=fc5_sample_info.molecular_weight, ) fig, ax = mp.plot_zfcfc(zfc5, fc5) <p>The default behavior is to plot magnetization, but that can be changed by passing a <code>y_val</code> argument. Possible values are <code>\"moment\"</code>, <code>\"chi\"</code>, and <code>\"chi_t\"</code>.</p> In\u00a0[23]: Copied! <pre>zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\")\nfc5 = mp.FC(DATA_PATH / \"fc5.dat\")\nzfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\")\nfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"fc5.dat\")\nzfc5.scale_moment(\n    mass = zfc5_sample_info.mass,\n    molecular_weight=zfc5_sample_info.molecular_weight,\n)\nfc5.scale_moment(\n    mass = fc5_sample_info.mass,\n    molecular_weight=fc5_sample_info.molecular_weight,\n)\nfig, ax = mp.plot_zfcfc(zfc5, fc5, y_val=\"chi_t\")\n</pre> zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\") fc5 = mp.FC(DATA_PATH / \"fc5.dat\") zfc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfc5.dat\") fc5_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"fc5.dat\") zfc5.scale_moment(     mass = zfc5_sample_info.mass,     molecular_weight=zfc5_sample_info.molecular_weight, ) fc5.scale_moment(     mass = fc5_sample_info.mass,     molecular_weight=fc5_sample_info.molecular_weight, ) fig, ax = mp.plot_zfcfc(zfc5, fc5, y_val=\"chi_t\") In\u00a0[24]: Copied! <pre>zfc4_100 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=100)\nzfc4_1000 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=1000)\nfc4_100 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=100)\nfc4_1000 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=1000)\nzfcfc4_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfcfc4.dat\")\nzfc4_100.scale_moment(zfcfc4_sample_info.mass)\nzfc4_1000.scale_moment(zfcfc4_sample_info.mass)\nfc4_100.scale_moment(zfcfc4_sample_info.mass)\nfc4_1000.scale_moment(zfcfc4_sample_info.mass)\n\nfig, ax = mp.plot_zfcfc([zfc4_100, zfc4_1000], [fc4_100, fc4_1000])\n</pre> zfc4_100 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=100) zfc4_1000 = mp.ZFC(DATA_PATH / \"zfcfc4.dat\", field=1000) fc4_100 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=100) fc4_1000 = mp.FC(DATA_PATH / \"zfcfc4.dat\", field=1000) zfcfc4_sample_info = mp.SampleInfo.from_dat_file(DATA_PATH / \"zfcfc4.dat\") zfc4_100.scale_moment(zfcfc4_sample_info.mass) zfc4_1000.scale_moment(zfcfc4_sample_info.mass) fc4_100.scale_moment(zfcfc4_sample_info.mass) fc4_1000.scale_moment(zfcfc4_sample_info.mass)  fig, ax = mp.plot_zfcfc([zfc4_100, zfc4_1000], [fc4_100, fc4_1000]) <p>The <code>normalized</code> argument is often useful for multiple sets of ZFC/FC experiments.</p> In\u00a0[25]: Copied! <pre>fig, ax = mp.plot_zfcfc([zfc4_100, zfc4_1000], [fc4_100, fc4_1000], normalized=True)\n</pre> fig, ax = mp.plot_zfcfc([zfc4_100, zfc4_1000], [fc4_100, fc4_1000], normalized=True) In\u00a0[26]: Copied! <pre>zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\", parse_raw=True)\nfig, ax = zfc5.plot_raw()\n</pre> zfc5 = mp.ZFC(DATA_PATH / \"zfc5.dat\", parse_raw=True) fig, ax = zfc5.plot_raw() In\u00a0[27]: Copied! <pre>fig, ax = zfc5.plot_raw_residual()\n</pre> fig, ax = zfc5.plot_raw_residual()"},{"location":"examples/zfcfc/#the-zfc-and-fc-experiment-classes","title":"The <code>ZFC</code> and <code>FC</code> Experiment Classes\u00b6","text":"<p>The <code>ZFC</code> and <code>FC</code> classes contain the data of individual zero-field cooled and field cooled, respectively, experiments (i.e., variable temperature magnetization), along with a number of methods used for processing and working with the data.</p> <p>The <code>ZFC</code> and <code>FC</code> classes are child classes of the <code>ZFCFC</code> class. When discussing elements that apply to both we may refer to <code>ZFCFC</code>.</p>"},{"location":"examples/zfcfc/#creating-zfc-and-fc-objects-from-files","title":"Creating <code>ZFC</code> and <code>FC</code> Objects from Files\u00b6","text":"<p>Note: The File Formatting page contains detailed information on how MagnetoPy automatically reads and parses the contents of a data file.</p>"},{"location":"examples/zfcfc/#files-containing-a-single-zfcfc-experiment","title":"Files Containing a Single ZFCFC Experiment\u00b6","text":"<p>It's common for a single data file to contain a ZFC experiment followed by an FC experiment. We can create <code>ZFC</code> and <code>FC</code> objects by passing such a file to their constructors, which will then extract only the relevant data from the file.</p>"},{"location":"examples/zfcfc/#files-containing-a-single-zfc-or-fc-experiment","title":"Files Containing a Single ZFC or FC Experiment\u00b6","text":"<p>Pass the file path to the correct constructor. If the file is commented, passing a ZFC file to the <code>FC</code> constructor (or vice versa) will raise an error. If the file is not commented, the file name includes the word \"zfc\" or \"fc\", and is passed to the constructor that doesn't match the file name, the object will be created but a warning will be raised. The warning can be suppressed by passing <code>suppress_warnings=True</code> to the constructor.</p>"},{"location":"examples/zfcfc/#files-containing-multiple-zfc-andor-fc-experiments","title":"Files Containing Multiple ZFC and/or FC Experiments\u00b6","text":"<p>This is currently only supported for commented files. If there are multiple ZFCFC experiments at different fields, you'll need to pass the <code>field</code> value to the constructor.</p>"},{"location":"examples/zfcfc/#creating-multiple-zfc-or-fc-objects-from-a-single-file","title":"Creating Multiple ZFC or FC Objects from a Single File\u00b6","text":"<p>If the file contains multiple ZFC and/or FC experiments, you can create a list of <code>ZFC</code>/<code>FC</code> objects using the <code>get_all_in_file()</code> method.</p>"},{"location":"examples/zfcfc/#simplified-data","title":"Simplified Data\u00b6","text":"<p>The columns given from the data file are likely more than we'll need for 98% of what we typically do with the data. Additionally, when MagnetoPy supports other file types from other instruments, we'll still want a standard interface upon which we can build anlayses and visualization methods. The <code>simplified_data()</code> method returns a <code>DataFrame</code> with only the relevant columns for a <code>ZFCFC</code> experiment:</p>"},{"location":"examples/zfcfc/#scaling-the-moment","title":"Scaling the Moment\u00b6","text":"<p>Scaling is something you'll likely do through the <code>Magnetometry</code> class, discussed in a later example notebook. However, the <code>Magnetometry</code> class uses methods within the <code>ZFCFC</code> class, and these methods can be used directly as well.</p> <p>Scaling can be done using the <code>scale_moment()</code> method. As is described in the underlying utility function, this method adds columns to the <code>data</code> attribute of the <code>ZFCFC</code> object that contain the magnetic moment, magnetic susceptibility, and magnetic susceptibility times temperature (and their errors). The columns added are <code>\"moment\"</code>, <code>\"moment_err\"</code>, <code>\"chi\"</code>, <code>\"chi_err\"</code>, <code>\"chi_t\"</code>, and <code>\"chi_t_err\"</code>. The units of these values depend on the values of the <code>mass</code>, <code>eicosane_mass</code>, <code>molecular_weight</code>, and <code>diamagnetic_correction</code> which are passed as arguments. A record of what scaling was applied is added to the <code>scaling</code> attribute of the <code>ZFCFC</code> object.</p> <p>Here are the currently supported scaling options:</p> <ul> <li>If <code>mass</code> is given but not <code>molecular_weight</code>, the only available scaling is a mass correction.</li> <li>If <code>mass</code> and <code>molecular</code> weight are given, a molar correction is applied. The molar correction can be further modified by giving <code>eicosane_mass</code> and/or <code>diamagnetic_correction</code>.</li> </ul> <p>We'll use the <code>SampleInfo</code> class to read the sample information from the header of the .dat file:</p>"},{"location":"examples/zfcfc/#plotting","title":"Plotting\u00b6","text":"<p>The MagnetoPy function <code>plot_zfcfc()</code> provides basic plotting capabilities for <code>ZFCFC</code> objects. It can be used to plot a single pair of ZFC/FC experiments or multiple pairs of ZFC/FC experiments. In the former case it calls <code>plot_single_zfcfc()</code> and in the latter case it calls <code>plot_multiple_zfcfc()</code>. It shouldn't be necessary, but these functions can be called directly if desired.</p> <p>There is a convenience function in the <code>Magnetometry</code> class for plotting ZFCFC experiments.</p>"},{"location":"examples/zfcfc/#plot-a-single-zfcfc-experiment","title":"Plot a Single <code>ZFCFC</code> Experiment\u00b6","text":"<p>The first two arguments of <code>plot_zfcfc()</code> must be the <code>ZFC</code> and <code>FC</code> objects. Note how the y-axis units change based on scaling. The default behavior is to plot magnetization.</p>"},{"location":"examples/zfcfc/#plotting-multiple-zfcfc-experiments","title":"Plotting Multiple <code>ZFCFC</code> Experiments\u00b6","text":"<p>The <code>plot_zfcfc()</code> function can also be used to plot multiple pairs of ZFC/FC experiments. In this case the first two arguments must be lists of <code>ZFC</code> and <code>FC</code> objects. The <code>label</code> argument can be used to label the curves in the legend, otherwise the field values are used as labels.</p>"},{"location":"examples/zfcfc/#plotting-raw-data","title":"Plotting Raw Data\u00b6","text":"<p>The <code>ZFCFC</code> class has <code>plot_raw()</code> and <code>plot_raw_residuals()</code> methods for plotting the raw data. These are often more convenient than the related <code>DatFile</code> methods, since the <code>DatFile</code> method would require the user to slice out ZFC or FC data from a file which contained both.</p>"}]}